\chapter{EasyCrypt and Game-based security}
\label{ch:EasyCrypt}
In this chapter, we introduce the \easycrypt\ proof assistant for proving the security
of cryptographic protocols. \easycrypt\ allows us to reason about cryptographic
protocols in the code-based game-playing paradigm. We can then prove the security of programs by defining
``games'', where the protocol is said to be secure if the game is won.
Another common technique for game-based security is to show that winning the game is
equivalent to solving a hard computational problem. More formally, we can show
the equivalence by proving that the program describing the game is indistinguishable
from the program describing the hard computational problem.
To facilitate reasoning about programs, \easycrypt\ provides us with three
logics: a relational probabilistic
Hoare logic (\textbf{rPHL}), a probabilistic Hoare logic (\textbf{pHL}), and a
regular Hoare logic.
The pHL allows us to reason about the probability of a program terminating with
some output/predicate.
The rPHL allows us to reason about the
indistinguishability of two programs.
Furthermore, \easycrypt\ has a Higher-order ambient logic, in which the three
previous logics are encoded.
This Higher-order logic allows us to reason about mathematical constructs. This,
in turn, allows us to reason about mathematical constructs used in programs
since we can lift the program logics into the ambient logic.
Moreover, the ambient logic offers strong tools for automation. Notably, the
ambient logic can call various theorem provers, which will try to finish the
current proof. This allows us to automatically prove complex mathematical
statements without having to recall the specific mathematical rules needed.

\section{Game-based security}
\label{sec:game-based-sec}
In the game-based approach, security is
modelled as a game against an adversary where the adversary's goal is to
break the indented design of the protocol.
This is usually done by a series of game reductions where it is proven that the
probability of the initial game is equivalent to winning another game, which is
easier to reason about.
Ultimately a sequence of game reductions leads to a final game, which is either
mathematically impossible for the adversary to win or equivalent to a
difficult problem, like the discrete logarithm problem.

\section{Easycrypt}
\label{sec:label}

\subsection{Types, Operators and Procedures}
\label{sec:ec_types_and_operators}
In \easycrypt\ we can view types as mathematical sets containing at least one
element. Types can either be \textit{abstract} or \textit{aliases}. An abstract
type is, in essence, a new type. While type aliases work on already defined
types.
Moreover, \easycrypt\ allows us to define inductive types and types with
multiple members.
\begin{lstlisting}
type t. (* Definition of new type *)

type card = [
    | spades of int
    | heart of int
    | clubs of int
    | diamonds of int
] (* Enumerated type *)
\end{lstlisting}

\noindent
Functions are declared with the ``op'' keyword in \easycrypt.
Here functions are not allowed to make indeterministic choices, which also
implies that a function will always terminate.
Furthermore, functions allows us to pattern match on types with
multiple members:
\begin{lstlisting}
op is_red (c : card) =
    with c = spades n => false
    with c = heart n => true
    with c = diamonds n => true
    with c = clubs n => false.
\end{lstlisting}


\subsection{Theories, Abstract theories and Sections}
\label{sec:ec_theories}
To structure proofs and code \easycrypt\ uses a language construction called
theories. By grouping definitions and proofs into a theory, they become available
in other files by ``requiring'' them. For example, to make use of \easycrypt's
existing formalisation of integers, it can be made available in any giving file
by writing:

\begin{lstlisting}[float,label=lst:theory_require,caption=\easycrypt\ theories: importing definitions]
require Int.

const two : int = Int.(+) Int.One Int.One.
\end{lstlisting}

To avoid the theory name prefix of all definitions ``require import'' can be
used in place of ``require'', which will add all definitions and proof of the
theory to the current scope without the prefix. Consequently, the ``export''
keyword can be used in place on import to require the theory under a custom prefix.

Any \easycrypt\ file with the ``.ec'' file type is automatically declared as a
theory.

\paragraph{Abstract Theories}
To model protocols that can work on many different
types we use \easycrypt's abstract theory functionality. An abstract theory allows us to model
protocols and proof over generic types. In other words, in an abstract theory,
all modules, functions and lemmas are quantified over the types declared in the file.
There are currently two ways of declaring an abstract theory. First, by using the
``theory'' keyword which declares all defined types to abstract.
Second, an abstract theory file can be declared by using the ``.eca'' file extension.

An abstract theory can then later be ``cloned'', which allows the user to define
concrete types for the theory before importing it.

\paragraph{Sections}
Sections provide similar functionality to that of abstract theories, but instead of quantifying over
types sections allows us to quantify everything within the subsection over programs
with special properties and axioms provided, which are defined by the user.

An example of this is proving that a protocol is secure given access to a
random oracle.
To model a random oracle we can then start a subsection and declare a oracle who
always samples values uniform random values.
All lemmas declared within the subsection will then have access to the random
oracle.

An important note is that introducing axioms in a subsection cannot break the logic
of \easycrypt, since if we axiomatise $true = false$ in a subsection, then all
lemmas become on the form $true = false \implies \text{lemma}$, which only
makes the proofs impossible to realise.

Sections are particularly useful if many lemmas require the same assumptions. By
using a subsection we can automatically make the assumption available in every
proof without having to explicitly write it in the lemma.

\subsection{Modules and procedures}
\label{sec:ec_modules}
To model programs in \easycrypt\ the module construct is provided.
A module is a set of procedures and a record of global variables, where all
procedures are written in \easycrypt's embedded programming language, \texttt{pWhile}.

The syntax of \texttt{pWhile} is described over a set $\mathcal{V}$ of variable
identifiers, a set $\mathcal{E}$ of deterministic expressions, a set
$\mathcal{P}$ of procedure expressions, and a set $\mathcal{D}$ of distribution
expression.
The set $\mathcal{I}$ of instructions is then defined
by \cite{zkcrypt}:
\begin{align*}
  \mathcal{I} ::&= \mathcal{V} = \mathcal{E} \\
              &|\; \mathcal{V} <\$ \mathcal{D} \\
              &|\; \text{if } \mathcal{E} \text{ then } \mathcal{I} \text{ else } \mathcal{I} \\
              &|\; \text{while } \mathcal{E} \text{ do } \mathcal{I} \\
              &|\; \mathcal{V} = \mathcal{P}(\mathcal{E}, \dots, \mathcal{E}) \\
              &|\; \text{skip} \\
              &|\; \mathcal{I}; \mathcal{I}
\end{align*}

Modules are, by default, allowed to interact with all defined modules.
This is due to the fact that all programs are executed within shared memory. This
models a real execution of the programs in, where the program would have access to
all memory not protected by the operating system.

From this, the set of global variables for any given module is all its
internally defined global variables and all variables the modules procedures
could potentially read or write during execution. This is checked by a simple
static analysis, which looks at all execution branches within all procedures of the module.

A module can be seen as \easycrypt's abstraction of the class construct
in object-oriented programming languages.

\paragraph{Modules Types}
\label{sec:ec_module_types}
Modules types is another feature of \easycrypt\ modelling system, which
enables us to procedures of modules, without having to implement
them. A procedure without implementation is abstract, while
an implemented one, \ie\ The ones provided by modules, is concrete.

An important distinction between abstract and non-abstract modules is that,
while non-abstract modules define a global state for the procedures to work
within, the abstract counter-part does not. This has two important implications;
first, it means that defining abstract modules does not affect the global
variables/state of non-abstract modules.
Moreover, it is also not possible to prove properties about an abstract modules, since
there is no context to prove properties within.

This allows us to quantify over all possible implementations of an abstract
module in our proofs.
The implications of this are that we can then prove that no matter what choice
the adversary makes during execution, he will not be able to break the security
of the procedure.

\subsection{Distributions and dealing with randomness}
\label{sec:easycrypt:distributions}
To introduce randomness/non-determinism to procedures \easycrypt\ allows
random assignments from distributions. \easycrypt\ support this functionality in
two way: sampling from a distribution and calling an adversary.

In \easycrypt\ distribution are themselves procedures with a fixed output
distribution. More formally a distribution in \easycrypt\ is a monad converting a
\textit{discrete} set of events into a sub-probability mass function over said events.

When dealing with distribution, we have three important characteristics:

\noindent \textbf{Lossless :} A procedure (or distribution) is said to be
lossless if it always produces an output. This means that the
probabilistic mass functions sums to one.

\noindent \textbf{Full :} A distribution is said to be full if it is
possible to sample every element of the type the distribution is defined on from
the distribution

\noindent \textbf{Uniform: } A distribution is uniform if every event is equally
likely to be sampled.

As an example, a distribution over a type $t$ can be defined as follows:
\begin{lstlisting}[frame=none]
op dt : challenge distr.
\end{lstlisting}
Furthermore, we specify the distribution to be lossless, full and uniform as:
\begin{gather*}
  \textbf{axiom: } \text{is\_lossless dt}.
  \textbf{axiom: } \text{is\_funiform dt}.
\end{gather*}

We can then express a random assignment form the distribution as $x \text{ <\$} \text{ dt}$


By introducing random assignments to our procedures, we change
the output of the procedure from a value to a distribution over possible output values.

Moreover, with distributions, it is possible to reason about indistinguishability
with the use of \easycrypt's coupling functionality. When sampling a random
value we can provide a coupling stating that the value sampled is
indistinguishable from some value, $x$. If it is possible to prove the two
values are indistinguishable, then we can use the value of $x$ in place of the
random value, for the rest of the procedure.

\todo{Mention common distributions like bool and interval}

\subsection{Probabilistic Hoare Logic}
\label{sec:pHL}
To formally prove a cryptographic protocol secure we commonly have to argue
that a probabilistic procedure will terminate with a certain event,
with some probability.

To this end, we have the probabilistic Hoare logic, which helps us express precisely this.
To express running a procedure $p(x)$, which is part of a module $M$, we have the
following \easycrypt\ notation:
\[
  phoare[M.q :\; \Psi \implies \Phi] = p
\]

Which informally corresponds to: if the procedure with the global variables from $M$
is executed with any memory/state which satisfies the precondition $\Psi$, then the
result of the execution will satisfy $\Phi$ with probability $p$.

Alternatively, this can be stated as:
\begin{equation}
  \label{eq:proc_pr}
  \Psi \implies \forall x, \&m.\Pr{M.q(x) \; @ \; \&m : \Phi} = p
\end{equation}

We note that the first representation implicitly quantifies over all
arguments to the procedure $q$ and memories while the latter requires us
quantify over them explicitly.

To understand how the pHL logic works, we adopt the notions by \citet{ec_intro},
which states that procedures are ``distribution transformers''.
When running the procedure, we know that it has an input distribution satisfying
$\Psi$. Each statement in the procedure will then change the input distribution
in some way. For example, when assigning to a variable, we change the
distribution of potential values for that variable. When running the whole
procedure, we need to argue that the procedure transforms the input distribution
in a way that makes $\Phi$ satisfiable.

\subsection{Probabilistic Relational Hoare Logic}
\label{sec:pRHL}
The pRHL logic allows us to reason about indistinguishability between two
procedures w.r.t a pre- and postcondition. More formally, the pRHL logic
allows us to determine if two procedures are perfectly indistinguishability w.r.t.
to the given pre- and postcondition.

We recall from subsection \ref{sec:pHL} that procedures can be seen as distribution
transformers. By observing procedures as distribution transformers,
indistinguishability between procedures equates to arguing that both procedures
transform their output distributions in a way that makes the postcondition
true.

In \easycrypt\ we have the following notation for comparing two procedures:
\[
  equiv[P \sim Q :\; \Psi \implies \Phi ]
\]

Where $\Psi$ is the precondition and $\Phi$ is the postcondition.

Alternatively, two procedures are indistinguishability if:

\[
  \Pr{P @ m_{1} : A} = \Pr{Q @ m_{2} : B} \land \Psi \implies (A \iff B) \land m_{1} \Psi m_{2}
\]

Informally, this can be understood as: The procedures P and Q running in
respective memories $m_{1}$ and $m_{2}$ are indistinguishability w.r.t. to
precondition $\Psi$ and postcondition $\Phi$, if both memories satisfy $\Psi$.
Moreover, if we can run procedure P and get event A and
procedure Q to get event B, then the procedures are indistinguishable if the
postcondition implies that the two events are isomorphic. Alternatively, this is
stated as:
\[
  \Phi \implies (A \iff B)
\]


When dealing with pRHL statement, there are two types of deduction rules;
one-sided or two-sided.
The one-sided rules allow us to use the pHL deduction rules on one of the
two programs we are comparing. We refer to the two programs by their
side of the $\sim$ operator. In the above example, P is the left side and Q is
the right.
These one-sided rules allow us to step the execution forward for one of the sides without
reasoning about the other side.
By doing this, we change all the term relating to pHL deduction rule, but only
for side on which the rule was use on.

The two-sided rules allow us to step both sides if they are both about to call
a command of the same shape. In this sense, the two-sided rules are much more
restrictive, since we can only use them if the programs are similar in structure.

In particular, the two-sided rules allows us to reason about random assignments
and adversarial calls.
Since random assignment and adversarial call are inherently indeterminable and possibly
non-terminate, our one-sided rules cannot be used to step the programs forward.
By using the two-sided rules, this is not an issue,
since if both procedures perform the same choice, then it does not
matter what the choice was, or if it terminated, just that both procedures
performed the same choice.

This allows us to step both procedures forward, while ensuring that both
procedures made the same random choices, hence transforming their output
distribution is similar ways.

\subsection{Easycrypt notation}
\label{sec:label}

We use notation $\Pr{P = b} = p$ to express that procedure P can be run with
output value $b$ with probability $p$
We use notation $\Pr{P : A} = p$ to express that the output distribution of
procedure P will satisfy $A$ with probability $p$.

When comparing two procedures P and Q in the relational logic, i.e:
\[
  equiv[P \sim Q :\; \Psi \implies \Phi]
\]

Moreover, we adopt the \easycrypt\ notation of \textbf{res} the signify the
output value of a procedure.

We use the notation $x^{P}$ to denote the value variable $x$ w.r.t. procedure P.
Likewise, we let $x^{Q}$ denote the value of $x$ when observing the run of
procedure Q. To express that $x^{P} \sim x^{Q}$ we use the notation $\indis{x}$,
Furthermore, we use the notation \textbf{Glob M} to express all the global
variables that M has access to.

When stating probabilistic Hoare statements on the form of equation
\ref{eq:proc_pr}, we omit the quantification of the arguments when the
quantification can be inferred from the context. Furthermore, we also omit
quantification over initial memory configurations.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
