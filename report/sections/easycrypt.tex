\chapter{EasyCrypt}
\label{ch:EasyCrypt}

It this chapter we introduce the \easycrypt proof assistant \dots

\easycrypt provides us with three important logics: a relational probabilistic
Hoare logic (\textbf{rPHL}), a probabilistic Hoare logic (\textbf{pHL}), and a
Hoare logic.
Furthermore, \easycrypt also has an Higher-order ambient logic, in which the three
previous logics are encoded within. This Higher-order logic allows us to reason
about mathematical constructs, which in turn lets us reason about them within
the different Hoare logics. The ambient logic also allows us to relate
judgement the three different types of Hoare logics, since they all have an
equivalent representation in the ambient logic.

\section{Types and Operators}
\label{sec:ec_types_and_operators}

\section{Theories, Abstract theories and Sections}
\label{sec:ec_theories}
To structure proofs and code \easycrypt uses a language construction called
theories. By grouping definitions and proofs into a theory they become available
in other files by ``requiring'' them. For example, to make use of \easycrypt's
existing formalisation of integers, it can be made available in any giving file
by writing:

\begin{lstlisting}[float,label=lst:theory_require,caption=\easycrypt theories: importing definitions]
require Int.

const two : int = Int.(+) Int.One Int.One.
\end{lstlisting}

To avoid the theory name prefix of all definitions ``require import'' can be
used in-place of ``require'', which will add all definitions and proof of the
theory to the current scope without the prefix.

Any \easycrypt file with the ``.ec'' file type is automatically declared as a
theory.

\paragraph{Abstract Theories}
To model parametric protocols, i.e. protocols that can work on many different
types we use \easycrypt's abstract theory functionality. A abstract theory allows us to model
protocols and proof over generic types.
There is currently two ways of declaring an abstract theory. First, by using the
``theory'' keyword within any file allows the user to define abstract types,
which can be used though-out the scope of the abstract theory, i.e. everything
in-between the ``theory'' and ``end theory'' keywords. Second, an abstract
theory file can be declared by using the ``.eca'' file type. This works much
like using the ``.ec'' file type to declare theories.

\paragraph{Sections}
Sections provide much of the same functionality, but instead of quantifying over
types sections allows us to quantify everything within the section over modules
axiomatised by the user.

An example of this, is having a section for cryptographic security of a
protocols, where we quantify over all instances of adversaries, that are
guaranteed to terminate.


\section{Modules and procedures}
\label{sec:ec_modules}
To model algorithms within \easycrypt the module construct is provided.
A module is a set of procedures and a record of global variables, where all
procedures are written in \easycrypt embedded programming language, \texttt{pWhile}.
\begin{draft}
pWhile is a mild generalization of the language proposed by Bellare and Rogaway [2006]?
\end{draft}

Modules are, by default, allowed to interact with all other defined modules.
This is a due to all procedures are executed within shared memory. This is to
model actual execution of procedures, where the procedure would have access to
all memory not protected by the operating system.

From this, the set of global variables for any given module, is all its
internally defined global variables and all variables the modules procedures
could potentially read or write during execution. This is checked by a simple
static analysis, which looks at all execution branches within all procedures of the module.

A module can been seen as \easycrypt's abstraction of the class construct
in object-oriented programming languages.

\todo{Example of modules}

\paragraph{Modules Types}
\label{sec:ec_module_types}
Modules types is another features of \easycrypt modelling system, which
enables us to define general structures of modules, without having to implement
the procedures. A procedure without an implementation is called abstract, while
a implemented one (The ones provided by modules) are called concrete.

An important distinction between abstract and non-abstract modules is that,
while non-abstract modules define a global state for the procedures to work
within, the abstract counter-part does not. This has two important implications,
first it means that defining abstract modules does not affect the global
variables/state of non-abstract modules.
\begin{draft}
Moreover, it is also not possible to prove properties of abstract modules, since
there is no context to prove properties within.
\end{draft}

It is, however, possible to define higher-order abstract modules with access to the global
variables and procedures of another abstract module.

This allows us to quantitate over all possible implementations of an abstract
module in our proofs. This implications of this, is that it is possible to
define adversaries and then proving that no matter what choice the adversary
makes during execution, he will not be able to break the security of the procedure.

\todo{Example of abstract modules}


\section{Probabilistic Hoare Logic}
\label{sec:pHL}
\todo{programs are distribution transformers}
To formally prove security of a cryptographic protocol we commonly have to argue
that some procedure perform random choices will terminate with a certain event
with some probability, regardless of the random choices made during execution.

To this end pHL logic, which helps us express precisely this.
A pHL statement in \easycrypt\ is commonly seen in the following form:
\[
  phoare[P :\; \Psi \implies \Phi] = p
\]

Which informally corresponds to: If the procedure is executed with any
memory/state which satisfy the precondition $\Psi$ then the result execution P
will satisfy $P$ with probability $p$.

Alternatively this can be stated as:
\[
  \Psi \implies \Pr{P : \Phi} = p
\]

To understand how the pHL logic works we adopt the notions by \citet{ec_intro},
which states that procedures are ``distribution transformers''.
This means...

The deduction rules for pHL...
Reasoning about adversarial code...

\section{Probabilistic Relational Hoare Logic}
\label{sec:pRHL}
The pRHL logic allows us to reason about indistinguishability between two
procedures under a specific pre- and postcondition. More formally the pRHL logic
allows us to determine if two procedures are perfectly indistinguishability wrt.
to the given pre- and postcondition.

We recall from section \ref{sec:pHL} that procedures can be seen as distribution
transformers. By observing procedures as distribution transformers
indistinguishability between procedures equates to arguing that both procedures
transform their output distributions in a way that makes the post condition
true.

In \easycrypt we have the following notation for comparing two procedures:
\[
  equiv[P \sim Q :\; \Psi \implies \Phi ]
\]

Where $\Psi$ is the precondition and $\Phi$ is the post condition.

Formally we say that two procedures are indistinguishability if:

\[
  \Pr{P @ m_{1} : A} = \Pr{Q @ m_{2} : B} \land \Psi \implies (A \iff B) \land m_{1} \Psi m_{2}
\]

More informally this can be understood as: The procedures P and Q running in
respective memories $m_{1}$ and $m_{2}$ are indistinguishability wrt. to
precondition $\Psi$ and postcondition $\Phi$, if the both memories satisfy the
precondition. Moreover, if we can run procedure P and get event A and
procedure Q to get event B then the procedures are indistinguishable if the
postcondition implies that the two events are isomorphic.


When dealing with pRHL statement we have two types deduction rules; they are
either one-sided or two-sided.
The one-sided rules allow us to use the pHL deduction rules on either one of the
two programs we are comparing in isolated. We refer to the two programs by their
side of the $\sim$ operator. In the above example P is the left side and Q is
the right.
These one-sided rules allows us to step one of the side forward without
reasoning about the other size. By doing this we alter all the term relating to
which side we called the rule on.

The two-sided rules allow us to step both sides, if they are both about to call
the a command of the same shape. In this sense the two-sided rules are much more
restrictive, since we can only use them if the programs are similar in structure.

In particular the two-sided rules allows us to reason about random assignments
and adversarial calls.
Since random assignment and adversarial call are inherently indeterminable and can
possible not terminate there it is not possible for our one-sided rules to
step the programs forward. By using the two-sided rules this is not an issues,
since if both procedures performs the indeterminable choice then it does not
matter what the choice where, or if it terminated, just that both procedures
performed the same choice.

This allows us to step both procedures forward under the assumption that both
procedures transformed their output distribution in exactly the same way for the
computation step.

\section{Distribution and dealing with randomness}
\label{sec:easycrypt:distributions}
\todo{lossless, full, uniform}
\todo{Coupling}

\section{Easycrypt notation}
\label{sec:label}

We use notation $\Pr{P = b} = p$ to express that procedure P can be run with
output value $b$ with probability $p$
We use notation $\Pr{P : A} = p$ to express that the output distribution of
procedure P will satisfy $A$ with probability $p$.


While this thesis has been performed entirely in easycrypt the code in this
thesis will be given in a more pseudo-code style to make it more general. For
the most party we will avoid easycrypt specific notation when writing procedures
and solely focus on what tools easycrypt provides us with for proving
procedures.

\todo{When referring to indistinguishability we are referring to the notion given by EC}
Moreover we introduce to follow notation to describe Hoare related statements...

\todo{We omit quantification over input when they can be directly inferred}
\todo{We omit quantification over memory when they can be directly inferred}

\paragraph{Easycrypt is a frontend?}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
