\chapter{EasyCrypt}
\label{ch:EasyCrypt}

It this chapter we introduce the \easycrypt proof assistant \dots

\easycrypt provides us with three important logics: a relational probabilistic
Hoare logic (\textbf{rPHL}), a probabilistic Hoare logic (\textbf{pHL}), and a
Hoare logic.
Furthermore, \easycrypt also has an Higher-order ambient logic, in which the three
previous logics are encoded within. This Higher-order logic allows us to reason
about mathematical constructs, which in turn lets us reason about them within
the different Hoare logics. The ambient logic also allows us to relate
judgement the three different types of Hoare logics, since they all have an
equivalent representation in the ambient logic.

\section{Types and Operators}
\label{sec:ec_types_and_operators}

\section{Theories, Abstract theories and Sections}
\label{sec:ec_theories}
To structure proofs and code \easycrypt uses a language construction called
theories. By grouping definitions and proofs into a theory they become available
in other files by ``requiring'' them. For example, to make use of \easycrypt's
existing formalisation of integers, it can be made available in any giving file
by writing:

\begin{lstlisting}[float,label=lst:theory_require,caption=\easycrypt theories: importing definitions]
require Int.

const two : int = Int.(+) Int.One Int.One.
\end{lstlisting}

To avoid the theory name prefix of all definitions ``require import'' can be
used in-place of ``require'', which will add all definitions and proof of the
theory to the current scope without the prefix.

Any \easycrypt file with the ``.ec'' file type is automatically declared as a
theory.

\paragraph{Abstract Theories}
To model parametric protocols, i.e. protocols that can work on many different
types we use \easycrypt's abstract theory functionality. A abstract theory allows us to model
protocols and proof over generic types.
There is currently two ways of declaring an abstract theory. First, by using the
``theory'' keyword within any file allows the user to define abstract types,
which can be used though-out the scope of the abstract theory, i.e. everything
in-between the ``theory'' and ``end theory'' keywords. Second, an abstract
theory file can be declared by using the ``.eca'' file type. This works much
like using the ``.ec'' file type to declare theories.

\paragraph{Sections}
Sections provide much of the same functionality, but instead of quantifying over
types sections allows us to quantify everything within the section over modules
axiomatised by the user.

An example of this, is having a section for cryptographic security of a
protocols, where we quantify over all instances of adversaries, that are
guaranteed to terminate.


\section{Modules and procedures}
\label{sec:ec_modules}
To model algorithms within \easycrypt the module construct is provided.
A module is a set of procedures and a record of global variables, where all
procedures are written in \easycrypt embedded programming language, \texttt{pWhile}.
\begin{draft}
pWhile is a mild generalization of the language proposed by Bellare and Rogaway [2006]?
\end{draft}

Modules are, by default, allowed to interact with all other defined modules.
This is a due to all procedures are executed within shared memory. This is to
model actual execution of procedures, where the procedure would have access to
all memory not protected by the operating system.

From this, the set of global variables for any given module, is all its
internally defined global variables and all variables the modules procedures
could potentially read or write during execution. This is checked by a simple
static analysis, which looks at all execution branches within all procedures of the module.

A module can been seen as \easycrypt's abstraction of the class construct
in object-oriented programming languages.

\todo{Example of modules}

\paragraph{Modules Types}
\label{sec:ec_module_types}
Modules types is another features of \easycrypt modelling system, which
enables us to define general structures of modules, without having to implement
the procedures. A procedure without an implementation is called abstract, while
a implemented one (The ones provided by modules) are called concrete.

An important distinction between abstract and non-abstract modules is that,
while non-abstract modules define a global state, in the sense of global
variables, for the procedures to work within, the abstract counter-part does
not. This has two important implications, first it means that defining abstract
modules does not affect the global variables/state of non-abstract modules.
\begin{draft}
Moreover, it is also not possible to prove properties of abstract modules, since
there is no context to prove properties within.
\end{draft}

It is, however, possible to define higher-order abstract modules with access to the global
variables and procedures of another abstract module.

This allows us to quantitate over all possible implementations of an abstract
module in our proofs. This implications of this, is that it is possible to
define adversaries and then proving that no matter what choice the adversary
makes during execution, he will not be able to break the security of the procedure.

\todo{Example of abstract modules}


\section{Probabilistic Hoare Logic}
\label{sec:pHL}
To formally prove security of a cryptographic protocol we commonly do we in the
way of so-called game-based proofs, we define a game against a malicious
adversary, and say that the protocol is secure, if the adversary cannot win said
game. An common example of this is IND-CPA security, where an probabilistic
polynomial time adversary is given access to an PKE-oracle and is allowed to
send two messages to the oracle, namely $m_{0}, m_{1}$. The oracle then chooses
a random bit, $b$, and sends the encryption of $m_{b}$ back to the adversary.
Then, if the adversary can guess which of the two messages where encrypted we
wins.
To reason about such within \easycrypt we first describe the game within a
module:

\begin{lstlisting}[float,label=lst:IND_CPA,caption=nextHopInfo: IND-CPA Game]
  module IND-CPA(A : Adversary) = {
    proc main() : bool = {
      var m0, m1, b, b', sk, pk;

      (sk, pk) = key_gen();

      (m0, m1) = A.choose(pk);

      b <\$ dbool;

      b' = A.guess(enc(sk, m_b));

      return b == b'
    }
  }
\end{lstlisting}

\todo{Problems with game: A should know what PKE schemes is used. A bit too
  psuedo-code-ish}

Now, to prove security we would like to show that the adversary cannot win this
game with probability better than randomly guessing values of $b'$, i.e. $\frac{1}{2}$.

This formulated in one of two ways:

\begin{equation}
forall (Adv <: Adversaries) \&m, Pr[IND-CPA(Adv).main() @ \&m : res] = 1\%r/2\%r
\end{equation}

\begin{equation}
forall (Adv <: Adversaries), phoare[IND-CPA(Adv).main : true ==> res] = 1\%r/2\%r
\end{equation}

Both are equivalent representations, but the former is in the ambient logic of
\easycrypt, whilst the latter is in the pHL logic.

To prove this, we step though the game using the logic rules of the pHL logic.
But, how can we guarantee that there does not exists any possible implementation
of the adversary, such that we he is able to succeed? To prove this we either
have to somehow prove, that such an adversary cannot exists within the current
game, or we can relate this game to another one, where adversary can only
perform random guesses. To do this we need to utilise the pRHL logic.

\section{Probabilistic Relational Hoare Logic}
\label{sec:pRHL}
the pRHL logic allows us to reason about the join outcome distribution of two
programs. This allows us to reason about equality of games.

To bing it back to the game of IND-CPA, we could define an alternative game,
where the Oracle always sends back a random element from the ciphertext space.
This is often referred to as the ideal case, where as the oracle previously
introduced is referred to as the real one.

We can then formulate equality between the two games as:

\begin{equation}
forall (Adv <: Adversary) \&m, Pr[IND-CPA(Adv).main() @ \&m : res] =
Pr[IND-CPA(Adv).real() @ \&m :res]
\end{equation}
\begin{equation}
forall (Adv <: Adversary) , equiv[IND-CPA(Adv).main ~ IND-CPA(Adv).real : true
==> =\{res\}]
\end{equation}

where $=\{res\}$ is notation for the outcome distributions begin equal.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
