\chapter{Formalising commitment schemes}
\label{ch:formal_commitment}
This section aims to give a generalised formalisation of commitment schemes and
their security in a way that makes it possible and easy to reason about the
security properties of arbitrary instantiations of commitment schemes. Moreover,
the formalisation provides a standard interface for other protocols to interact
with commitment schemes.
In this section we will introduce two flavours of commitment schemes. The first
version formalises key-based commitment schemes, where it is necessary for the
two parties to share a key. The other is a more idealised variant of commitment
schemes, which does not require the parties to share any keys between them, and
only assumes they share the function specification of the commitment schemes.
The latter variant is usually instantiated by one-way/hash functions.

\section{Key-based commitment schemes}
\label{sec:commitment:key-based}
For Key-based commitment schemes we fix to following types:
\begin{align*}
  \textbf{type: } &\text{public\_key} \\
  &\text{secret\_key} \\
  &\text{commitment} \\
  &\text{message} \\
  &\text{randomness} \\
\end{align*}

Here we specifically fix a type ``randomness'' which is responsible for making two
commitments to the same message look different. Technically this randomness
could just be part of the ``commitment'' type, which is the type defining what
values commitments takes. The choice of separating the two types, however, makes
the formalisations of security easier to work with, which we will see later in
this section.

With the types fixed we then define a key-based commitment scheme as the
following functions and procedures:

\begin{lstlisting}[float,label=lst:commitment-procedures,caption= Key-Based commitment specification]
op validate_key (sk : secret_key, pk : public_key) : bool.
op verify (pk : public_key) (m : message) (c : commitment) (d : randomness) : bool.

module type Committer = {
  proc * key_gen() : secret_key * public_key
  proc commit(sk : secret_key, m : message) : commitment * randomness
}.
\end{lstlisting}
Here verification of commitments and key pairs are modelled as function, since
we assume these function to always be deterministic and lossless.
When verifying a commitment, for example, there should be no need to sample
additional randomness. A simple deterministic function on the commitment and its
opening should suffice. Moreover, if the
verification algorithms cannot terminate within a reasonable amount of time,
then it is probably not wroth studying the commitment scheme further.

The committer is modelled as a module with two procedures. One for generating
key pairs and one for committing to messages. This models the fact that the Committer
is able to hold state and make random choice, while the commitments he makes
should be easily verifiable by anyone knowing the public key, without having to
keep any additional state about the committer.

By separating the verification functions from the committers procedures we get a
formalisation closer to the real world, where the verifiers functions should not
be able to read/alter any of the state of the committer. This could alternatively have
been modelled with the verifier being a separate module.
However, if \texttt{verify} is expressed as a procedure in a verifier module,
then we allow \texttt{verify} to read/alter state. By introducing state we
unnecessarily complicate reasoning about verification of multiple messages.
Consider the case, where the verifier is given two commitment and two openings;
if \texttt{verify} is allowed to alter state, then the order of which we verify
the commitments matter. It is, therefore, not possible to change to order of
verifying commitments, unless it is explicitly proven that \texttt{verify} does
not alter state.
Implementing \texttt{verify} as a function alleviates the problem of reasoning
about state.
This is in contrast to previous work \cite{DBLP:journals/corr/MetereD17}, which
has to implemented the functionality of the verifier as procedures in the same
module as the committers functionality.

We define a commitment scheme C to be an implementation of the functions and
procedures in listing \ref{lst:commitment-procedures}.

\section{Key-less commitment schemes}
\label{sec:commitment:key-less}
We furthermore formalise a variant of commitment schemes that we key-less. This
is formalised separately from the key-based commitment schemes, since the
change in function/procedure signatures makes it incompatible with the key-based
formalisation. They could potentially be merged into one formalisation, which
allows for both to be used whenever a commitment scheme is required. The main
reason for not doing this is that proofs of protocols depending on commitment
schemes can become easier when it is not necessary to reason about the sampling
and distribution of the keys. Ideally it should be
proven that the two formalisation are compatible wrt. security, and one can be
used in place of the other, but this is beyond the scope of this thesis.

The functions and procedures used by the key-less commitment schemes are
identical to the ones listed in Figure \ref{lst:commitment-procedures} for the
key-based commitment schemes with the only difference being all references to
the public and secret keys has been removed. Furthermore, the Committer module
now only contains one procedure \texttt{commit}, since there is no longer a need
to generate key pairs.

Moreover, the security definitions remain the same but, again, with the key
generation removed along with the references to the secret and public keys.

\section{Security}
\label{sec:commitment:sec}
For both the key-based and key-less variant of the give the same definitions of security, which is based on the work of \citet{DBLP:journals/corr/MetereD17}.

\begin{definition}[Correctness]
  \label{def:commitment:correctness}
  A commitment scheme C is correct if:
  \[
    \forall m. \Pr{ Correctness(C).main(m) = true } = 1.
  \]

  where Correctness(C) is defined as:

\begin{lstlisting}
module Correctness(C : Committer) = {
  main(m : message) = {
    (sk, pk) = C.key_gen(); (* Omitted in the key-less case *)
    (c, d) = C.commit(sk, m);
    valid = verify pk m c d;
    return valid;
  }
}.
\end{lstlisting}


\end{definition}

\begin{definition}[Hiding]
  A Commitment scheme C can have to following degrees of hiding
  \label{def:commitment:hiding}
  \textit{perfect hiding:} $\forall Adv. \Pr{HidingGame(C,Adv).main() = true} = \frac{1}{2}$
  \textit{computation hiding:} $\forall Adv. \Pr{HidingGame(C,Adv).main() = true} = \frac{1}{2} + \epsilon$

  Where we define the adversary Adv and HidingGame as follows:
\begin{lstlisting}
module type HidingAdv = {
  proc * get() : message * message
  proc check(c : commitment) : bool
}.

module HidingGame(C : Committer, A : HidingAdv) = {
  proc main() = {
    (sk, pk) = C.key_gen();
    (m, m') = A.get();
    b <$ {0,1};
    if (b) {
      (c, r) = C.commit(sk, m);
    } else {
      (c, r) = C.commit(sk, m');
    }
    b' = A.check(c);
    return b = b';
  }
}.
\end{lstlisting}
\end{definition}

\begin{definition}[Binding]
  \label{def:commitment:binding}
  A commitment scheme C can have to following degrees of binding:
  \textit{perfect binding:} $\forall Adv. \Pr{BindingGame(C, Adv).main() = true} = 0$
  \textit{computational binding:} $\forall Adv. \Pr{BindingGame(C, Adv).main() = true} = \epsilon$

  Where we define the adversary Adv and BindingGame as:
\begin{lstlisting}
module type BindingAdv = {
  proc bind(sk : secret_key, pk : public_key) : commitment * message * message * randomness * randomness
}.

module BindingGame(C : Committer, B : BindingAdv) = {
  proc main() = {
    (sk, pk) = C.key_gen();
    (c, m, m', r, r') = B.bind(sk, pk);
    v =  verify pk m c r;
    v' = verify pk m' c r';
    return (v /\ v') /\ (m <> m');
  }
}.

\end{lstlisting}
\end{definition}

In our definitions of hiding and binding we do not have a formalisation of the
statistical variant, since it is still unclear how to express those in EC \cite{ec_intro}.


\section{Alternative definitions of security}
\label{sec:commitment:alt-sec}
Based on the previously defined notions of security we also introduce a number
of alternative definitions, some of which can be directly derivable from our
original definitions. The other definitions does not offer an easy reduction but
intuitively capture the same aspects of security.

\begin{lemma}[Alternative correctness]
  A commitment scheme C is correct if:

  \begin{align*}
    \forall m,sk,pk.& \\
    &\text{validate\_key } sk \; pk \land \Pr{\texttt{key\_{fixed}}(m, sk, pk) = true} = 1 \\
    & \implies \Pr{\texttt{Completeness(C).main(m)}} = 1.
  \end{align*}

  Where \texttt{key\_fixed} is given by the following procedure:

\begin{lstlisting}
proc key_fixed(m : message, sk : secret_key, pk : public_key)  = {
  (c, d)   = C.commit(sk, m);
  b        = verify pk m c d;
  return b;
}
\end{lstlisting}
\end{lemma}
\begin{proof}
  We start by introducing an intermediate game:
\begin{lstlisting}
proc intermediate(m : message) = {
  (sk, pk) = C.key_gen();
  b = key_fixed(m, sk, pk);
  return b;
}
\end{lstlisting}
  We then prove that \texttt{intermediate} is equivalent to
  \texttt{Completeness(C).main} by inlining all procedures and observing that
  both procedures are equal in structure.

  We are then left with showing:
  \begin{align*}
    \forall m,sk,pk.& \\
    &\text{validate\_key } sk \; pk \land \Pr{\texttt{key\_{fixed}}(m, sk, pk) = true} = 1 \\
    & \implies \Pr{\texttt{intermediate}(m)} = 1.
  \end{align*}

  We then use the assumption that \texttt{key\_fixed} is correct to prove that
  it returns true when called as a sub-procedure in \texttt{intermediate}. Last
  we have to prove that $(sk, pk)$ are a valid key pair, but since they are
  generated by \texttt{C.key\_gen} they must be valid.
\end{proof}

\begin{definition}[Perfect Hiding]
  \label{def:commitment:perfect-hiding}
  A commitment scheme C offers perfect hiding, if the output distribution of two
  committers with the same state but different messages are perfectly
  indistinguishable.

  \[
    equiv[commit \sim commit :\; \indis{sk, m, \textbf{glob } Committer} \implies \indis{res, \textbf{glob } Committer} ]
  \]

\end{definition}

\begin{definition}[Alternative Binding]
  \label{def:commitment:alt-binding}
  A commitment scheme C offers binding with probability $p$ if:
  $\Pr{alt\_{binding}(c, m, m') = true} = p$

  for procedure \texttt{binding} given by:
\begin{lstlisting}[mathescape]
proc alt_binding(c : commitment, m m' : message) = {
  v1 = verify m c;
  v2 = verify m' c;
  return v1 /\ v2 /\ (m $\neq$ m');
}
\end{lstlisting}

  The commitment schemes offers \textit{perfect binding} if $p = 0$
\end{definition}

The alternative definition of hiding only works in the perfect case, but it is much easier
to work with within \easycrypt\  since pRHL statement be used to prove
equivalence of calls to sub-procedures in other proofs.

The alternative definition of binding allows us to use the ambient logic to
reason about the probability of breaking the binding property instead of the
Hoare logics by the way of an adversary. The benefit of reasoning about
statement in the ambient logic is that they are usually easier to reason about
while offering better modularity since we can use ambient logic to
reason about probabilities of different procedures.
Additionally, computational binding can be shown by proving equality between two
procedures rather than constructing an adversary.


\section{Concrete instantiation: Pedersen Commitment}
\label{sec:pedersen}

To show the workability of the proposed formalisation we show that it can be
used replicate the results of \citet{DBLP:journals/corr/MetereD17}. Pedersens
commitment scheme is based on the discrete logarithm assumption

The Pedersen commitment scheme is a protocol run between a committer C and a
receiver R. Both parties have before running the protocol agreed on a group
$(\mathcal{G}, q, g)$, where $q$ is the order of $\mathbb{G}$ and $g$ is the
generator for the group.

When the committer want to commit the a message $m$ he does the following:
\begin{itemize}
  \item He lets R sample a key $h \in_{\text{R}} \mathbb{G}$ and send it to him
  \item Sample a random opening $d \in_{\text{R}} \mathbb{Z}_{q}$ and sends the
    key and commitment $c = g^{d}h^{m}$ to R.
\end{itemize}

At a later time, when C is ready to show the value he committed to, he sends the
message and randomness, $(m',d')$ to R, when then runs the following
verification steps:
\begin{itemize}
  \item R computes $c' = g^{d'}h^{m'}$ and checks that $c = c'$.
\end{itemize}

From this description it is clear that the verification step is simply a
function taking as input the key, commitment, message and opening and then performs a
deterministic computations. This fits perfectly within our formalisation of the
Receiver, we therefore instantiate our commitment scheme framework with the
following:

\begin{lstlisting}[mathescape,label=lst:commitment:pedersen,caption=Pedersen instantiation]
clone export Commitment as Com with
  type public_key <- group (* group element *)
  type secret_key <- group
  type commitment <- group
  type message    <- F.t  (* Finite field element, like $\mathbb{Z}_{q}$ *)
  type randomness <- F.t

  op dm = FDistr.dt, (* Distribution of messages *)
  op dr = FDistr.dt, (* Distribution of randomness *)
  op verify pk (m : message) c (r : randomness) = g^r * pk^m = c,
  op valid_key (sk : secret_key) (pk : public_key) = (sk = pk).

module Pedersen : Committer = {
  proc key_gen() : secret_key * public_key = {
    a <$\$$ dr;
    $h = g ^ a$;

    return (h, h);
  }

  proc commit(sk : secret_key, m : message) = {
    r <$\$$ dr;
    $c = g^r \cdot (sk^m)$;

    return (c, r);
  }
}.

\end{lstlisting}

Here our formalisation assumes that the Committer samples the keys but as we
will see in the following section we are still able to prove security of the
scheme regardless of who generates the keys.
Here we use the Cyclic Group theory from EC to generate the agreed upon group
and model uniform distributions of messages and randomness by...

\paragraph{Security}
To prove security of the protocol we show that the previous definitions of
correctness, hiding and binding can be proven true.

\begin{lemma}[Pedersen correctness]
  $\forall m.\Pr{\texttt{Correctness(Pedersen).main}(m) = true} = 1$
\end{lemma}
\begin{proof}
  correctness follows directly by running the procedure and observing the output.
\end{proof}

\begin{lemma}[Pedersen hiding]
  We show that Pedersen has perfect hiding by definition
  \ref{def:commitment:hiding}.
\end{lemma}
\begin{proof}
  To prove hiding we start by introducing an intermediate hiding game where we
  commit to a random message instead of one of the messages chosen by the adversary:
\begin{lstlisting}[mathescape]
module HidingIdeal(A : HidingAdv) = {
  proc main() = {
    (sk, pk) = Pedersen.key_gen();
    (m, m') = A.get();
    b <$ DBool.dbool;
    r <$\$$ dr;
    c = $g^r$;
    b' = A.check(c);
    return b = b';
  }
}.
\end{lstlisting}
  We then split the proof into two parts:

  \noindent\textbf{1) }
  $\forall Adv. \Pr{\texttt{HidingGame(Pedersen, Adv)}.main = true} = \Pr{\texttt{HidingIdeal(Adv)}.main = true}$
  Where we prove that for any choice of $b$ the two procedures and
  indistinguishable. We start by prove indistinguishability with $b = 0$.
  To prove this we have to prove that $g^{r} \sim g^{r'} \cdot \text{sk}^{m}$
  Here we can use \easycrypt's coupling functionality to prove that
  $r \sim r' \cdot \text{sk}^{m}$ since both $r, r'$ and sk$^{m}$ are all group
  elements and the distribution of $r$ is full and uniform.

  The proof of $b = 1$ is equivalent.

  \noindent \textbf{2)}
  $\forall Adv. \Pr{\texttt{HidingIdeal(Adv)}.main = true} = \frac{1}{2}$

  Since $c = g^{r}$ is completely random the adversary has no better strategy
  than to guess at random.


  By the facts \textbf{1)} and \textbf{2)} we can conclude that Pedersen
  commitment scheme has perfect hiding.
\end{proof}

\begin{lemma}[Pedersen Binding]
  We show computation binding under definition \ref{def:commitment:binding}
\end{lemma}
\begin{proof}
  We prove computation binding of Pedersen commitment by showing that an
  adversary breaking binding can be used to construct a adversary solving the discrete logarithm.

\begin{lstlisting}
module DLogPedersen(B : BindingAdv) : Adversary = {
  proc guess(h : group) = {
    (c, m, m', r, r') = B.bind(h, h);
    v = verify h m c r;
    v' = verify h m' c r';
    if ((v /\ v') /\ (m <> m')) {
      w = Some( (r - r') * inv(m' - m) );
    } else {
      w = None;
    }
    return w;
  }
}.
\end{lstlisting}

  We then prove:
  \begin{align*}
    \forall Adv.& \\
    &\Pr{\texttt{BindingGame(Pedersen, Adv)}.main() = true} \\
    = &\Pr{\texttt{DLogGame(Pedersen, Adv)}.main() = true}.
  \end{align*}

  Fist we show that if \texttt{DLogPedersen} if given one commitment with two
  openings then the discrete logarithm can be solved. This is given by:
  \begin{align}
    &m \neq m' \label{eq:pedersen:dif}\\
    &\implies c = g^{r} \cdot g^{a^{m}} \land c = g^{r'} \cdot g^{a^{m'}} \label{eq:pedersen:com}\\
    &\implies a = (r - r') \cdot (m' - m)^{-1}
  \end{align}
  Which is easily proven by \easycrypt's automation tools.

  Next we show that the two procedures are equivalent. Which follows by inlining
  all procedures and observing the output.
  Procedure \texttt{DLogPedersen.main} can only output true if equations
  \ref{eq:pedersen:dif} and \ref{eq:pedersen:com} holds, which is what procedure
  \texttt{BindingGame(Pedersen, Adv).main} needs to satisfy to output true. We
  can therefore conclude that two procedures imply each other.
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
