\chapter{Formalising commitment schemes}
\label{ch:formal_commitment}
This section aims to give a generalised formalisation of commitment schemes and
their security in a way that makes it possible and easy to reason about the
security properties of arbitrary instantiations of commitment schemes. Moreover,
the formalisation provides a standard interface for other protocols to interact
with commitment schemes.
In this section we will introduce two flavours of commitment schemes. The first
version formalises key-based commitment schemes, where it is necessary for the
two parties to share a key. The other is a more idealised variant of commitment
schemes, which does not require the parties to share any keys between them, and
only assumes they share the function specification of the commitment schemes.
The latter variant is usually instantiated by one-way/hash functions.

\section{Key-based commitment schemes}
\label{sec:commitment:key-based}
For Key-based commitment schemes we fix to following types:
\begin{align*}
  \textbf{type: } &\text{public\_key} \\
  &\text{secret\_key} \\
  &\text{commitment} \\
  &\text{message} \\
  &\text{randomness} \\
\end{align*}

Here we specifically fix a type ``randomness'' which is responsible for making two
commitments to the same message look different. Technically this randomness
could just be part of the ``commitment'' type, which is the type defining what
values commitments takes. The choice of separating the two types, however, makes
the formalisations of security easier to work with, which we will see later in
this section.

With the types fixed we then define a key-based commitment scheme as the
following functions and procedures:

\begin{lstlisting}[float,label=lst:commitment-procedures,caption= Key-Based commitment specification]
op validate_key (sk : secret_key, pk : public_key) : bool.
op verify (pk : public_key) (m : message) (c : commitment) (d : randomness) : bool.

module type Committer = {
  proc * key_gen() : secret_key * public_key
  proc commit(sk : secret_key, m : message) : commitment * randomness
}.
\end{lstlisting}
Here verification of commitments and key pairs are modelled as function, since
we assume these function to always be deterministic and lossless. There should
be need to sample additional randomness to verify these. Mo rover, if the
verification algorithms cannot terminate within a reasonable amount of time,
then it is probably not wroth studying the commitment scheme further.

The committer is modelled as a module with two procedures. One for generating
key pairs and one for committing to messages. This models the fact that a commit
is able to hold state and make random choice, while the commitments he makes
should be easily verifiable by anyone knowing the public key, without having to
keep state about the committer.

By separating the verification functions from the committers procedures we get a
formalisation closer to the real world, where verification functions should not
be able to read any of the state of the committer. This could alternatively have
been modelled with the verifier being a module, but allowing the verify to keep
state complicates proofs, since verifier two messages could potentially have an
effect on each other \todo{rewrite this}.
This is in contrast to previous work \cite{DBLP:journals/corr/MetereD17}, which
has proven problematic to work with, when applying the formalisation of
commitment schemes in larger protocols (Section \ref{sec:formal_zkboo}).
\todo{Rewrite in sec \ref{sec:formal_zkboo} that it is needed to swap the order
  of verifying commitments}

We then attain the following definitions of security:

\begin{definition}[Correctness]
  \label{def:commitment:correctness}
  A commitment scheme C is correct if the following procedures always succeeds.
\end{definition}

\begin{definition}[Hiding]
  \label{def:commitment:hiding}
  A commitment scheme C is ...
  \todo{Explain how the adversary can express multiple levels of hiding.}
\end{definition}

\begin{definition}[Binding]
  \label{def:commitment:binding}
  A commitment scheme C is ...
  \todo{Explain how the adversary can express multiple levels of binding.}
\end{definition}

\todo{Mention randomness distributions?}

\section{Key-less commitment schemes}
\label{sec:commitment:key-less}
\todo{Is this section necessary?}
We furthermore formalise a variant of commitment schemes that we key-less. This
is formalised independently from the key-based commitment schemes, since the
change is function signatures makes it incompatible with the key-based
formalisation, they would potentially be merged into one formalisation, which
allows for both to be used whenever a commitment scheme is required. The main
reason for not doing this is that proofs of protocols depending on commitment
schemes can become easier when it is not necessary to quantify over keys (See
section \ref{sec:formal_zkboo} for an example of this). Ideally it should be
proven that the two formalisation are compatible wrt. security, and one can be
used in place of the other, but this has been beyond the scope of this thesis.

The functions and procedures used by the key-less commitment schemes are
identical to the ones listed in Figure \ref{lst:commitment-procedures} for the
key-based commitment schemes with the only difference being all references to
the public and secret keys has been removed. Furthermore, the Committer module
now only contains one procedure \texttt{commit}, since there is no longer a need
to generate key pairs.

Moreover, the security definitions remain the same but, again, with the key
generation removed along with the references to the secret and public keys.

\section{Alternative definitions of security}
\label{sec:commitment:alt-sec}
Based on the previously defining notions of security we also introduce a number
of alternative definitions, some which can be directly derivable from our
original definitions, whilst the others does not offer an easy reduction but
intuitively capture the same aspects of security.

\begin{lemma}[Alternative correctness]
  A commitment scheme C is correct if given as input a valid key pairs
  $(sk, pk)$ then the verifier with public key $pk$ will always accept
  commitments made by the committer using secret key $sk$.
\end{lemma}
\begin{proof}

\end{proof}

\begin{definition}[Perfect Hiding]
  \label{def:commitment:perfect-hiding}
  A commitment scheme C offers perfect hiding, if the output distribution of two
  committers with the same state but different messages are perfectly
  indistinguishable.

  \[
    equiv[commit \sim commit :\; \indis{sk, m, \textbf{glob } Committer} \implies \indis{res, \textbf{glob } Committer} ]
  \]

\end{definition}

\begin{definition}[Alternative Binding]
  \label{def:commitment:alt-binding}
  A commitment scheme C offers binding...
\end{definition}

The definition of hiding only works in the perfect case, but it is much easier
to work with within \easycrypt\  when this is the case. This is due to most
proofs being stated is indistinguishability proofs, which are bothersome to
convert to adversarial proofs.

The definition of binding allows us to ...


\section{Concrete instantiation: Pedersen Commitment}
\label{sec:pedersen}

To show the workability of the proposed formalisation we show that it can be
used to instantiate the key-based Pedersen commitment scheme. Pedersens
commitment scheme is based on the discrete logarithm assumption


The Pedersen commitment scheme is a protocol run between a committer C and a
receiver R. Both parties have before running the protocol agreed on a group
$(\mathcal{G}, q, g)$, where $q$ is the order of $\mathbb{G}$ and $g$ is the
generator for the group.

When the committer want to commit the a message $m$ he does the following:
\begin{itemize}
  \item He lets R sample a key $h \in_{\text{R}} \mathbb{G}$ and send it to him
  \item Sample a random opening $d \in_{\text{R}} \mathbb{Z}_{q}$ and sends the
    key and commitment $c = g^{d}h^{m}$ to R.
\end{itemize}

At a later time, when C is ready to show the value he committed to, he sends the
message and random opening, $(m',d')$ to R, when then runs the following
verification steps:
\begin{itemize}
  \item R computes $c' = g^{d'}h^{m'}$ and checks that $c = c'$.
\end{itemize}

From this description it is clear that the verification step is simply a
function taking as input the key, commitment, message and opening and does a
deterministic computations. This fits perfectly within our formalisation of the
Receiver, we therefore instantiate our commitment scheme framework with the
following:

\begin{lstlisting}[mathescape,label=lst:commitment:pedersen,caption=Pedersen instantiation]
clone export Commitment as Com with
  type public_key <- group (* group element *)
  type secret_key <- group
  type commitment <- group
  type message    <- F.t  (* Finite field element, like $\mathbb{Z}_{q}$ *)
  type randomness <- F.t

  op dm = FDistr.dt, (* Distribution of messages *)
  op dr = FDistr.dt, (* Distribution of randomness *)
  op verify pk (m : message) c (r : randomness) = g^r * pk^m = c,
  op valid_key (sk : secret_key) (pk : public_key) = (sk = pk).

module Pedersen : Committer = {
  proc key_gen() : secret_key * public_key = {
    a <$\$$ dr;
    $h = g ^ a$;

    return (h, h);
  }

  proc commit(sk : secret_key, m : message) = {
    r <$\$$ dr;
    $c = g^r * (sk^m)$;

    return (c, r);
  }
}.

\end{lstlisting}

Here our formalisation assumes that the Committer samples the keys but as we
will see in the following section we are still able to prove security of the
scheme regardless of who generates the keys.
Here we use the Cyclic Group theory from EC to generate the agreed upon group
and model uniform distributions of messages and randomness by...

Proofs are handled by the ambient logics implementation of group operations.

To prove security of the protocol we should that the previous definitions of
correctness, hiding and binding can be proven true.

\begin{lemma}[Pedersen correctness]
  We must prove that the game outputs true.
\end{lemma}
\begin{proof}
trivial.
\end{proof}

\begin{lemma}[Pedersen hiding]
  We show that Pedersen has perfect hiding by definition
  \ref{def:commitment:hiding}.
\end{lemma}
\begin{proof}
  Program is indistinguishable from game committing to random choice of message.
  No adversary can guess a random bit better than $\frac{1}{2}$.
\end{proof}

\begin{lemma}[Pedersen Binding]
  We show computation binding under definition \ref{def:commitment:binding} by
  showing that an adversary winning the binding game can be used to break the
  discrete logarithm.
\end{lemma}
\begin{proof}
  Define DLog game.
\end{proof}

In this section we have seen ...

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
