\chapter{Formalising $\Sigma$-Protocols}
\label{ch:formal_sigma}
This section will aim to formalise $\Sigma$-protocols according to the
definitions set out in section \ref{sec:background:sigma_protocols}, with a
sufficiently general set-up to allows easy instantiation of arbitrary concrete
protocols.

Moreover, we show that any protocol that adheres to this abstract specification
of a $\Sigma$-Protocol can be compounded together whilst still being secure.

We then end this section by formalising the Fiat-Shamir heuristic, which allows
us to make any $\Sigma$-Protocol non-interactive in the random oracle model.
This also implies that $\Sigma$-Protocol are Zero-knowledge in the random oracle
model, since Special honest verifier zero-knowledge ensure zero-knowledge in the
presence of an honest verifier. If we remove the verifier then he can always be
assumed honest.

\todo{Cite other works about $\Sigma$-Protocols}

\section{Defining $\Sigma$-Protocols}
\label{sec:sigma:def}
We start by defining the types for any arbitrary $\Sigma$-Protocol:
\begin{align*}
  \textbf{type: } &\text{statement} \\
                  &\text{witness} \\
                  &\text{message} \\
                  &\text{challenge} \\
                  &\text{response} \\
\end{align*}
These types corresponds to the types from Figure \ref{fig:proto_sigma}.

Furthermore, we define the relation for which the protocol operates on as a binary function mapping a statement and a witness to true/false :
$R : (\text{statement} \times \text{witness}) \rightarrow \{0,1\}$ along with
a distribution over challenges. This distribution is used to model a honest
verifier which will always generate a random challenge. Since distribution are
probabilistic programs within \easycrypt\ we require that sampling from the
distribution is always successful. This is referred to as the distribution being lossless.

We then define the $\Sigma$-protocol itself to be a series of probabilistic procedures:
\begin{lstlisting}[label=lst:sigma_procedures,caption= Abstract procedures of $\Sigma$-Protocols]
module type SProtocol = {
  proc init(h : statement, w : witness) : message
  proc response(h : statement, w : witness,
                m : message, e : challenge) : response
  proc verify(h : statement, m : message, e : challenge, z : response) : bool
  proc witness_extractor(h : statement, m : message, e : challenge list, z : response list) : witness option
  proc simulator(h : statement, e : challenge) : message * response
}
\end{lstlisting}

Here all procedures are modelled into the same module. This allows the
Verifier procedure to access the global state of the Prover. This could lead to
invalid proofs of security. It is therefore important to not implement a
\texttt{verify} procedure which access global state of the SProtocol module.
This could have been alleviated by splitting the SProtocol module into multiple
different modules with only the appropriate procedures inside. This would remove
any potential for human error when defining a $\Sigma$-Protocol, but it makes it
more bothersome to instantiate a $\Sigma$-Protocol in \easycrypt\ . Ultimately,
we decided on having everything defined within the same module.

\todo{Here gen is \dots}

\begin{lstlisting}[float, label=lst:sigma_completeness,caption=Completeness game for $\Sigma$-Protocols]
module Completeness(S : SigmaProtocol) = {
  proc main(h : input, w : witness) : bool = {
      var a, e, z;
      a = S.init(h,w);
      e <$ dchallenge;
      z = S.response(h, a, e);
      v = S.verify(h, a, e, z);
      return v;
  }
}.
\end{lstlisting}

An instantiation of a $\Sigma$-Protocol is then an implementation of the
procedures in Listing \ref{lst:sigma_completeness}.

We then model security as a series of games:

\begin{definition}[Completeness]
\label{def:sigma:completeness}
  We say that a $\Sigma$-protocol, S, is complete, if the probabilistic procedure in
  \ref{lst:sigma_completeness} outputs 1 with probability 1, i.e.
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall h \; w, \text{R } h \; w \implies Pr[\text{Completeness(S).main}(h,w) = true] = 1.
  \end{equation}
\end{definition}

One problem with definition $\ref{def:sigma:completeness}$ is that
quantification over challenges is implicitly done when sampling from the random
distribution of challenges. This mean that reasoning about the challenges are
done within the probabilistic Hoare logic, and not the ambient logic. If we at
some later point need the completeness property to hold for a specific
challenge, then that is not true by this definition of completeness, since
the ambient logic does not quantify over the challenges. To alleviate this
problem we introduce a alternative definition of completeness:

\begin{definition}[Alternative Completeness]
\label{def:sigma:alt_completeness}
  We say that a $\Sigma$-protocol, S, is complete if:
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall h \; w \; e, \text{R } h \; w \implies Pr[\text{Completeness(S).special}(h,w,e) = true] = 1.
  \end{equation}
  Where the procedure ``Completeness(S).special'' is defined as
  \lstinputlisting[linerange={40-48}]{../code/SigmaProtocols.eca}
\end{definition}

Now, since the alternative procedure no longer samples from a random
distribution it is not possible to prove equivalence between the two procedure,
but to show that this alternative definition is still captures what is means for
a protocol to be complete we have the following lemma:

\begin{lemma}
Given that definition \ref{def:sigma:alt_completeness} then it must hold that
definition \ref{def:sigma:completeness} holds, given the same public input and witness.

\begin{align*}
  &\Pr{\texttt{special} : true \implies res} = 1 \implies
    &\Pr{\texttt{Completeness(S).main} : true \implies res} = 1.
\end{align*}
\end{lemma}

\begin{proof}
First we start by defining an intermediate game:
\begin{lstlisting}
proc intermediate(h : input, w : witness) : bool = {
   e <$ dchallenge;
   v = special(h, w, e);
   return v;
}
\end{lstlisting}

From this it is easy to prove equivalence between the two procedures
``intermediate'' and ``main'' by simply inlinining the procudures and moving
the sampling to the first line of each program. This will make the two programs
equivalent.

Now, we can prove the lemma by instead proving:
\begin{align*}
  &\Pr{\texttt{special} : true \implies res} = 1 \implies
    &\Pr{\texttt{intermediate} : true \implies res} = 1.
\end{align*}

The proof then proceeds by first sampling $e$ and then proving the following
probabilistic Hoare triplet: $true \vdash \{\exists e', e = e'\}
\text{special(h,w,e)} \{true\}$. Now, we can move the existential
from the pre-condition into the context:
\[
  e' \vdash \{e = e'\} \text{special(h,w,e)} \{true\}
\]

Which then is proven by the hypothesis of the ``special'' procedure being complete.
\end{proof}


\begin{definition}[Special Soundness]
\label{def:sigma:soundness}
  A $\Sigma$-Protocol S has special soundness if:
\begin{align*}
  \forall h,w,a&,e,e',z,z'. \\
    & e \neq e' \\
    & \text{R } h \; w \implies \\
    \land &\Pr{S.verify((h_{1}, h_{2}), (w_{1}, w_{2}), a,  e, z)} = 1 \\
    \land &\Pr{S.verify((h_{1}, h_{2}), (w_{1}, w_{2}), a, e', z')} = 1 \\
    &\implies \Pr{SpecialSoundness(\texttt{ANDProtocol}(P_{1}, P_{2})).main(h, a, [e;e'], [z;z'])} = 1
\end{align*}

With \texttt{SpecialSoundness} defined as:

\begin{lstlisting}[float, label=lst:sigma-soundness, caption= 2-special soundness game]
module SpecialSoundness(S : SProtocol) = {
  proc main(h : statement, a : message, e c' : challenge, z z' : response) : bool = {
    var w, v, v';

    v  = S.verify(h, a, c, z);
    v' = S.verify(h, m, c', z');

    w = S.witness_extractor(h, m, e, e', z, z');

    return (e <> e' /\ (R h w) /\ v /\ v');
  }
}.
\end{lstlisting}
\end{definition}

\begin{definition}[Special Honest Verifier Zero-Knowledge]
  To define SHVZK we start by defining a module SHVZK containing two procedures:
\label{def:sigma:shvzk}
  \begin{figure}[ht]
    \centering
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc real(h, w, e) = {
   a = init(h,w);
   z = respose(h,w,e,a);
   return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc ideal(h, e) = {
  (a, z) = simulator(h, e);
  return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
    \caption{SHVZK module}
  \end{figure}
  We then say a $\Sigma$-Protocol S is special honest verifier zero-knowledge
  if:
  \[
    equiv[\texttt{SHVZK}.real \sim \texttt{SHVZK}.ideal :\; \indis{h, e} \land \text{R
    h w}^{real} \implies \indis{res}]
  \]
\end{definition}

\begin{definition}
\label{def:sigma-protocol}
  S is said to be a $\Sigma$-Protocol if it implements the procedures in figure
  \ref{lst:sigma_procedures} and satisfy the definitions of completeness,
  special soundness, and special honest verifier zero-knowledge.
\end{definition}

\todo{Argue that games corresponds to original definitions}

\todo{SHVZK only captures perfect indis. Unclear how to do with equiv?}

\todo{To prove compound we assume to following relations to be true \dots and
this only hold if both inputs are in the domain of R.}

\section{Compound Protocols}
\label{sec:sigma_comp}
Given our formalisation of $\Sigma$-Protocols we now show that our formalisation
composes is various ways. More specially it is possible to prove knowledge of
relations compounded by the logical operators ``AND'' and ``OR''.
The benefit of this is...

Formalisations of compound $\Sigma$-Protocols already exists for other proof
assistants \cite{cryptoeprint:2019:1185,certicrypt_sigma}, which we will also
use as a basis for our \easycrypt\ formalisation. By drawing on previous work we
aim to make a formalisation that is workable and succinct within reason of what
\easycrypt\ allows us to do. Moreover, by recreating formalisations within new
proof assistant we can gain valuable insight into how \easycrypt\ compares to
other proof assistant whilst reflecting on how to improve previous work.

\paragraph{Higher order instances of theories} \todo{Unsure how?}

\subsection{AND}
\label{subsec:sigma_AND}
\todo{Based on description from \cite{on-sigma-protocols}}
\todo{Not entirely correct. Need $h \in domain R$ to discharge axioms}
Given two $\Sigma$-Protocols, $S_{1}$ with relation $R_{1}(h_{1},w_{1})$ and
$S_{2}$ with relation $R_{2}(h_{2},w_{2})$ we define the AND construction to be a
$\Sigma$-Protocol proving knowledge of the relation
$R((h_{1}, h_{2}), (w_{1}, w_{2})) = R_{1}(h_{1}, w_{1}) \land R_{2}(h_{2}, w_{2})$.

The construction of AND protocol is then a $\Sigma$-Protocol running both
$S_{1}$ and $S_{2}$ as sub-procedures. To formalise this we start by declaring
the AND construction as an instantiation of a $\Sigma$-Protocol. To do this we
first need to define the types for which the protocol works of. But before we
can define the types of the AND construction we need to know the types of the
underlying $\Sigma$-Protocols $S_{1}$ and $S_{2}$. To denote the types of
$S_{i}$ we use the notation: $\text{type}_i$
\begin{align*}
  \textbf{Type: } &\text{statement = statement}_{1} \times \text{statement}_{2} \\
                  &\text{witness = witness}_{1} \times \text{witness}_{2} \\
                  &\text{message = message}_{1} \times \text{message}_{2} \\
                  &\text{challenge = challenge}_{1} = \text{challenge}_{2} \\
                  &\text{response = response}_{1} \times \text{response}_{2} \\
\end{align*}

We then define the AND construction as a module parametrised by
$\Sigma$-Protocols satisfying the type signatures of $S_{1}$ and $S_{2}$, which
can be seen in Listing \ref{lst:and-procedures}. This might seem restrictive,
since the AND construction can now only be made from $\Sigma$-Protocol with the
specific type signature of $S_{1}$ and $S_{2}$, but recall that the entire AND
construction is quantified over the types given in the type declaration. This
means that the types of $S_{1}$ and $S_{2}$ can be fixed to any arbitrary types
and therefore can express any $\Sigma$-Protocol.
But, if $S_{1}$ and $S_{2}$ are any arbitrary $\Sigma$-Protocols, then why are
the AND construction parametrised by $\Sigma$-Protocols satisfying the type
signatures of $S_{1}$ and $S_{2}$ rather than just parametrising the AND
construction be any two $\Sigma$-protocols? Ideally, this would how the AND
construction is formalised, but due to how \easycrypt\ handles types we
need to declare the types of the AND construction and ensure that the procedures
are typeable. The only way of ensuring this is by fixing the types of the
underlying $\Sigma$-Protocols before instantiation the AND construction as a $\Sigma$-Protocol.

\todo{Explicitly mention axioms}

\begin{lstlisting}[float,label=lst:and-procedures,caption=AND construction]
module ANDProtocol (P1 : S1, P2 : S2) = {
  proc init(h : statement, w : witness) = {
    (h1, h2) = h;
    (w1, w2) = w;

    a1 = P1.init(h1, w1);
    a2 = P2.init(h2, w2);
    return (a1, a2);
  }

  proc response(h : statement, w : witness, m : message, e : challenge) : response = {
    (m1, m2) = m;
    (h1, h2) = h;
    (w1, w2) = w;

    z1 = P1.response(h1, w1, m1, e);
    z2 = P2.response(h2, w2, m2, e);
    return (z1, z2);
  }

  proc verify(h : statement, m : message, e : challenge, z : response) : bool = {
    (h1, h2) = h;
    (m1, m2) = m;
    (z1, z2) = z;

    v = P1.verify(h1, m1, e, z1);
    v' = P2.verify(h2, m2, e, z2);

    return (v /\ v');

  }
\end{lstlisting}

\paragraph{Security}
Given the AND constructions instantiation of a $\Sigma$-Protocols we simply need
to prove the security definitions given in section \ref{sec:sigma:def} with
regards to the module \texttt{ANDProtocol}

\begin{lemma}[AND Completeness]
  Assume $\Sigma$-Protocols $P_{1}$ and $P_{2}$ are complete then
  Module $\texttt{ANDProtocol}(P_1, P_2)$ satisfy completeness definition \ref{def:sigma:completeness}
\end{lemma}
\begin{proof}
  By inlining the procedures of $\texttt{ANDProtocol}(P_{1}, P_{2})$ in
  \texttt{Completeness(ANDProtocol).special} we see that it is equivalent to:
  \texttt{Completeness($P_{1}$).special; Completeness($P_{2}$).special}. Which is true by our
  assumption of $P_{1}$ and $P_{2}$ being complete.
  We need to use the \texttt{special} definition of the completeness game here,
  since the challenge $e$ is given by a Verifier running the AND construction.
  And the sub-protocols are, therefore, not allowed to sample their own
  challenges and need to use the challenge from the AND construction.
\end{proof}

\todo{Write protocol as diagram?}

\begin{lemma}[AND special soundness]
  The AND construction satisfy definition \ref{def:sigma:soundness}
\end{lemma}
\begin{proof}
  trivial by construction
\end{proof}

\begin{lemma}[AND SHVZK]
  Given $\Sigma$-Protocols $P_{1}$ and $P_{2}$ that satisfy SHVZK then AND is SHVZK
\end{lemma}
\begin{proof}
  Construction
\end{proof}

\subsection{OR}
\label{subsec:sigma_OR}
Here we use the definition of the OR construction by \cite{on-sigma-protocols},
which states that both sub-protocols must have the same witness type.

Given two $\Sigma$-Protocols, $S_{1}$ with relation $R_{1}(h_{1},w)$ and
$S_{2}$ with relation $R_{2}(h_{2},w)$ we define the AND construction to be a
$\Sigma$-Protocol proving knowledge of the relation
$R((h_{1}, h_{2}), w) = R_{1}(h_{1}, w) \lor R_{2}(h_{2}, w)$.

The main idea behind the OR construction, is that by the SHVZK it is possible to
construct accepting conversations for both $S_{1}$ and $S_{2}$ if the Prover is
allowed to choose what challenge he responds to. Obviously, if the Prover is
allowed to chose the challenge the protocol is would not be secure. Therefore,
we limit the Prover such that he can choose the challenge for one sub-protocol,
but must run the other sub-protocol with a challenge influenced by the Verifier.
This is done by letting the Prover chose two challenges $e_{1}$ and $e_{2}$,
which the Verifier will only accept, if the $e_{1} \oplus e_{2} = s$ where $s$
is the challenge produced by the Verifier.
By producing accepting transcripts for both sub-protocols it must be true that
he knew the witness for at least one of the relations.

To formalise this we first need a way to express that the challenge type
supports XOR operations. To do this we add the following axioms, which will have
to be proven true before our formalisation can be applied.

\begin{gather}
  \textbf{op } (\oplus) \; c_{1} \; c_{2} : \text{challenge} \label{def:op:xor} \\
  \textbf{axiom xorK } x \; c : (x \oplus c) \oplus c = x \label{axiom:xorK} \\
  \textbf{axiom xorA } x \; y : (x \oplus y) = y \oplus x \label{axiom:xorA}
\end{gather}

\todo{The protocol then proceeds as ...}

We then define the OR construction as a $\Sigma$-Protocol like in section
\ref{subsec:sigma_AND}. The procedures can be seen in listing \ref{lst:sigma:or}.

\begin{lstlisting}[float, mathescape, label=lst:sigma:or,caption=OR construction]
proc init(h : statement, w : witness) = {
  (h1, h2) = h;

  if (R1 h1 w) {
    a1 = S1.init(h1, w);
    e2 <$\$$ dchallenge;
    (a2, z2) = S2.simulator(h2, e2);
  } else {
    a2 = S2.init(h2, w);
    e1 <$\$$ dchallenge;
    (a1, z1) = S1.simulator(h1, e1);
  }
  return (a1, a2);
}

proc response(h : statement, w : witness, m : message, s : challenge) = {
  (m1, m2) = m;
  (h1, h2) = h;

  if (R1 h1 w) {
    e1 = s $\oplus$ e2;
    z1 = S1.response(h1, w, m1, e1);
  } else {
    e2 = s $\oplus$ e1;
    z2 = S2.response(h2, w, m2, e2);
  }
  return (e1, z1, e2, z2);
}

proc verify(h : statement, m : message, s : challenge, z : response) = {
  (h1, h2) = h;
  (m1, m2) = m;
  (e1, z1, e2, z2) = z;

  v = S1.verify(h1, m1, e1, z1);
  v' = S2.verify(h2, m2, e2, z2);

  return ((s = e1 $\oplus$ e2) /\ v /\ v');
}
\end{lstlisting}

\todo{Write protocol as diagram?}

\paragraph{Security}
Given the OR constructions instantiation of a $\Sigma$-Protocols we simply need
to prove the security definitions given in section \ref{sec:sigma:def} with
regards to the module \texttt{ORProtocol}

\begin{lemma}[OR Completeness]
  Assume $\Sigma$-Protocols $P_{1}$ and $P_{2}$ are complete and shvzk then
  Module $\texttt{ORProtocol}(P_1, P_2)$ satisfy completeness definition \ref{def:sigma:completeness}
\end{lemma}
\begin{proof}
  To prove completeness we branch depending on which relation holds. If R1 $h1$
  $w$ holds then all P1 procedures can be grouped together as the P1
  completeness game. We then need to prove that \texttt{S2.verify} output accept
  on the transcript generated by \texttt{S2.simulator} which is true by the
  assumption of SHVZK of P2.
  The proof when R2 $h2$ $w$ holds follows similarly.
\end{proof}

\begin{lemma}[OR SHVZK]
  Given $\Sigma$-Protocols $P_{1}$ and $P_{2}$ that satisfy SHVZK then:
  \[
    equiv[SHVZK(OR(P1, P2)).ideal \sim SHVZK(OR(P1, P2)).real]
  \]
  With the Pre and Post condition given by definition \ref{def:sigma:shvzk}.

  Where the simulator for the OR construction is given by

\begin{lstlisting}
proc simulator(h : statement, s : challenge) : message * response = {
  (h1, h2) = h;
  e2 <$ dchallenge;
  e1 = s ^^ c2;

  (a1, z1) = P1.simulator(h1, e1);
  (a2, z2) = P2.simulator(h2, e2);

  return ((a1, a2), (e1, z1, e2, z2));
}
\end{lstlisting}
\end{lemma}
\begin{proof}
  We again split the proof based on which relation holds.
  \textbf{case (R1 h1 w)} for this case we have to show the following.
  \noindent\textbf{1)} that $e1$ and $e2$ are indistinguishable. This follows
  trivially since we assume both procedures make the same random choices and
  since the order in which the challenges are sampled they must be equal.

  \noindent\textbf{2)} that the transcript $(a1, e1, z1)$ made by running P1 on
  input (h1,w) is indistinguishable from the transcript produced by
  \texttt{P1.simulator}(h, e1). The rest of the procedures is trivially
  equivalent since they call the same procedures with the same arguments.
  This follows from the SHVZK property of P1.

  Both of these facts allow us that the procedures are indistinguishable in this
  case, since if the challenges are indistinguishable then the sub-procedures in
  both procedures are effectively called on the same inputs.

  \noindent\textbf{case (R2 h2 w)} This proof follows the same steps as the
  other case with the only exception being step \textbf{1)}. In this step, since
  the challenges are sampled in a different order, we cannot assume them to be
  equal since they are sampled with different randomness. Instead we use
  \easycrypt's coupling functionality to prove that
  $e_{1}^{ideal} \sim e_{1}^{real} \oplus s$ and
  $e_{1}^{real} \sim e_{1}^{ideal} \oplus s$ which allows us to assume
  $e_{1}^{ideal} = e_{2}^{real} \oplus s$ and
  $e_{2}^{real} = e_{1}^{ideal} \oplus s$ for the rest of the proof.
  The indistinguishability follows trivially since the challenge distribution is
  assumed full and uniform.

  From this we are left with showing:
  \begin{align*}
    e_{1}^{real} &= s \oplus e_{2}^{real} && \text{eq. \ref{axiom:xorK} and \ref{axiom:xorA}} \\
                &= s \oplus e_{1}^{ideal} \oplus s && \text{Coupling} \\
                &= e_{1}^{ideal} && \text{eq. \ref{axiom:xorK} and \ref{axiom:xorA}}
  \end{align*}

  Which completes the proof.
\end{proof}

\begin{lemma}[OR special soundness]
  The OR construction satisfy definition \ref{def:sigma:soundness} with the
  witness extractor for the OR construction defined as:
\begin{lstlisting}[mathescape]
proc witness_extractor(h, a, s : challenge list, z : response list) = {
  (h1, h2) = h;
  (m1, m2) = m;
  (e1, z1, e2, z2) = z[0];
  (e1', z1', e2', z2') = z[1];
  if (e1 $\neq$ e1') {
    w = P1.witness_extractor(h1, m1, [e1;e1'], [z1;z1']);
  } else {
    w = P2.witness_extractor(h2, m2, [e2;e2'], [z2;z2']);
  }
  return w;
}
\end{lstlisting}

\end{lemma}
\begin{proof}
  Construction
\end{proof}

\section{Fiat-Shamir Transformation}
\label{subsec:fiat-shamir}
The Fiat-Shamir transformation is a technique for converting $\Sigma$-protocols
into zero-knowledge protocols. $\Sigma$-Protocols almost satisfy the definition
of zero-knowledge, the only problem is that $\Sigma$-Protocols only guarantee
zero-knowledge given the verifier is honest. This is stated by the Special
Honest Verifier Zero-Knowledge property. However, if we can alter the protocol
to force the verifier to always be honest, then the protocol, by definition,
must be zero-knowledge.
The Fiat-Shamir transformation achieves this by removing the verifier from the
protocol and thus making it non-interactive. The verifier is then replaced by an
random oracle, which generates a random challenge based on the first message of
the prover, thus it works exactly like an honest verifier in the interactive
protocol. However, since the random oracle is a sub-procedure of the prover he
is allowed to make polynomially many call to the oracle in the hopes of getting
a good challenge.

\subsection{Oracles}
\label{subsec:sigma:fiat:oracle}


To formalise this transformation we first formalise what we expect a random
oracle to do...

\subsection{Non-interactive $\Sigma$-Protocol}
\label{subsec:sigma:fiat:protocol}

We can define the non-interactive version of the protocol as:

\subsection{Security}
\label{subsec:sigma:fiat:security}

And we can then prove completeness ans zero-knowledge of the protocol by...

Soundness, however, cannot be proven by the definition of special soundness from
$\Sigma$-Protocols, since the Prover has gained more possibilities of cheating
the verifier. We could prove some arbitrary bounds, but to get a meaningful
proof of soundness for the Fiat-Shamir transformation we would need the
rewinding lemma, which still an open research topic to formalise within \easycrypt\ \cite{ec_intro}.

\section{Concrete instantiation: Schnorr protocol}
\label{sec:schnorr}
To show the workability of the proposed formalisation we show that it can be
used to instantiate Schnorr's protocol.
The Schnorr's protocol is run between a Prover C and a
Verifier R. Both parties have before running the protocol agreed on a group
$(\mathcal{G}, q, g)$, where $q$ is the order of $\mathbb{G}$ and $g$ is the
generator for the group.
Schnorr's protocol is a $\Sigma$-Protocol for proving knowledge of a discrete
logarithm. Formally it is a $\Sigma$-Protocol for the relation R h w $= h = g^{w}$

When the P wants to prove knowledge of the w to V he starts by
constructing a message $a = g^{r}$ for some random value $r$. The Verifier will
the generate a random challenge, $e$, which is a bit-string of some arbitrary length
that defines the security of the protocol.
Based on this challenge P then constructs a response $z = r + e * w$ and sends
it to V.
To verify the transcript $(a,e,z)$ V then checks if $g^{z} = a * h^{e}$.

From this general description it is clear that this protocol fits within out
formalisation of $\Sigma$-Protocol procedures. We then define the appropriate
types and instantiate the protocol using out $\Sigma$-Protocol formalisation:

\begin{lstlisting}[mathescape,label=lst:sigma:schnorr,caption=Schnorr instantiation]
clone export SigmaProtocols as Sigma with
  type statement <- group, (* group element *)
  type witness   <- F.t,   (* Finite field element, like $\mathbb{Z}_{q}$ *)
  type message   <- group,
  type challenge <- F.t,
  type response  <- F.t,

  op R h w =  ($h = g^w$)
  op dchallenge = FDistr.dt (* Distribution of messages *)
  proof *.
  realize dchallenge_llfuni. by split; [apply FDistr.dt_ll | apply FDistr.dt_funi].

module Schnorr : SProtocol = {
  var r : F.t
  proc init(h : statement, w : witness) : message = {
    r <$\$$ FDistr.dt;
    return $g^r$;
  }

  proc response(h : statement, w : witness, a : message, e : challenge) : response = {
    return $r + e \cdot w$;
  }

  proc verify(h : statement, a : message, e : challenge, z : response) : bool = {
    return $(g^z = a \cdot (h ^e))$;
  }
}
\end{lstlisting}

Here we first discharge the assumption that the challenge are lossless, uniform
and fully distributed by using the \easycrypt\ theories about distributions and
cyclic groups.

To prove security of the protocol we show that the it satisfies the security
definitions from section \ref{sec:sigma:def}.

\begin{lemma}[Schnorr correctness]
  R h w $\implies \Pr{\texttt{Completeness(Schnorr)}.main(h,w)} = 1$
\end{lemma}
\begin{proof}
  To prove correctness we need to prove two things:
  \begin{enumerate}
    \item That the procedure always terminates
    \item That it always outputs true
  \end{enumerate}
  \textbf{1)} Since all procedures bar the random sampling in $\texttt{Schnorr}$ are arithmetic
  operations they can never fail. The random sampling have been proven to be
  lossless. Therefore the procedures always terminates.

  \noindent\textbf{2)} After running all sub-procedures of the correctness game
  the output of the procedure is
  \begin{align*}
         &g^{r + e \cdot w} = g^{r} \cdot h^{e} \\
    \iff &g^{r + e \cdot w} = g^{r} \cdot g^{w^{e}} && \text{R h w = ($h = g^{w}$)} \\
    \iff &g^{r} \cdot g^{e \cdot w} = g^{r} \cdot g^{w \cdot {e}} \\
  \end{align*}

  Which is easily proven by \easycrypt\ automation tools for algebraic operations.
\end{proof}

\begin{lemma}[Schnorr soundness]
  \begin{align*}
    &e \neq e' \implies \\
    &\Pr{\texttt{verify}(a, e, z)} = 1 \implies \\
    &\Pr{\texttt{verify}(a, e', z')} = 1 \implies \\
    &\Pr{\texttt{Soundness(Schnorr)}(a, [e; e'], [z; z'])} = 1 \\
  \end{align*}
\end{lemma}
\begin{proof}
  We start by defining the witness extractor for Schnorr's protocol:
\begin{lstlisting}
proc witness_extractor(h : statement, m : message, e : challenge list, z : response list) : witness= {
  return (z[0] - z[1]) / (e[0] - e[1]);
}
\end{lstlisting}
  \todo{Define list indexing in background chapter}
  To prove that the soundness game succeeds we need the following
  \begin{enumerate}
    \item Both transcripts are accepting
    \item The witness extractor produces a valid witness for the relation R
  \end{enumerate}

  \textbf{1)} By stepping though the while loop of the soundness game we can
  show that all transcripts must be accepting by our assumptions.

  \noindent \textbf{2)} Running all procedures of the soundness game we are left
  with showing:
  \begin{align*}
    \text{R h } ((z - z') / (e - e')) &= (h = g ^{((z - z') / (e - e'))}) \\
                                      &= (h = g ^{((z - z') / (e - e'))}) \\
  \end{align*}
  \todo{Rest like pen and paper proof but with cyclic group theory operations}
\end{proof}

\begin{lemma}[Schnorr SHVZK]
  \[
    equiv[\texttt{SHVZK(Schnorr)}.ideal \sim \Pr{\texttt{SHVZK(Schnorr)}.real} :\; \indis{h,e} \land \text{R h w}^{real} \implies \indis{res}]
  \]
\end{lemma}
\begin{proof}
  We start by defining the simulator for Schnorr's protocol:
\begin{lstlisting}[mathescape]
proc simulator(h : statement, e : challenge) = {
  z <$\$$ FDistr.dt;
  a = $g^z * h ^ (-e)$;
  return (a, z);
}
\end{lstlisting}
  To prove SHVZK be must the prove output indistinguishability of the following procedures:
  \begin{figure}[ht]
    \centering
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc real(h, w, e) = {
   r <$\$$ FDistr.dt;
   a = $g^r$;
   z = $r + e \cdot w$;
   return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc ideal(h, e) = {
  z <$\$$ FDistr.dt;
  a = $g^z * h^{(-e)}$;
  return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
  \end{figure}
  To prove this we use \easycrypt\ coupling functionality to show that $r^{real} \equiv z^{ideal} - e \cdot w^{real}$ and that $z^{ideal} \equiv r^{real} + e \cdot w^{real}$.
  This is easily prove, since the distribution is full and uniform, and the group is closed under addition and multiplication. All these facts follow directly from the cyclic group theory in \easycrypt.
  By the coupling functionality we are then for the rest of the proof allowed to assume:
  $r^{real} = z^{ideal} - e \cdot w^{real}$ and $z^{ideal} = r^{real} + e \cdot
  w^{real}$. We then use this to show output indistinguishability:
  \begin{align*}
    (a^{real}, e, z^{real}) &= (g^{r^{real}}, e, r^{real} + e \cdot w^{real}) \\
                          &= (g^{r^{real}}, e, z^{ideal} - e \cdot w^{real} + e \cdot w^{real}) \\
                          &= (g^{z^{ideal} - e \cdot w^{real}}, e, z^{ideal}) \\
                          &= (g^{z^{ideal}} \cdot g^{w^{real} - e}, e, z^{ideal}) \\
                          &= (g^{z^{ideal}} \cdot h^{(-e)}, e, z^{ideal}) \\
                          &= (a^{ideal}, e, z^{ideal}) \\
  \end{align*}
  Which is proven by \easycrypt's automation tools.
\end{proof}
\todo{Define generalised notation for comparing views in background chapter}
\todo{The proofs have been relatively easy thanks to the strong support for algebraic groups in EC}


\paragraph{Conclusion}
In this section we have seen ...

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
