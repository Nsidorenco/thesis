\chapter{Formalising $\Sigma$-Protocols}
\label{ch:formal_sigma}
In this chapter, we formalise $\Sigma$-Protocols along with different
constructions based on $\Sigma$-Protocols. Our formalisation is driven by the
definitions given by \citet{on-sigma-protocols} and already existing
formalisation of $\Sigma$-Protocols in the \easycrypt\ source code \cite{ec_source}. Our work
improves on previous work by providing more generalised definitions, namely
$s$-special soundness instead of the usual $2$-special soundness definition
given. Additionally, we also provide an alternative definition of completeness.
Moreover, we reproduce the work of compound $\Sigma$-Protocols by
\citet{cryptoeprint:2019:1185} by formalising their results in \easycrypt.
We then introduce the Fiat-Shamir transformation, which can turn any
$\Sigma$-Protocol into a non-interactive zero-knowledge protocol in the random
oracle model. We then explore how this transformation applies to our formalisation.
Last, we show that our formalisation can be used to prove the security of
Schnorr's $\Sigma$-Protocol.

\section{Defining $\Sigma$-Protocols}
\label{sec:sigma:def}
We start by defining the types for any arbitrary $\Sigma$-Protocol:
\begin{align*}
  \textbf{type: } &\text{statement} \\
                  &\text{witness} \\
                  &\text{message} \\
                  &\text{challenge} \\
                  &\text{response} \\
\end{align*}
These types corresponds to the types from Figure \ref{fig:proto_sigma}.

Furthermore, we define the relation for which the protocol operates on as a
binary function mapping a statement and witness to true/false
$R : (\text{statement} \times \text{witness}) \rightarrow \{0,1\}$.
Moreover, we fix a lossless, full, and uniform distribution over challenges space. This
distribution is used to model an honest verifier which will always generate a
uniformly random challenge.

We define a $\Sigma$-protocol to be a series of probabilistic procedures, which
can be seen in listing \ref{lst:sigma_procedures}.
\begin{lstlisting}[label=lst:sigma_procedures,caption=Abstract procedures of $\Sigma$-Protocols]
module type SProtocol = {
  proc init(h : statement, w : witness) : message
  proc response(h : statement, w : witness,
                m : message, e : challenge) : response
  proc verify(h : statement, m : message, e : challenge, z : response) : bool
  proc witness_extractor(h : statement, m : message, e : challenge list, z : response list) : witness option
  proc simulator(h : statement, e : challenge) : message * response
}
\end{lstlisting}

Here all procedures are defined in the same module. This allows the
Verifier procedure to access the global state of the prover, which could lead to
invalid proofs of security. It is, therefore, paramount to implement
\texttt{verify} such that it never accesses the global state of the SProtocol module.
This could have been alleviated by splitting the SProtocol module into multiple
different modules with only the appropriate procedures inside. This would remove
any potential for human error when defining a $\Sigma$-Protocol,
however, it is easier to quantify over one module containing all relevant procedures than
quantifying over a prover and a verifier module and then reasoning about the two
modules being part of the same $\Sigma$-Protocol.
Ultimately, we decided on defining everything within the same module.

\begin{lstlisting}[float, label=lst:sigma_completeness,caption=Completeness game for $\Sigma$-Protocols]
module Completeness(S : SigmaProtocol) = {
  proc main(h : input, w : witness) : bool = {
      var a, e, z;
      a = S.init(h,w);
      e <$ dchallenge;
      z = S.response(h, a, e);
      v = S.verify(h, a, e, z);
      return v;
  }
}.
\end{lstlisting}

An instantiation of a $\Sigma$-Protocol is then an implementation of the
procedures in listing \ref{lst:sigma_completeness}.

\paragraph{Security}
We then model security as a series of games:

\begin{definition}[Completeness]
\label{def:sigma:completeness}
  We say that a $\Sigma$-protocol, S, is complete, if the probabilistic procedure in
  listing \ref{lst:sigma_completeness} outputs 1 with probability 1, \ie
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall h \; w, \text{R } h \; w \implies \Pr{ \text{Completeness(S).main}(h,w) = true } = 1.
  \end{equation}
\end{definition}

One problem with definition $\ref{def:sigma:completeness}$ is that
quantification over challenges is implicitly done when sampling from the random
distribution of challenges. This mean that reasoning about the challenges are
done within the probabilistic Hoare logic, and not the ambient logic. If we, at
some later point, need the completeness property to hold for a specific
challenge, then that is not true by this definition of completeness, since
the ambient logic does not quantify over the challenges. To alleviate this
problem we introduce a alternative definition of completeness:

\begin{definition}[Alternative Completeness]
\label{def:sigma:alt_completeness}
  We say that a $\Sigma$-protocol, S, is complete if:
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall h,w,e. \text{R } h \; w \implies \Pr{\text{Completeness(S).special}(h,w,e) = true} = 1.
  \end{equation}
  Where the procedure ``Completeness(S).special'' is defined in listing \ref{lst:sigma:special}.
  \lstinputlisting[float, label=lst:sigma:special, linerange={40-48}]{../code/SigmaProtocols.eca}
\end{definition}

However, since the alternative procedure no longer samples from a random
distribution it is not possible to prove equivalence between the two procedure,
but to show that this alternative definition is still captures what is means for
a protocol to be complete we have the following lemma:

\begin{lemma}
  \label{lem:sigma:alt:completeness}
\begin{equation*}
  \Pr{\texttt{special} : true \implies res} = 1 \implies
  \Pr{\texttt{Completeness(S).main} : true \implies res} = 1.
\end{equation*}
\end{lemma}

\begin{proof}
Start by defining an intermediate game:
\begin{lstlisting}
proc intermediate(h : input, w : witness) : bool = {
   e <$ dchallenge;
   v = special(h, w, e);
   return v;
}
\end{lstlisting}

From this it is easy to prove equivalence between the two procedures
``intermediate'' and ``main'' by simply inlining the procedures and moving
the sampling to the first line of each program. This will make the two programs
equivalent.

Next, we prove the lemma by showing:
\begin{equation*}
  \Pr{\texttt{special} : true \implies res} = 1 \implies
  \Pr{\texttt{intermediate} : true \implies res} = 1.
\end{equation*}

The proof then proceeds by first sampling $e$ and then proving the following
probabilistic Hoare triplet: $true \vdash \{\exists e', e = e'\}
\text{special(h,w,e)} \{true\}$. Now, we can move the existential
from the pre-condition into the context:
\[
  e' \vdash \{e = e'\} \text{special(h,w,e)} \{true\}
\]

Which then is proven by the hypothesis of the ``special'' procedure being complete.
\end{proof}


\begin{definition}[Special Soundness]
\label{def:sigma:soundness}
  A $\Sigma$-Protocol S has $s$-special soundness if given a list of challenges
  $c$ and a list of responses $z$ with $\text{size } c = \text{size } z = s$, it
  holds that:
\begin{align*}
    & \forall (i \neq j). c[i] \neq c[j] \\
    \land &\forall (i \in [1 \dots s]). \Pr{S.verify(h, a, c[i], z[i])} = 1 \\
    &\implies \Pr{SpecialSoundness(\texttt{ANDProtocol}(S)).main(h, a, c, z)} = 1
\end{align*}

With \texttt{SpecialSoundness} defined as:

\begin{lstlisting}[float, label=lst:sigma-soundness, caption= 2-special soundness game]
module SpecialSoundness(S : SProtocol) = {
  proc main(h : statement, a : message, c : challenge list, z : response list) : bool = {
    w = S.witness_extractor(h, m, c, z);

    valid = true;

    while (c <> []) {
      c' = c[0];
      z' = z[0];
      valid = valid /\ S.verify(h, m, c', z');
      c = behead c;
      z = behead z;
    }

    return valid /\ R h (oget w);
}.
\end{lstlisting}
\end{definition}

\begin{definition}[Special honest-verifier zero-knowledge]
  To define SHVZK we start by defining a module SHVZK containing two procedures,
  which can be seen in figure \ref{fig:sigma:shvzk}
\label{def:sigma:shvzk}
  \begin{figure}[ht]
    \centering
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc real(h, w, e) = {
   a = init(h,w);
   z = respose(h,w,e,a);
   return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc ideal(h, e) = {
  (a, z) = simulator(h, e);
  return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
    \caption{SHVZK module}
    \label{fig:sigma:shvzk}
  \end{figure}
  We then say a $\Sigma$-Protocol S is special honest verifier zero-knowledge
  if:
  \[
    equiv[\texttt{SHVZK}.real \sim \texttt{SHVZK}.ideal :\; \indis{h, e} \land \text{R
    h w}^{real} \implies \indis{res}]
  \]
\end{definition}

\begin{definition}
\label{def:sigma-protocol}
  S is said to be a secure $\Sigma$-Protocol if it implements the procedures in figure
  \ref{lst:sigma_procedures} and satisfies the definitions of completeness,
  special soundness, and special honest-verifier zero-knowledge.
\end{definition}

We note that our definition of special honest-verifier zero-knowledge is not
expressive enough for all use cases. Since we are using \easycrypt's pRHL to
distinguish the two procedures, our definition only captures perfect
zero-knowledge. If we wanted a definition capable of expressing computational
zero-knowledge, we would have to use an adversary to compare the two procedures.
We opted to restrict SHVZK to perfect zero-knowledge.

\section{Compound Protocols}
\label{sec:sigma_comp}
Given our formalisation of $\Sigma$-Protocols we now show that our formalisation
composes in various ways. More specifically, we show that it is possible to prove knowledge of
relations compounded by the logical operators ``AND'' and ``OR''.

Formalisations of compound $\Sigma$-Protocols already exists in other proof
assistants \cite{cryptoeprint:2019:1185,certicrypt_sigma}, which we will also
use as a basis for our \easycrypt\ formalisation. Primarily, we aim to reproduce
the results of \citet{cryptoeprint:2019:1185}.
By reproducing formalisations within a new proof
assistant, we can gain valuable insight into how \easycrypt\ compares to other
proof assistant while reflecting on how to improve previous work.

\paragraph{Higher-order instances of theories}
\begin{draft}
We then define the AND construction as a module parametrised by
$\Sigma$-Protocols satisfying the type signatures of $S_{1}$ and $S_{2}$, which
can be seen in Listing \ref{lst:and-procedures}. This might seem restrictive,
since the AND construction can now only be made from $\Sigma$-Protocol with the
specific type signature of $S_{1}$ and $S_{2}$, but recall that the entire AND
construction is quantified over the types given in the type declaration. This
means that the types of $S_{1}$ and $S_{2}$ can be fixed to any arbitrary types
and therefore can express any $\Sigma$-Protocol.
Nevertheless, if $S_{1}$ and $S_{2}$ are any arbitrary $\Sigma$-Protocols, then why are
the AND construction parametrised by $\Sigma$-Protocols satisfying the type
signatures of $S_{1}$ and $S_{2}$ rather than just parametrising the AND
construction be any two $\Sigma$-protocols? Ideally, the AND
construction would be formalised in this way, but due to how \easycrypt\ handles
types of modules we
need to declare the types of the AND construction and ensure that the procedures
are typeable. The only way of ensuring this is by fixing the types of the
underlying $\Sigma$-Protocols before instantiation the AND construction as a $\Sigma$-Protocol.
\end{draft}

\subsection{AND}
\label{subsec:sigma_AND}
Given two $\Sigma$-Protocols, $S_{1}$ with relation $R_{1}(h_{1},w_{1})$ and
$S_{2}$ with relation $R_{2}(h_{2},w_{2})$ we define the AND construction to be a
$\Sigma$-Protocol proving knowledge of the relation
$R((h_{1}, h_{2}), (w_{1}, w_{2})) = R_{1}(h_{1}, w_{1}) \land R_{2}(h_{2}, w_{2})$.

The construction of AND is itself a $\Sigma$-Protocol running both
$S_{1}$ and $S_{2}$ as sub-procedures. To formalise this, we start by declaring
the AND construction as an instantiation of a $\Sigma$-Protocol. To do this we
first need to define the types of AND construction. However, before we
can define the types we need to know the types of the
underlying $\Sigma$-Protocols $S_{1}$ and $S_{2}$. To denote the types of
$S_{i}$ we use the notation: $\text{type}_i$
\begin{align*}
  \textbf{Type: } &\text{statement = statement}_{1} \times \text{statement}_{2} \\
                  &\text{witness = witness}_{1} \times \text{witness}_{2} \\
                  &\text{message = message}_{1} \times \text{message}_{2} \\
                  &\text{challenge = challenge}_{1} = \text{challenge}_{2} \\
                  &\text{response = response}_{1} \times \text{response}_{2} \\
\end{align*}

We then define the procedures of the AND construction as seen in listing \ref{lst:and-procedures}.
The AND construction works by running both protocols in parallel. The first
message, therefore, becomes the product of the messages produced by the
underlying protocols. The responses are similarly created.

\begin{lstlisting}[float,label=lst:and-procedures,caption=AND construction]
module ANDProtocol (P1 : S1, P2 : S2) = {
  proc init(h : statement, w : witness) = {
    (h1, h2) = h;
    (w1, w2) = w;

    a1 = P1.init(h1, w1);
    a2 = P2.init(h2, w2);
    return (a1, a2);
  }

  proc response(h : statement, w : witness, m : message, e : challenge) : response = {
    (m1, m2) = m;
    (h1, h2) = h;
    (w1, w2) = w;

    z1 = P1.response(h1, w1, m1, e);
    z2 = P2.response(h2, w2, m2, e);
    return (z1, z2);
  }

  proc verify(h : statement, m : message, e : challenge, z : response) : bool = {
    (h1, h2) = h;
    (m1, m2) = m;
    (z1, z2) = z;

    v = P1.verify(h1, m1, e, z1);
    v' = P2.verify(h2, m2, e, z2);

    return (v /\ v');

  }
\end{lstlisting}

\paragraph{Security}
Given that the AND constructions is a $\Sigma$-Protocols we need
to prove the security definitions given in section \ref{sec:sigma:def} with
regards to the module \texttt{ANDProtocol}

\begin{lemma}[AND Completeness]
  Assume $\Sigma$-Protocols $P_{1}$ and $P_{2}$ are complete then
  Module $\texttt{ANDProtocol}(P_1, P_2)$ satisfy completeness definition \ref{def:sigma:completeness}
\end{lemma}
\begin{proof}
  By inlining the procedures of $\texttt{ANDProtocol}(P_{1}, P_{2})$ in
  \texttt{Completeness(ANDProtocol).special} we see that it is equivalent to:
  \texttt{Completeness($P_{1}$).special; Completeness($P_{2}$).special}. Which is true by our
  assumption of $P_{1}$ and $P_{2}$ being complete.
  We need to use the \texttt{special} definition of the completeness game here
  since the challenge $e$ is given by a Verifier running the AND construction.
  Where we to use the original definition of completeness, then the AND construction
  would need randomly sample two challenges to prove equivalence with the
  binding games, which is not the case.

  By lemma \ref{lem:sigma:alt:completeness} we get that
  $\Pr{\texttt{Completeness(AND($P_{1}, P_{2}$)}.main} = 1$
\end{proof}

\begin{lemma}[AND special soundness]
  Given secure $\Sigma$-Protocols P1 and P2
  the AND construction AND(P1, P2) satisfy definition \ref{def:sigma:soundness}
  with $s = 2$.

  The witness extractor is defined in listing \ref{lst:AND:extractor}
\begin{lstlisting}[float,label=lst:AND:extractor,caption=Witness extractor for AND construction]
proc witness_extractor(h : statement, a : message, e : challenge list, z : response list) = {
  (h1, h2) = h;
  (a1, a2) = a;
  e = e[0];
  e' = e[1];
  (z1, z2) = z[0];
  (z1', z2') = z[1];
  w1 = P1.witness_extractor(h1, a1, [e;e'], [z1;z1']);
  w2 = P2.witness_extractor(h2, a2, [e;e'], [z2;z2']);

  return Some(oget w1, oget w2);
}
\end{lstlisting}
\end{lemma}
\begin{proof}
  We start by showing that
  \begin{align}
    &\texttt{AND.verify}((h_{1}, h_{2}), (a_{1}, a_{2}), e, (z_{1}, z_{2})) \label{eq:and:verify}\\
    \iff &\texttt{P1.verify}(h_{1}, a_{1}, e, z_{1}) \land \texttt{P2.verify}(h_{2}, a_{2}, e, z_{2})
  \end{align}
  Which follows directly from the definition of \texttt{AND.verify}.

  Then, since relation of AND requires a witness for both $R_{1}$ and $R_{2}$,
  we can use the $2$-special soundness property of $P_{1}$ and $P_{2}$ to
  conclude the proof.
\end{proof}

\begin{lemma}[AND SHVZK]
  Given secure $\Sigma$-Protocols $P_{1}$ and $P_{2}$ then AND(P1, P2) satisfy
  definition \ref{def:sigma:shvzk}.

  The simulator for the AND construction is given in listing \ref{lst:AND:simulator}.
\begin{lstlisting}[float,label=lst:AND:simulator,caption=Simulator for the AND construction]
proc simulator(h : statement, e : challenge) : message * response = {
  (h1, h2) = h;

  (a1, z1) = P1.simulator(h1, e);
  (a2, z2) = P2.simulator(h2, e);

  return ((a1, a2), (z1, z2));
}
\end{lstlisting}
\end{lemma}
\begin{proof}
  Since the simulator for AND is running both simulator for P1 and P2,
  we use \ref{eq:and:verify} to apply the SHVZK property of P1 and P2.
  From this, we can conclude that the transcript of the simulator is
  indistinguishable from the transcript of running honest versions of P1 and P2.
  By correctness of AND the proof is then complete.
\end{proof}

\subsection{OR}
\label{subsec:sigma_OR}
For the OR construction we use the definition of the OR construction by \citet{on-sigma-protocols},
which states that both sub-protocols must have the same witness type.

Given two $\Sigma$-Protocols, $S_{1}$ with relation $R_{1}(h_{1},w)$ and
$S_{2}$ with relation $R_{2}(h_{2},w)$ we define the OR construction to be a
$\Sigma$-Protocol proving knowledge of the relation
$$R((h_{1}, h_{2}), w) = R_{1}(h_{1}, w) \lor R_{2}(h_{2}, w)$$.

However, this relation makes it impossible to realise our security definitions \cite{cryptoeprint:2019:1185}.
If the if public statement $h_{i}$ for which there is no witness is not in the
domain of statements with a possible witness making the relation true, then it
is possible for the verifier to guess for which of the two underlying relations hold.
To fix this we use the alternative relation:

\begin{align*}
  R((h_{1}, h_{2}), w) = &R_1(h_1, w) \land h_2 \in \textbf{Domain } R_2 \\
                   \lor &R_2(h_2, w) \land h_1 \in \textbf{Domain } R_1
\end{align*}


The main idea behind the OR construction, is that by SHVZK it is possible to
construct accepting conversations for both $S_{1}$ and $S_{2}$ if the Prover is
allowed to choose what challenge he responds to. Obviously, if the Prover is
allowed to chose the challenge, the protocol would not be secure. Therefore,
we limit the Prover such that he can choose the challenge for one sub-protocol,
but must run the other sub-protocol with a challenge influenced by the Verifier.
This is done by letting the Prover chose two challenges $e_{1}$ and $e_{2}$,
which the Verifier will only accept if the $e_{1} \oplus e_{2} = s$ where $s$
is the challenge produced by the Verifier.
By producing accepting transcripts for both sub-protocols, it must be true that
he knew the witness for at least one of the relations.

To formalise this, we need a way to express that the challenge type
supports XOR operations. To do this, we add the following axioms, which will have
to be proven true before our formalisation can be applied.

\begin{gather}
  \textbf{op } (\oplus) \; c_{1} \; c_{2} : \text{challenge} \label{def:op:xor} \\
  \textbf{axiom xorK } x \; c : (x \oplus c) \oplus c = x \label{axiom:xorK} \\
  \textbf{axiom xorA } x \; y : x \oplus y = y \oplus x \label{axiom:xorA}
\end{gather}

We then define the OR construction as a $\Sigma$-Protocol like in section
\ref{subsec:sigma_AND}. The procedures can be seen in listing \ref{lst:sigma:or}.

\begin{lstlisting}[float, mathescape, label=lst:sigma:or,caption=OR construction]
proc init(h : statement, w : witness) = {
  (h1, h2) = h;

  if (R1 h1 w) {
    a1 = S1.init(h1, w);
    e2 <$\$$ dchallenge;
    (a2, z2) = S2.simulator(h2, e2);
  } else {
    a2 = S2.init(h2, w);
    e1 <$\$$ dchallenge;
    (a1, z1) = S1.simulator(h1, e1);
  }
  return (a1, a2);
}

proc response(h : statement, w : witness, m : message, s : challenge) = {
  (m1, m2) = m;
  (h1, h2) = h;

  if (R1 h1 w) {
    e1 = s $\oplus$ e2;
    z1 = S1.response(h1, w, m1, e1);
  } else {
    e2 = s $\oplus$ e1;
    z2 = S2.response(h2, w, m2, e2);
  }
  return (e1, z1, e2, z2);
}

proc verify(h : statement, m : message, s : challenge, z : response) = {
  (h1, h2) = h;
  (m1, m2) = m;
  (e1, z1, e2, z2) = z;

  v = S1.verify(h1, m1, e1, z1);
  v' = S2.verify(h2, m2, e2, z2);

  return ((s = e1 $\oplus$ e2) /\ v /\ v');
}
\end{lstlisting}

\paragraph{Security}
Given the OR constructions is a $\Sigma$-Protocols we need
to prove the security definitions given in section \ref{sec:sigma:def} with
regards to the module \texttt{ORProtocol}

\begin{lemma}[OR Completeness]
  Assume $\Sigma$-Protocols $P_{1}$ and $P_{2}$ are complete and shvzk then
  $\texttt{ORProtocol}(P_1, P_2)$ satisfy completeness definition \ref{def:sigma:completeness}
\end{lemma}
\begin{proof}
  To prove completeness we branch depending on which relation holds. If R1 $h1$
  $w$ holds then all P1 procedures can be grouped into the P1
  completeness game. We then need to prove that \texttt{S2.verify} output accept
  on the transcript generated by \texttt{S2.simulator}, which is true by the
  assumption of SHVZK of P2.
  The proof when R2 $h2$ $w$ holds follows similarly.
\end{proof}

\begin{lemma}[OR SHVZK]
  Given $\Sigma$-Protocols $P_{1}$ and $P_{2}$ that satisfy SHVZK then:
  \[
    equiv[SHVZK(OR(P1, P2)).ideal \sim SHVZK(OR(P1, P2)).real]
  \]
  With pre and postcondition given by definition \ref{def:sigma:shvzk}.

  The simulator for the OR construction is given is listing \ref{lst:sigma:or:simulator}.

\begin{lstlisting}[label=lst:sigma:or:simulator]
proc simulator(h : statement, s : challenge) : message * response = {
  (h1, h2) = h;
  e2 <$ dchallenge;
  e1 = s ^^ c2;

  (a1, z1) = P1.simulator(h1, e1);
  (a2, z2) = P2.simulator(h2, e2);

  return ((a1, a2), (e1, z1, e2, z2));
}
\end{lstlisting}
\end{lemma}
\begin{proof}
  We again split the proof based on which relation holds.

  \noindent\textbf{case (R1 h1 w): } for this case we further split the proof
  into two steps:

  \noindent\textbf{1)} we show that $e1^{real} \sim e1^{ideal}$ and
  $e2^{real} \sim e2^{ideal}$. This follows trivially since we assume both
  procedures make the same random choices and since the order in which the
  challenges are sampled is the same then they must be equal.

  \noindent\textbf{2)} that the transcript $(a1, e1, z1)$ made by running P1 on
  input (h1,w) is indistinguishable from the transcript produced by
  \texttt{P1.simulator}(h, e1). The rest of the procedures is trivially
  equivalent since they call the same procedures with the same arguments.
  This follows from the SHVZK property of P1.

  Both of these facts allow us to conclude that the procedures are indistinguishable,
  since if the challenges are indistinguishable then the sub-procedures in
  both procedures are effectively called on the same inputs.

  \noindent\textbf{case (R2 h2 w): } This proof follows the same steps as the
  other case with the only exception being step \textbf{1)}. In this step, since
  the challenges are sampled in a different order, we cannot assume them to be
  equal since they are sampled with different randomness. More specially, $e1$
  is sampled at random and $e2 = s \oplus e1$ in this case.
  To prove this we instead use \easycrypt's coupling functionality and prove that
  $e_{1}^{ideal} \sim e_{1}^{real} \oplus s$ and
  $e_{1}^{real} \sim e_{1}^{ideal} \oplus s$
  The indistinguishability follows trivially since the challenge distribution is
  assumed full and uniform.

  From this we are left with showing:
  \begin{align*}
    e_{1}^{real} &= s \oplus e_{2}^{real} && \text{eq. \ref{axiom:xorK} and \ref{axiom:xorA}} \\
                &\sim s \oplus e_{1}^{ideal} \oplus s && \text{Coupling} \\
                &= e_{1}^{ideal} && \text{eq. \ref{axiom:xorK} and \ref{axiom:xorA}}
  \end{align*}

  Which completes the proof.
\end{proof}

\begin{lemma}[OR special soundness]
  Given secure $\Sigma$-Protocols P1 P2 then
  The OR construction OR(P1,P2) satisfy definition \ref{def:sigma:soundness}
  with $s = 2$ and witness extractor for the OR construction defined as:
\begin{lstlisting}mathescape]
proc witness_extractor(h, a, s : challenge list, z : response list) = {
  (h1, h2) = h;
  (a1, a2) = m;
  (e1, z1, e2, z2) = z[0];
  (e1', z1', e2', z2') = z[1];
  if (e1 $\neq$ e1') {
    w = P1.witness_extractor(h1, a1, [e1;e1'], [z1;z1']);
  } else {
    w = P2.witness_extractor(h2, a2, [e2;e2'], [z2;z2']);
  }
  return Some(oget w);
}
\end{lstlisting}

\end{lemma}
\begin{proof}
  We split the proof into two parts:
  \begin{itemize}
    \item $(e1 \neq e1')$: Here we must prove that \texttt{P1.witness\_extractor} produce a valid witness for R.

      Here we use equation \ref{eq:and:verify} from the special soundness
      proof of AND, which lets us apply the
      special soundness property of P1, which gives us that
      $R1 \; h1 \; w \implies R1 \; h1 \; w \lor R2 \; h2 \; w = R \; (h1, h2) \; w$
    \item $\neg(e1 \neq e1')$ Here we prove the same, but with the special
      soundness property of P2 instead.
  \end{itemize}
\end{proof}

\section{Fiat-Shamir Transformation}
\label{subsec:fiat-shamir}
The Fiat-Shamir transformation is a technique for converting $\Sigma$-protocols
into zero-knowledge protocols. $\Sigma$-Protocols almost satisfy the definition
of zero-knowledge, the only problem is that $\Sigma$-Protocols only guarantee
zero-knowledge in the presence of a honest verifier. This is stated by the special
honest-verifier zero-knowledge property. However, if we can alter the protocol slightly
to force the verifier to always be honest, then the protocol, by definition,
must be zero-knowledge.
The Fiat-Shamir transformation achieves this by removing the verifier from the
protocol, thus making it non-interactive.
The verifier is replaced by an random oracle, which generates a uniformly random
challenge based on the first message of the prover. The random oracle,
therefore,  works exactly like an honest verifier in the interactive protocol.
However, since the prover is responsible for obtaining the challenge from random
oracle, and there is no interaction with the verifier, he is free to call
the oracle as many times as he wants. The only limitations is that the time
complexity of the protocol must still be polynomial. Therefore, the prover can
only make polynomially many calls to the oracle.
The problem with allowing the prover to call the oracle multiple times is
he can keep sampling new challenges from the oracle until he gets a challenge that he can answer.


\subsection{Oracles}
\label{subsec:sigma:fiat:oracle}
To formalise this transformation we first need a clear description of what a
random oracle is.

To capture the functionality of a random oracle we define the following abstract
module:
\begin{lstlisting}
module type Oracle = {
  proc * init() : unit
  proc sample (m : message) : challenge
}.
\end{lstlisting}

In essence, an oracle should be able to initialise its state, which is used to
determine the random choices made by the oracle. Moreover, it exposes the
procedure $\texttt{sample}$ which samples new challenges based on messages.

In the case of a random oracle we require that oracle responds with the same
challenge if sample is queried with the same message multiple times. This is
implemented by the following module:

\begin{lstlisting}[mathescape]
module RandomOracle : Oracle = {
  global variable : h = (message $\mapsto$ challenge)

  proc init() = {
    h = empty map;
  }

  proc sample (m : message) : challenge = {
    if ($m \not\in \textbf{Domain}(h)$) {
      h[m] $<\$$ dchallenge; (* Sample random value in entry m *)
      }
    return h[m];
    }
  }.
\end{lstlisting}

\subsection{Non-interactive $\Sigma$-Protocol}
\label{subsec:sigma:fiat:protocol}
We can define the non-interactive version of the protocol as the following procedure:
\begin{lstlisting}
module FiatShamir(S : SProtocol, O : Oracle) = {
  proc main(h : statement, w : witness) : transcript = {
    O.init();
    a = S.init(h, w);
    e = O.sample(a);
    z = S.response(h, w, a, e);

    return (a, e, z);
  }
}.
\end{lstlisting}

Here, a non-interactive version of a $\Sigma$-Protocol is a procedure producing
a transcript by first initialising the oracle and then sampling a challenge from it.

\paragraph{Security}
To prove security of the Fiat-Shamir transformation we need to use the security
definition of a zero-knowledge protocol.

\begin{lemma}
  If the underlying $\Sigma$-Protocol S is secure and the random Oracle O is
  lossless then the Fiat-Shamir transformation is correct.
\end{lemma}
\begin{proof}
  By comparing the completeness from the underling $\Sigma$-protocol to the
  transformation we see that the only different is that underlying protocol
  waits for the verifier to sample a challenge for him. Since a honest verifier
  will never fail to send a challenge (\ie\ he is lossless) and it will always
  be uniformly chosen the two procedures are equivalent.
\end{proof}

\begin{lemma}
  If the underlying $\Sigma$-Protocol S is secure and the random Oracle O is
  lossless then the Fiat-Shamir transformation is zero-knowledge
\end{lemma}
\begin{proof}
  To prove zero-knowledge in the random oracle model we must define a simulator
  producing indistinguishable output from the real procedure. Here, the
  simulator is allowed to dictate the random choices made by the oracle in the real
  protocol.

  From the correctness proof we know that the random oracle acts as a honest
  verifier. Therefore the SHVZK simulator for S proves zero-knowledge for the transformation.
\end{proof}

Soundness, however, cannot be proven by the definition of special soundness from
$\Sigma$-Protocols, since the Prover has gained more possibilities of cheating
the verifier. We could prove some arbitrary bounds, but to get a meaningful
proof of soundness for the Fiat-Shamir transformation we would need the
forking lemma, which depends on rewinding and is still an open research topic to formalise within \easycrypt\ \cite{ec_intro}.

\section{Concrete instantiation: Schnorr protocol}
\label{sec:schnorr}
To show the workability of our formalisation, we show that it can be
used to instantiate Schnorr's protocol.
Schnorr's protocol is run between a Prover P and a
Verifier V. Both parties, before running the protocol, agree on a group
$(\mathbb{G}, q, g)$, where $q$ is the order of $\mathbb{G}$ and $g$ is the
generator for the group.
Schnorr's protocol is a $\Sigma$-Protocol for proving knowledge of a discrete
logarithm. Formally it is a $\Sigma$-Protocol for the relation R h w $= (h = g^{w})$

When P wants to prove knowledge of w to V he starts by
constructing a message $a = g^{r}$ for some random value $r$. The Verifier will
generate a random challenge, $e$, which is a bit-string of some arbitrary length.
Based on this challenge P then constructs a response $z = r + e \cdot w$ and sends
it to V.
To verify the transcript $(a,e,z)$ V then checks if $g^{z} = a \cdot h^{e}$.

From this general description, it is clear that this protocol fits within our
formalisation of $\Sigma$-Protocol procedures. We then define the appropriate
types and instantiate the protocol using our $\Sigma$-Protocol formalisation,
which can be seen in listing \ref{lst:sigma:schnorr}.

\begin{lstlisting}[float,mathescape,label=lst:sigma:schnorr,caption=Schnorr instantiation]
clone export SigmaProtocols as Sigma with
  type statement <- group, (* group element *)
  type witness   <- F.t,   (* Finite field element, like $\mathbb{Z}_{q}$ *)
  type message   <- group,
  type challenge <- F.t,
  type response  <- F.t,

  op R h w =  ($h = g^w$)
  op dchallenge = FDistr.dt (* Distribution of messages *)
  proof *.
  realize dchallenge_llfuni. by split; [apply FDistr.dt_ll | apply FDistr.dt_funi].

module Schnorr : SProtocol = {
  var r : F.t
  proc init(h : statement, w : witness) : message = {
    r <$\$$ FDistr.dt;
    return $g^r$;
  }

  proc response(h : statement, w : witness, a : message, e : challenge) : response = {
    return $r + e \cdot w$;
  }

  proc verify(h : statement, a : message, e : challenge, z : response) : bool = {
    return $(g^z = a \cdot (h ^e))$;
  }
}
\end{lstlisting}

Here we first discharge the assumption that the challenge distribution is lossless, uniform
and fully distributed by using the \easycrypt\ theories about distributions and
cyclic groups.

To prove that the protocol is secure, we show that it satisfies the security
definitions from section \ref{sec:sigma:def}.

\begin{lemma}[Schnorr correctness]
  R h w $\implies \Pr{\texttt{Completeness(Schnorr)}.main(h,w)} = 1$
\end{lemma}
\begin{proof}
  To prove correctness we need to prove two things:
  \begin{enumerate}
    \item That the procedure always terminates
    \item That it always outputs true
  \end{enumerate}
  \textbf{1)} Since all procedures bar the random sampling in $\texttt{Schnorr}$ are arithmetic
  operations they can never fail. The random sampling have been proven to be
  lossless. Therefore the procedures always terminates.

  \noindent\textbf{2)} After running all sub-procedures of the correctness game
  the output of the procedure is
  \begin{align*}
         &g^{r + e \cdot w} = g^{r} \cdot h^{e} \\
    \iff &g^{r + e \cdot w} = g^{r} \cdot g^{w^{e}} && \text{R h w = ($h = g^{w}$)} \\
    \iff &g^{r} \cdot g^{e \cdot w} = g^{r} \cdot g^{w \cdot {e}} \\
  \end{align*}

  Which is easily proven by \easycrypt\ automation tools for algebraic operations.
\end{proof}

\begin{lemma}[Schnorr 2-special soundness]
  \begin{align*}
    &e \neq e' \implies \\
    &\Pr{\texttt{verify}(a, e, z)} = 1 \implies \\
    &\Pr{\texttt{verify}(a, e', z')} = 1 \implies \\
    &\Pr{\texttt{Soundness(Schnorr)}(a, [e; e'], [z; z'])} = 1 \\
  \end{align*}
\end{lemma}
\begin{proof}
  We start by defining the witness extractor for Schnorr's protocol:
\begin{lstlisting}
proc witness_extractor(h : statement, m : message, e : challenge list, z : response list) : witness= {
  return (z[0] - z[1]) / (e[0] - e[1]);
}
\end{lstlisting}
  To prove that the soundness game succeeds we need the following
  \begin{enumerate}
    \item Both transcripts are accepting
    \item The witness extractor produces a valid witness for the relation R
  \end{enumerate}

  \textbf{1)} By stepping though the while loop of the soundness game we can
  show that all transcripts must be accepting by our assumptions.

  \noindent \textbf{2)} Running all procedures of the soundness game we are left
  with showing:
  \begin{equation*}
    \text{R h } ((z - z') / (e - e'))
  \end{equation*}
  Which follows by unfolding the definition of $z$ and $z'$ and using the
  automation tools of \easycrypt\  to solve algebraic operations.
\end{proof}

\begin{lemma}[Schnorr SHVZK]
  \[
    equiv[\texttt{SHVZK(Schnorr)}.ideal \sim \Pr{\texttt{SHVZK(Schnorr)}.real} :\; \indis{h,e} \land \text{R h w}^{real} \implies \indis{res}]
  \]
\end{lemma}
\begin{proof}
  We start by defining the simulator for Schnorr's protocol:
\begin{lstlisting}[mathescape]
proc simulator(h : statement, e : challenge) = {
  z <$\$$ FDistr.dt;
  a = $g^z * h ^ (-e)$;
  return (a, z);
}
\end{lstlisting}
  To prove SHVZK be must the prove output indistinguishability of the following procedures:
  \begin{figure}[ht]
    \centering
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc real(h, w, e) = {
   r <$\$$ FDistr.dt;
   a = $g^r$;
   z = $r + e \cdot w$;
   return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc ideal(h, e) = {
  z <$\$$ FDistr.dt;
  a = $g^z * h^{(-e)}$;
  return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
  \end{figure}
  To prove this we use \easycrypt\ coupling functionality to show that $r^{real} \equiv z^{ideal} - e \cdot w^{real}$ and that $z^{ideal} \equiv r^{real} + e \cdot w^{real}$.
  This is easily prove, since the distribution is full and uniform, and the group is closed under addition and multiplication. All these facts follow directly from the cyclic group theory in \easycrypt.
  We then use this to show output indistinguishability:
  \begin{align*}
    (a^{real}, e, z^{real}) &= (g^{r^{real}}, e, r^{real} + e \cdot w^{real}) \\
                          &\sim (g^{r^{real}}, e, z^{ideal} - e \cdot w^{real} + e \cdot w^{real}) \\
                          &= (g^{z^{ideal} - e \cdot w^{real}}, e, z^{ideal}) \\
                          &= (g^{z^{ideal}} \cdot g^{w^{real} - e}, e, z^{ideal}) \\
                          &= (g^{z^{ideal}} \cdot h^{(-e)}, e, z^{ideal}) \\
                          &= (a^{ideal}, e, z^{ideal}) \\
  \end{align*}
  Which can easily be proven by \easycrypt's automation tools.
\end{proof}
\todo{The proofs have been relatively easy thanks to the strong support for algebraic groups in EC}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
