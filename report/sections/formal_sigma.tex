\chapter{Formalising Sigma-Protocols}
\label{ch:formal_sigma}
This section will aim to formalise $\Sigma$-protocols according to the
definitions set out in section \ref{sec:background:sigma_protocols}, with a
sufficiently general set-up to allows easy instantiation of arbitrary concrete
protocols.

Moreover, we show that any protocol that adheres to this abstract specification
of a $\Sigma$-Protocol can be compounded together whilst still being secure.

We then end this section by formalising the Fiat-Shamir heuristic, which allows
us to make any $\Sigma$-Protocol non-interactive in the random oracle model.
This also implies that $\Sigma$-Protocol are Zero-knowledge in the random oracle
model, since Special honest verifier zero-knowledge ensure Zero-knowledge in the
presence of an honest verifier. If we remove the verifier then he can always be
assumed honest.

\section{Defining $\Sigma$-Protocols}
\label{sec:sigma:def}
We start by defining the types for any arbitrary $\Sigma$-Protocol:
\begin{align*}
  \textbf{type: } &\text{statement} \\
                  &\text{witness} \\
                  &\text{message} \\
                  &\text{challenge} \\
                  &\text{response} \\
\end{align*}
These types corresponds to the types from Figure \ref{fig:proto_sigma}.

Furthermore, we fix a relation
$R : (\text{input} \times \text{witness}) \rightarrow \{0,1\}$ along with
a distribution over challenges. This distribution is used to model a honest
verifier which will always generate a random challenge. Since distribution are
probabilistic programs within \easycrypt\ we require that sampling from the
distribution is always successful. This is referred to as the distribution being lossless.

We then define the $\Sigma$-protocol itself to be a series of probabilistic procedures:
\begin{lstlisting}[label=lst:sigma_procedures,caption= Abstract procedures of $\Sigma$-Protocols]
module type SProtocol = {
  proc init(h : statement, w : witness) : message
  proc response(h : statement, w : witness,
                m : message, e : challenge) : response
  proc verify(h : statement, m : message, e : challenge, z : response) : bool
  proc witness_extractor(h : statement, m : message, e : challenge list, z : response list) : witness option
  proc simulator(h : statement, e : challenge) : message * response
}
\end{lstlisting}

Here all procedures are modelled into the same module. This allows the
Verifier procedure to access the global state of the Prover. This could lead to
invalid proofs of security. It is therefore important to not implement a
\texttt{verify} procedure which access global state of the SProtocol module.
This could have been alleviated by splitting the SProtocol module into multiple
different modules with only the appropriate procedures inside. This would remove
any potential for human error when defining a $\Sigma$-Protocol, but it makes it
more bothersome to instantiate a $\Sigma$-Protocol in \easycrypt\ . Ultimately,
we decided on having everything defined within the same module.

\todo{Here gen is \dots}

\begin{lstlisting}[float, label=lst:sigma_completeness,caption=Completeness game for $\Sigma$-Protocols]
module Completeness(S : SigmaProtocol) = {
  proc main(h : input, w : witness) : bool = {
      var a, e, z;
      a = S.init(h,w);
      e <$ dchallenge;
      z = S.response(h, a, e);
      v = S.verify(h, a, e, z);
      return v;
  }
}.
\end{lstlisting}

An instantiation of a $\Sigma$-Protocol is then an implementation of the
procedures in Listing \ref{lst:sigma_completeness}.

We then model security as a series of games:

\begin{definition}[Completeness]
\label{def:sigma:completeness}
  We say that a $\Sigma$-protocol, S, is complete, if the probabilistic procedure in
  \ref{lst:sigma_completeness} outputs 1 with probability 1, i.e.
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall h \; w, \text{R } h \; w \implies Pr[\text{Completeness(S).main}(h,w) = true] = 1.
  \end{equation}
\end{definition}

One problem with definition $\ref{def:sigma:completeness}$ is that
quantification over challenges is implicitly done when sampling from the random
distribution of challenges. This mean that reasoning about the challenges are
done within the probabilistic Hoare logic, and not the ambient logic. If we at
some later point need the completeness property to hold for a specific
challenge, then that is not true by this definition of completeness, since
the ambient logic does not quantify over the challenges. To alleviate this
problem we introduce a alternative definition of completeness:

\begin{definition}[Alternative Completeness]
\label{def:sigma:alt_completeness}
  We say that a $\Sigma$-protocol, S, is complete if:
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall h \; w \; e, \text{R } h \; w \implies Pr[\text{Completeness(S).special}(h,w,e) = true] = 1.
  \end{equation}
  Where the procedure ``Completeness(S).special'' is defined as
  \lstinputlisting[linerange={40-48}]{../code/SigmaProtocols.eca}
\end{definition}

Now, since the alternative procedure no longer samples from a random
distribution it is not possible to prove equivalence between the two procedure,
but to show that this alternative definition is still captures what is means for
a protocol to be complete we have the following lemma:

\begin{lemma}
Given that definition \ref{def:sigma:alt_completeness} then it must hold that
definition \ref{def:sigma:completeness} holds, given the same public input and witness.

This can be stated in \easycrypt as:
\begin{lstlisting}[mathescape]
lemma special_implies_main (S <: SProtocol) h' w':
  ($\forall$ h' w' e',
    phoare[special : (h = h' /\ w = w' /\ e = e') ==> res] = 1%r)
  =>
  phoare[Completeness(S).main : (h = h' /\ w = w') ==> res] = 1%r.
\end{lstlisting}
\end{lemma}

\begin{proof}
First we start by defining an intermediate game:
\begin{lstlisting}
proc intermediate(h : input, w : witness) : bool = {
   e <$ dchallenge;
   v = special(h, w, e);
   return v;
}
\end{lstlisting}

From this it is easy to prove equivalence between the two procedures
``intermediate'' and ``main'' by simply inlinining the procudures and moving
the sampling to the first line of each program. This will make the two programs
equivalent.

Now, we can prove the lemma by instead proving:
\begin{lstlisting}
lemma special_implies_main (S <: SProtocol) h' w':
  (forall h' w' e', phoare[special : (h = h' /\ w = w' /\ e = e') ==> res] = 1%r) =>
  phoare[intermediate : (h = h' /\ w = w') ==> res] = 1%r.
\end{lstlisting}

The proof then proceeds by first sampling $e$ and then proving the following
probabilistic Hoare triplet: $true \vdash \{\exists e', e = e'\}
\text{special(h,w,e)} \{true\}$. Now, we can move the existential
from the pre-condition into the context:
\[
  e' \vdash \{e = e'\} \text{special(h,w,e)} \{true\}
\]

Which then is proven by the hypothesis of the ``special'' procedure being complete.

\todo{variable declarations have been omitted}
\end{proof}


\begin{definition}[Special Soundness]
\label{def:sigma:soundness}
Given a $\Sigma$-Protocol $S$ for some relation $R$ with public input $h$
and two any accepting transcripts $(a,e,z)$ and $(a,e',z')$
where both transcripts have the same initial message, $a$ and $e \neq e'$.

\begin{lstlisting}[float, label=lst:sigma-soundness, caption= 2-special soundness game]
module SpecialSoundness(S : SProtocol) = {
  proc main(h : statement, m : message, c c' : challenge, z z' : response) : bool = {
    var w, v, v';

    v  = S.verify(h, m, c, z);
    v' = S.verify(h, m, c', z');

    w = S.witness_extractor(h, m, c, c', z, z');

    return (c <> c' /\ (R h w) /\ v /\ v');
  }
}.
\end{lstlisting}

We then define special soundness as winning the game
defined in Listing \ref{lst:sigma-soundness} with probability 1.

\end{definition}

\begin{definition}[Special Honest Verifier Zero-Knowledge]
\label{def:sigma:shvzk}
Given a $\Sigma$-Protocol $S$ for some relation $R$ with public input $h$ and
witness $w$, then $S$ is said to be Special Honest Verifier Zero-knowledge
(SHVZK), if there exists a simulator that given input $h$ outputs a
transcript $(a,e,z)$, which is indistinguishable from the transcript observed by
running $S$ on input $h, w$.

\todo{define indistinguishability}
\todo{Statistical and computation indistinguishability in EC?}

\end{definition}

\begin{definition}
\label{def:sigma-protocol}
  S is said to be a $\Sigma$-Protocol if it implements the procedures in figure
  \ref{lst:sigma_procedures} and satisfy the definitions of completeness,
  special soundness, and special honest verifier zero-knowledge.
\end{definition}

\todo{Argue that games corresponds to original definitions}

\todo{To prove composition we assume to following relations to be true \dots and
this only hold if both inputs are in the domain of R.}

\section{Composition Protocols}
\label{sec:sigma_comp}
Given our formalisation of $\Sigma$-Protocols we now show that our formalisation
composes is various ways. More specially it is possible to prove knowledge of
relations compounded by the logical operators ``AND'' and ``OR''.
The benefit of this is...

\subsection{AND}
\label{subsec:sigma_AND}
\todo{Needed to change definition of games to relate challenges}

In this section we prove the AND construction to be a $\Sigma$-protocol by
definition \ref{def:sigma-protocol}.

\todo{Write protocol as diagram?}
\todo{Write procedure definitions?}

\begin{lemma}[AND completeness]
  \begin{align*}
    \text{R } h \, w \land
    \Pr{Completeness.main(S_{1})} = 1 \land \Pr{Completeness.main(S_{2})} = 1 \\
    \implies \Pr{Completeness.main(AND(S_{1}, S_{2}))} = 1
  \end{align*}
  % If the completeness definition (\ref{def:sigma:completeness}) is instantiated
  % with the AND protocol, then it will succeed with probability 1, if $S_{1}$ and $S_{2}$
  \todo{Missing parameters and quantification}
\end{lemma}
\begin{proof}
  The proof proceeds by game-hopping to:
  \begin{lstlisting}[mathescape]
  proc intermediate(h : input, w : witness) = {
    $(h_{1}, h_{2}) = h$;
    $(w_{1}, w_{2}) = w$;
    $v_{1} = Completeness(S_1).main(h_1, w_{1})$
    $v_{2} = Completeness(S_2).main(h_2, w_{2})$

    return $v_{1} \land v_{2}$
  }
  \end{lstlisting}

  This intermediate game will return true with probability 1 since both
  $v_{1}$ and $v_{2}$ will always return true by our assumption of completeness
  for $S_{1}$ and $S_{2}$.
\end{proof}

\begin{lemma}[AND special soundness]
  \begin{align*}
    &R (h_{1}, h_{2}) (w_{1}, w_{2}) \\
    \land &\Pr{S_{1}.verify(h_{1}, w_{1}, e, z)} = 1 \\
    \land &\Pr{S_{2}.verify(h_{2}, w_{2}, e', z')} = 1 \\
    &\implies \Pr{SpecialSoundness(AND(S_{1}, S_{2})).main} = 1
  \end{align*}
\end{lemma}


\subsection{OR}
\label{subsec:sigma_OR}
\todo{Needed to change relation}

\subsection{Fiat-Shamir Transformation}
\label{subsec:fiat-shamir}
The Fiat-Shamir transformation is a technique for converting $\Sigma$-protocols
into zero-knowledge protocols. $\Sigma$-Protocols almost satisfy the definition
of zero-knowledge, the only problem is that $\Sigma$-Protocols only guarantee
zero-knowledge given the verifier is honest. This is stated by the Special
Honest Verifier Zero-Knowledge property. However, if we can alter the protocol
to force the verifier to always be honest, then the protocol, by definition,
must be zero-knowledge.
The Fiat-Shamir transformation achieves this by removing the verifier from the
protocol and thus making it non-interactive. The verifier is then replaced by an
random oracle, which generates a random challenge based on the first message of
the prover, thus it works exactly like an honest verifier in the interactive
protocol. However, since the random oracle is a sub-procedure of the prover he
is allowed to make polynomially many call to the oracle in the hopes of getting
a good challenge.

\subsubsection{Oracles}
\label{subsec:sigma:fiat:oracle}


To formalise this transformation we first formalise what we expect a random
oracle to do...

\subsubsection{Non-interactive $\Sigma$-Protocol}
\label{subsec:sigma:fiat:protocol}

We can define the non-interactive version of the protocol as:

\subsubsection{Security}
\label{subsec:sigma:fiat:security}

And we can then prove completeness ans zero-knowledge of the protocol by...

Soundness, however, cannot be proven by the definition of special soundness from
$\Sigma$-Protocols, since the Prover has gained more possibilities of cheating
the verifier. We could prove some arbitrary bounds, but to get a meaningful
proof of soundness for the Fiat-Shamir transformation we would need the
rewinding lemma, which is yet unclear how to do in proof assistants
\todo{reference proving/disproving this}.

\subsection{Concrete Example: Schnorr protocol}
\label{subsec:schnorr}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
