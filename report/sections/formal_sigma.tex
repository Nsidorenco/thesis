\chapter{Formalising $\Sigma$-Protocols}
\label{ch:formal_sigma}
\todo{Aim to port results from Isabelle to EC}
In this chapter we formalise $\Sigma$-Protocols a long with different
constructions based on $\Sigma$-Protocol. Our formalisation is driven by the
definitions given by \cite{on-sigma-protocols} and already existing
formalisation of $\Sigma$-Protocols in the \easycrypt\ source code \cite{ec_source}. Our work
improve on this work by providing more generalised definition, namely
$s$-special soundness instead of the usual $2$-special soundness definition
given. Additionally, we also provide an alternative definition of completeness.
Moreover, we \todo{word} the work of compound $\Sigma$-Protocols by
\citet{cryptoeprint:2019:1185} by formalising their results in \easycrypt.
We then introduce the Fiat-Shamir transformation and how it applies to our
formalisation.
Last, we show that our formalisation can be used to prove the security of
Schnorr's $\Sigma$-Protocol.

Moreover, we show that any protocol that adheres to this abstract specification
of a $\Sigma$-Protocol can be compounded together whilst still being secure.

We then end this section by formalising the Fiat-Shamir transformation, which allows
us to make any $\Sigma$-Protocol non-interactive in the random oracle model.
This also implies that $\Sigma$-Protocol are Zero-knowledge in the random oracle
model, since Special honest verifier zero-knowledge ensure zero-knowledge in the
presence of an honest verifier. If we remove the verifier then he can always be
assumed honest.

\section{Defining $\Sigma$-Protocols}
\label{sec:sigma:def}
We start by defining the types for any arbitrary $\Sigma$-Protocol:
\begin{align*}
  \textbf{type: } &\text{statement} \\
                  &\text{witness} \\
                  &\text{message} \\
                  &\text{challenge} \\
                  &\text{response} \\
\end{align*}
These types corresponds to the types from Figure \ref{fig:proto_sigma}.

Furthermore, we define the relation for which the protocol operates on as a
binary function mapping a statement and witness to true/false
$R : (\text{statement} \times \text{witness}) \rightarrow \{0,1\}$.
Moreover, we fix a lossless and full/uniform distribution over challenges. This
distribution is used to model a honest verifier which will always generate a random challenge.

We then define the $\Sigma$-protocol itself to be a series of probabilistic procedures:
\begin{lstlisting}[label=lst:sigma_procedures,caption= Abstract procedures of $\Sigma$-Protocols]
module type SProtocol = {
  proc init(h : statement, w : witness) : message
  proc response(h : statement, w : witness,
                m : message, e : challenge) : response
  proc verify(h : statement, m : message, e : challenge, z : response) : bool
  proc witness_extractor(h : statement, m : message, e : challenge list, z : response list) : witness option
  proc simulator(h : statement, e : challenge) : message * response
}
\end{lstlisting}

Here all procedures are defined in the same module. This allows the
Verifier procedure to access the global state of the prover. This could lead to
invalid proofs of security. It is paramount to implement the
\texttt{verify} procedure such that it never accesses the global state of the SProtocol module.
This could have been alleviated by splitting the SProtocol module into multiple
different modules with only the appropriate procedures inside. This would remove
any potential for human error when defining a $\Sigma$-Protocol, but it is
easier to quantify over one module containing all relevant procedures than
quantifying over a prover and a verifier module and then reasoning about the two
modules being part of the same $\Sigma$-Protocol.
Ultimately, we decided on having everything defined within the same module.

\todo{Here gen is \dots}

\begin{lstlisting}[float, label=lst:sigma_completeness,caption=Completeness game for $\Sigma$-Protocols]
module Completeness(S : SigmaProtocol) = {
  proc main(h : input, w : witness) : bool = {
      var a, e, z;
      a = S.init(h,w);
      e <$ dchallenge;
      z = S.response(h, a, e);
      v = S.verify(h, a, e, z);
      return v;
  }
}.
\end{lstlisting}

An instantiation of a $\Sigma$-Protocol is then an implementation of the
procedures in Listing \ref{lst:sigma_completeness}.

We then model security as a series of games:

\begin{definition}[Completeness]
\label{def:sigma:completeness}
  We say that a $\Sigma$-protocol, S, is complete, if the probabilistic procedure in
  \ref{lst:sigma_completeness} outputs 1 with probability 1, \ie
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall h \; w, \text{R } h \; w \implies \Pr{ \text{Completeness(S).main}(h,w) = true } = 1.
  \end{equation}
\end{definition}

One problem with definition $\ref{def:sigma:completeness}$ is that
quantification over challenges is implicitly done when sampling from the random
distribution of challenges. This mean that reasoning about the challenges are
done within the probabilistic Hoare logic, and not the ambient logic. If we at
some later point need the completeness property to hold for a specific
challenge, then that is not true by this definition of completeness, since
the ambient logic does not quantify over the challenges. To alleviate this
problem we introduce a alternative definition of completeness:

\begin{definition}[Alternative Completeness]
\label{def:sigma:alt_completeness}
  We say that a $\Sigma$-protocol, S, is complete if:
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall h \; w \; e, \text{R } h \; w \implies \Pr{\text{Completeness(S).special}(h,w,e) = true} = 1.
  \end{equation}
  Where the procedure ``Completeness(S).special'' is defined as
  \lstinputlisting[linerange={40-48}]{../code/SigmaProtocols.eca}
\end{definition}

Now, since the alternative procedure no longer samples from a random
distribution it is not possible to prove equivalence between the two procedure,
but to show that this alternative definition is still captures what is means for
a protocol to be complete we have the following lemma:

\begin{lemma}
  \label{lem:sigma:alt:completeness}
\begin{equation*}
  \Pr{\texttt{special} : true \implies res} = 1 \implies
  \Pr{\texttt{Completeness(S).main} : true \implies res} = 1.
\end{equation*}
\end{lemma}

\begin{proof}
First we start by defining an intermediate game:
\begin{lstlisting}
proc intermediate(h : input, w : witness) : bool = {
   e <$ dchallenge;
   v = special(h, w, e);
   return v;
}
\end{lstlisting}

From this it is easy to prove equivalence between the two procedures
``intermediate'' and ``main'' by simply inlinining the procudures and moving
the sampling to the first line of each program. This will make the two programs
equivalent.

Now, we can prove the lemma by instead proving:
\begin{equation*}
  \Pr{\texttt{special} : true \implies res} = 1 \implies
  \Pr{\texttt{intermediate} : true \implies res} = 1.
\end{equation*}

The proof then proceeds by first sampling $e$ and then proving the following
probabilistic Hoare triplet: $true \vdash \{\exists e', e = e'\}
\text{special(h,w,e)} \{true\}$. Now, we can move the existential
from the pre-condition into the context:
\[
  e' \vdash \{e = e'\} \text{special(h,w,e)} \{true\}
\]

Which then is proven by the hypothesis of the ``special'' procedure being complete.
\end{proof}


\begin{definition}[Special Soundness]
\label{def:sigma:soundness}
  A $\Sigma$-Protocol S has $s$-special soundness if given a list of challenges
  $c$ and a list of responses $z$ with $\text{size } c = \text{size } z = s$, it
  holds that:
\begin{align*}
    & \forall (i \neq j). c[i] \neq c[j] \\
    \land &\forall (i \in [1 \dots s]). \Pr{S.verify(h, a, c[i], z[i])} = 1 \\
    &\implies \Pr{SpecialSoundness(\texttt{ANDProtocol}(S)).main(h, a, c, z)} = 1
\end{align*}

With \texttt{SpecialSoundness} defined as:

\begin{lstlisting}[float, label=lst:sigma-soundness, caption= 2-special soundness game]
module SpecialSoundness(S : SProtocol) = {
  proc main(h : statement, a : message, c : challenge list, z : response list) : bool = {
    w = S.witness_extractor(h, m, c, z);

    valid = true;

    while (c <> []) {
      c' = c[0];
      z' = z[0];
      valid = valid /\ S.verify(h, m, c', z');
      c = behead c;
      z = behead z;
    }

    return valid /\ R h (oget w);
}.
\end{lstlisting}
\end{definition}

\begin{definition}[Special Honest Verifier Zero-Knowledge]
  To define SHVZK we start by defining a module SHVZK containing two procedures:
\label{def:sigma:shvzk}
  \begin{figure}[ht]
    \centering
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc real(h, w, e) = {
   a = init(h,w);
   z = respose(h,w,e,a);
   return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc ideal(h, e) = {
  (a, z) = simulator(h, e);
  return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
    \caption{SHVZK module}
  \end{figure}
  We then say a $\Sigma$-Protocol S is special honest verifier zero-knowledge
  if:
  \[
    equiv[\texttt{SHVZK}.real \sim \texttt{SHVZK}.ideal :\; \indis{h, e} \land \text{R
    h w}^{real} \implies \indis{res}]
  \]
\end{definition}

\begin{definition}
\label{def:sigma-protocol}
  S is said to be a $\Sigma$-Protocol if it implements the procedures in figure
  \ref{lst:sigma_procedures} and satisfy the definitions of completeness,
  special soundness, and special honest verifier zero-knowledge.
\end{definition}

\todo{Argue that games corresponds to original definitions}

\todo{SHVZK only captures perfect indis. Unclear how to do with equiv?}

\section{Compound Protocols}
\label{sec:sigma_comp}
Given our formalisation of $\Sigma$-Protocols we now show that our formalisation
composes is various ways. More specially we show that it is possible to prove knowledge of
relations compounded by the logical operators ``AND'' and ``OR'' by compounding
$\Sigma$-Protocols together.
The benefit of this is...

Formalisations of compound $\Sigma$-Protocols already exists in other proof
assistants \cite{cryptoeprint:2019:1185,certicrypt_sigma}, which we will also
use as a basis for our \easycrypt\ formalisation. By drawing on previous work we
aim to make a formalisation that is workable and succinct within reason of what
\easycrypt\ allows us to do. Moreover, by recreating formalisations within new
proof assistant we can gain valuable insight into how \easycrypt\ compares to
other proof assistant whilst reflecting on how to improve previous work.

\paragraph{Higher order instances of theories} \todo{Unsure how?}

\subsection{AND}
\label{subsec:sigma_AND}
\todo{Based on description from \cite{on-sigma-protocols}}
\todo{Not entirely correct. Need $h \in domain R$ to discharge axioms}
Given two $\Sigma$-Protocols, $S_{1}$ with relation $R_{1}(h_{1},w_{1})$ and
$S_{2}$ with relation $R_{2}(h_{2},w_{2})$ we define the AND construction to be a
$\Sigma$-Protocol proving knowledge of the relation
$R((h_{1}, h_{2}), (w_{1}, w_{2})) = R_{1}(h_{1}, w_{1}) \land R_{2}(h_{2}, w_{2})$.

The construction of AND protocol is a $\Sigma$-Protocol running both
$S_{1}$ and $S_{2}$ as sub-procedures. To formalise this we start by declaring
the AND construction as an instantiation of a $\Sigma$-Protocol. To do this we
first need to define the types of AND construction. But before we
can define the types we need to know the types of the
underlying $\Sigma$-Protocols $S_{1}$ and $S_{2}$. To denote the types of
$S_{i}$ we use the notation: $\text{type}_i$
\begin{align*}
  \textbf{Type: } &\text{statement = statement}_{1} \times \text{statement}_{2} \\
                  &\text{witness = witness}_{1} \times \text{witness}_{2} \\
                  &\text{message = message}_{1} \times \text{message}_{2} \\
                  &\text{challenge = challenge}_{1} = \text{challenge}_{2} \\
                  &\text{response = response}_{1} \times \text{response}_{2} \\
\end{align*}

We then define the AND construction as a module parametrised by
$\Sigma$-Protocols satisfying the type signatures of $S_{1}$ and $S_{2}$, which
can be seen in Listing \ref{lst:and-procedures}. This might seem restrictive,
since the AND construction can now only be made from $\Sigma$-Protocol with the
specific type signature of $S_{1}$ and $S_{2}$, but recall that the entire AND
construction is quantified over the types given in the type declaration. This
means that the types of $S_{1}$ and $S_{2}$ can be fixed to any arbitrary types
and therefore can express any $\Sigma$-Protocol.
But, if $S_{1}$ and $S_{2}$ are any arbitrary $\Sigma$-Protocols, then why are
the AND construction parametrised by $\Sigma$-Protocols satisfying the type
signatures of $S_{1}$ and $S_{2}$ rather than just parametrising the AND
construction be any two $\Sigma$-protocols? Ideally, the AND
construction would be formalised in this way, but due to how \easycrypt\ handles
types of modules we
need to declare the types of the AND construction and ensure that the procedures
are typeable. The only way of ensuring this is by fixing the types of the
underlying $\Sigma$-Protocols before instantiation the AND construction as a $\Sigma$-Protocol.

\todo{Explicitly mention axioms}

\begin{lstlisting}[float,label=lst:and-procedures,caption=AND construction]
module ANDProtocol (P1 : S1, P2 : S2) = {
  proc init(h : statement, w : witness) = {
    (h1, h2) = h;
    (w1, w2) = w;

    a1 = P1.init(h1, w1);
    a2 = P2.init(h2, w2);
    return (a1, a2);
  }

  proc response(h : statement, w : witness, m : message, e : challenge) : response = {
    (m1, m2) = m;
    (h1, h2) = h;
    (w1, w2) = w;

    z1 = P1.response(h1, w1, m1, e);
    z2 = P2.response(h2, w2, m2, e);
    return (z1, z2);
  }

  proc verify(h : statement, m : message, e : challenge, z : response) : bool = {
    (h1, h2) = h;
    (m1, m2) = m;
    (z1, z2) = z;

    v = P1.verify(h1, m1, e, z1);
    v' = P2.verify(h2, m2, e, z2);

    return (v /\ v');

  }
\end{lstlisting}

\paragraph{Security}
Given the AND constructions instantiation of a $\Sigma$-Protocols we simply need
to prove the security definitions given in section \ref{sec:sigma:def} with
regards to the module \texttt{ANDProtocol}

\begin{lemma}[AND Completeness]
  Assume $\Sigma$-Protocols $P_{1}$ and $P_{2}$ are complete then
  Module $\texttt{ANDProtocol}(P_1, P_2)$ satisfy completeness definition \ref{def:sigma:completeness}
\end{lemma}
\begin{proof}
  By inlining the procedures of $\texttt{ANDProtocol}(P_{1}, P_{2})$ in
  \texttt{Completeness(ANDProtocol).special} we see that it is equivalent to:
  \texttt{Completeness($P_{1}$).special; Completeness($P_{2}$).special}. Which is true by our
  assumption of $P_{1}$ and $P_{2}$ being complete.
  We need to use the \texttt{special} definition of the completeness game here,
  since the challenge $e$ is given by a Verifier running the AND construction.
  And the sub-protocols are, therefore, not allowed to sample their own
  challenges and need to use the challenge from the AND construction.

  Then by lemma \ref{lem:sigma:alt:completeness} we get that
  $\Pr{\texttt{Completeness(AND($P_{1}, P_{2}$)}.main} = 1$
\end{proof}

\todo{Write protocol as diagram?}

\begin{lemma}[AND special soundness]
  Given secure $\Sigma$-Protocols P1 and P2
  the AND construction AND(P1, P2) satisfy definition \ref{def:sigma:soundness}
\end{lemma}
\begin{proof}
  Since a transcript of AND(P1, P2) is the transcripts of running P1 and P2
  combined simulating a transcript for AND(P1, P2) is equivalent to simulating
  transcripts for P1 and P2 and combining them. By SHVZK of P1 and P2 this will
  always succeed.
\end{proof}

\begin{lemma}[AND SHVZK]
  Given secure $\Sigma$-Protocols $P_{1}$ and $P_{2}$ then AND(P1, P2) satisfy
  definition \ref{def:sigma:shvzk}.
\end{lemma}
\begin{proof}
  We start by showing:
  \begin{align}
    \label{eq:sigma:or:verify}
    &verify((h1, h2), (a1, a2), s, (e1, z1, e2, z2) \iff  \\
    &P1.verify(h1, a1, e1, z1) \land P2.verify(h2, a2, e2, z2)
  \end{align}

  Since the relation
  $R \; (h1, h2) \; (w1, w2) = R1 \; h1 \; w1 /land R2 \; h2 \; w2$ we need to
  produce valid witnesses for the protocol P1 and P2. Since both protocols have
  special soundness we can use equation \ref{eq:sigma:or:verify} to apply the
  special soundness property of both P1 and P2, which completes the proof.
\end{proof}

\subsection{OR}
\label{subsec:sigma_OR}
Here we use the definition of the OR construction by \cite{on-sigma-protocols},
which states that both sub-protocols must have the same witness type.

Given two $\Sigma$-Protocols, $S_{1}$ with relation $R_{1}(h_{1},w)$ and
$S_{2}$ with relation $R_{2}(h_{2},w)$ we define the AND construction to be a
$\Sigma$-Protocol proving knowledge of the relation
$R((h_{1}, h_{2}), w) = R_{1}(h_{1}, w) \lor R_{2}(h_{2}, w)$.

The main idea behind the OR construction, is that by the SHVZK it is possible to
construct accepting conversations for both $S_{1}$ and $S_{2}$ if the Prover is
allowed to choose what challenge he responds to. Obviously, if the Prover is
allowed to chose the challenge the protocol would not be secure. Therefore,
we limit the Prover such that he can choose the challenge for one sub-protocol,
but must run the other sub-protocol with a challenge influenced by the Verifier.
This is done by letting the Prover chose two challenges $e_{1}$ and $e_{2}$,
which the Verifier will only accept, if the $e_{1} \oplus e_{2} = s$ where $s$
is the challenge produced by the Verifier.
By producing accepting transcripts for both sub-protocols it must be true that
he knew the witness for at least one of the relations.

To formalise this we first need a way to express that the challenge type
supports XOR operations. To do this we add the following axioms, which will have
to be proven true before our formalisation can be applied.

\begin{gather}
  \textbf{op } (\oplus) \; c_{1} \; c_{2} : \text{challenge} \label{def:op:xor} \\
  \textbf{axiom xorK } x \; c : (x \oplus c) \oplus c = x \label{axiom:xorK} \\
  \textbf{axiom xorA } x \; y : (x \oplus y) = y \oplus x \label{axiom:xorA}
\end{gather}

\todo{The protocol then proceeds as ...}

We then define the OR construction as a $\Sigma$-Protocol like in section
\ref{subsec:sigma_AND}. The procedures can be seen in listing \ref{lst:sigma:or}.

\begin{lstlisting}[float, mathescape, label=lst:sigma:or,caption=OR construction]
proc init(h : statement, w : witness) = {
  (h1, h2) = h;

  if (R1 h1 w) {
    a1 = S1.init(h1, w);
    e2 <$\$$ dchallenge;
    (a2, z2) = S2.simulator(h2, e2);
  } else {
    a2 = S2.init(h2, w);
    e1 <$\$$ dchallenge;
    (a1, z1) = S1.simulator(h1, e1);
  }
  return (a1, a2);
}

proc response(h : statement, w : witness, m : message, s : challenge) = {
  (m1, m2) = m;
  (h1, h2) = h;

  if (R1 h1 w) {
    e1 = s $\oplus$ e2;
    z1 = S1.response(h1, w, m1, e1);
  } else {
    e2 = s $\oplus$ e1;
    z2 = S2.response(h2, w, m2, e2);
  }
  return (e1, z1, e2, z2);
}

proc verify(h : statement, m : message, s : challenge, z : response) = {
  (h1, h2) = h;
  (m1, m2) = m;
  (e1, z1, e2, z2) = z;

  v = S1.verify(h1, m1, e1, z1);
  v' = S2.verify(h2, m2, e2, z2);

  return ((s = e1 $\oplus$ e2) /\ v /\ v');
}
\end{lstlisting}

\todo{Write protocol as diagram?}

\paragraph{Security}
Given the OR constructions instantiation of a $\Sigma$-Protocols we need
to prove the security definitions given in section \ref{sec:sigma:def} with
regards to the module \texttt{ORProtocol}

\begin{lemma}[OR Completeness]
  Assume $\Sigma$-Protocols $P_{1}$ and $P_{2}$ are complete and shvzk then
  $\texttt{ORProtocol}(P_1, P_2)$ satisfy completeness definition \ref{def:sigma:completeness}
\end{lemma}
\begin{proof}
  To prove completeness we branch depending on which relation holds. If R1 $h1$
  $w$ holds then all P1 procedures can be grouped together as the P1
  completeness game. We then need to prove that \texttt{S2.verify} output accept
  on the transcript generated by \texttt{S2.simulator} which is true by the
  assumption of SHVZK of P2.
  The proof when R2 $h2$ $w$ holds follows similarly.
\end{proof}

\begin{lemma}[OR SHVZK]
  Given $\Sigma$-Protocols $P_{1}$ and $P_{2}$ that satisfy SHVZK then:
  \[
    equiv[SHVZK(OR(P1, P2)).ideal \sim SHVZK(OR(P1, P2)).real]
  \]
  With the Pre and Post condition given by definition \ref{def:sigma:shvzk}.

  Where the simulator for the OR construction is given by

\begin{lstlisting}
proc simulator(h : statement, s : challenge) : message * response = {
  (h1, h2) = h;
  e2 <$ dchallenge;
  e1 = s ^^ c2;

  (a1, z1) = P1.simulator(h1, e1);
  (a2, z2) = P2.simulator(h2, e2);

  return ((a1, a2), (e1, z1, e2, z2));
}
\end{lstlisting}
\end{lemma}
\begin{proof}
  We again split the proof based on which relation holds.

  \noindent\textbf{case (R1 h1 w): } for this case we have to show the following.

  \noindent\textbf{1)} that $e1$ and $e2$ are indistinguishable. This follows
  trivially since we assume both procedures make the same random choices and
  since the order in which the challenges are sampled they must be equal.

  \noindent\textbf{2)} that the transcript $(a1, e1, z1)$ made by running P1 on
  input (h1,w) is indistinguishable from the transcript produced by
  \texttt{P1.simulator}(h, e1). The rest of the procedures is trivially
  equivalent since they call the same procedures with the same arguments.
  This follows from the SHVZK property of P1.

  Both of these facts allow us that the procedures are indistinguishable in this
  case, since if the challenges are indistinguishable then the sub-procedures in
  both procedures are effectively called on the same inputs.

  \noindent\textbf{case (R2 h2 w): } This proof follows the same steps as the
  other case with the only exception being step \textbf{1)}. In this step, since
  the challenges are sampled in a different order, we cannot assume them to be
  equal since they are sampled with different randomness. Instead we use
  \easycrypt's coupling functionality to prove that
  $e_{1}^{ideal} \sim e_{1}^{real} \oplus s$ and
  $e_{1}^{real} \sim e_{1}^{ideal} \oplus s$
  The indistinguishability follows trivially since the challenge distribution is
  assumed full and uniform.

  From this we are left with showing:
  \begin{align*}
    e_{1}^{real} &= s \oplus e_{2}^{real} && \text{eq. \ref{axiom:xorK} and \ref{axiom:xorA}} \\
                &\sim s \oplus e_{1}^{ideal} \oplus s && \text{Coupling} \\
                &= e_{1}^{ideal} && \text{eq. \ref{axiom:xorK} and \ref{axiom:xorA}}
  \end{align*}

  Which completes the proof.
\end{proof}

\begin{lemma}[OR special soundness]
  Given secure $\Sigma$-Protocols P1 P2 then
  The OR construction OR(P1,P2) satisfy definition \ref{def:sigma:soundness} with the
  witness extractor for the OR construction defined as:
\begin{lstlisting}[mathescape]
proc witness_extractor(h, a, s : challenge list, z : response list) = {
  (h1, h2) = h;
  (a1, a2) = m;
  (e1, z1, e2, z2) = z[0];
  (e1', z1', e2', z2') = z[1];
  if (e1 $\neq$ e1') {
    w = P1.witness_extractor(h1, a1, [e1;e1'], [z1;z1']);
  } else {
    w = P2.witness_extractor(h2, a2, [e2;e2'], [z2;z2']);
  }
  return w;
}
\end{lstlisting}

\end{lemma}
\begin{proof}
  We split the proof into two parts:
  \begin{itemize}
    \item $(e1 \neq e1')$: Here we must prove that \texttt{P1.witness\_extractor} produce a valid witness for R.

      Here we use equation \ref{eq:sigma:or:verify} from the special soundness
      proof of AND which lets us apply the
      special soundness property of P1, which gives us that
      $R1 \; h1 \; w \implies R1 \; h1 \; w \lor R2 \; h2 \; w = R \; (h1, h2) \; w$
    \item $\neg(e1 \neq e1')$ Here we prove the same, but with the special
      soundness property of P2 instead.
  \end{itemize}
\end{proof}

\section{Fiat-Shamir Transformation}
\label{subsec:fiat-shamir}
The Fiat-Shamir transformation is a technique for converting $\Sigma$-protocols
into zero-knowledge protocols. $\Sigma$-Protocols almost satisfy the definition
of zero-knowledge, the only problem is that $\Sigma$-Protocols only guarantee
zero-knowledge in the presence of a honest verifier. This is stated by the Special
Honest Verifier Zero-Knowledge property. However, if we can alter the protocol
to force the verifier to always be honest, then the protocol, by definition,
must be zero-knowledge.
The Fiat-Shamir transformation achieves this by removing the verifier from the
protocol and thus making it non-interactive. The verifier is then replaced by an
random oracle, which generates a random challenge based on the first message of
the prover, thus it works exactly like an honest verifier in the interactive
protocol. However, since the random oracle is a sub-procedure of the prover he
is allowed to make polynomially many call to the oracle in the hopes of getting
a good challenge... \todo{more text?}

\subsection{Oracles}
\label{subsec:sigma:fiat:oracle}
To formalise this transformation we first need a clear description of what a
random oracle is.

To capture the functionality of a random oracle we define the following abstract
module:
\begin{lstlisting}
module type Oracle = {
  proc * init() : unit
  proc sample (m : message) : challenge
}.
\end{lstlisting}

In essence, an oracle should be able to initialise its state, which used to
determine the random choices made by the oracle. Moreover, it exposes the
procedure $\texttt{sample}$ which maps messages to challenges.

In the case of a random oracle we require that oracle responds with the same
challenge if sample is queried with the same message multiple times. This is
implemented by the following module:

\begin{lstlisting}[mathescape]
module RealOracle : Oracle = {
  global variable : h = (message $\mapsto$ challenge)

  proc init() = {
    h = empty map;
  }

  proc sample (m : message) : challenge = {
    if ($m \not\in \textbf{Domain}(h)$) {
      h[m] $<\$$ dchallenge; (* Sample random value in entry m *)
      }
    return h[m];
    }
  }.
\end{lstlisting}

\subsection{Non-interactive $\Sigma$-Protocol}
\label{subsec:sigma:fiat:protocol}
We can define the non-interactive version of the protocol as the following procedure:
\begin{lstlisting}
module FiatShamir(S : SProtocol, O : Oracle) = {
  proc main(h : statement, w : witness) : transcript = {
    O.init();
    a = S.init(h, w);
    e = O.sample(a);
    z = S.response(h, w, a, e);

    return (a, e, z);
  }
}.
\end{lstlisting}

Here, a non-interactive version of a $\Sigma$-Protocol is a procedure producing
a transcript by first initialising the oracle and then sampling a challenge from it.

\paragraph{Security}
To prove security of the Fiat-Shamir transformation we need to use the security
definition of a zero-knowledge protocol.

\begin{lemma}
  If the underlying $\Sigma$-Protocol S is secure and the random Oracle O is
  lossless then the Fiat-Shamir transformation is correct.
\end{lemma}
\begin{proof}
  By comparing the completeness from the underling $\Sigma$-protocol to the
  transformation we see that the only different is that underlying protocol
  waits for the verifier to sample a challenge for him. Since a honest verifier
  will never fail to send the challenge (\ie he is lossless) and it will always
  be uniformly chosen the two procedures are equivalent.
\end{proof}

\begin{lemma}
  If the underlying $\Sigma$-Protocol S is secure and the random Oracle O is
  lossless then the Fiat-Shamir transformation is zero-knowledge
\end{lemma}
\begin{proof}
  To prove zero-knowledge in the random oracle model we must define a simulator
  producing indistinguishable output from the real procedure. Moreover, the
  simulator is allowed to choose the choices made by the oracle for the real
  protocol.

  From the correctness proof we know that the random oracle acts as a honest
  verifier. Therefore the SHVZK simulator for S proves zero-knowledge for the transformation.
\end{proof}

Soundness, however, cannot be proven by the definition of special soundness from
$\Sigma$-Protocols, since the Prover has gained more possibilities of cheating
the verifier. We could prove some arbitrary bounds, but to get a meaningful
proof of soundness for the Fiat-Shamir transformation we would need the
forking lemma, which depends on rewinding and is still an open research topic to formalise within \easycrypt\ \cite{ec_intro}.

\section{Concrete instantiation: Schnorr protocol}
\label{sec:schnorr}
To show the workability of the proposed formalisation we show that it can be
used to instantiate Schnorr's protocol.
Schnorr's protocol is run between a Prover P and a
Verifier V. Both parties have before running the protocol agreed on a group
$(\mathbb{G}, q, g)$, where $q$ is the order of $\mathbb{G}$ and $g$ is the
generator for the group.
Schnorr's protocol is a $\Sigma$-Protocol for proving knowledge of a discrete
logarithm. Formally it is a $\Sigma$-Protocol for the relation R h w $= (h = g^{w})$

When P wants to prove knowledge of w to V he starts by
constructing a message $a = g^{r}$ for some random value $r$. The Verifier will
the generate a random challenge, $e$, which is a bit-string of some arbitrary length.
Based on this challenge P then constructs a response $z = r + e \cdot w$ and sends
it to V.
To verify the transcript $(a,e,z)$ V then checks if $g^{z} = a \cdot h^{e}$.

From this general description it is clear that this protocol fits within out
formalisation of $\Sigma$-Protocol procedures. We then define the appropriate
types and instantiate the protocol using out $\Sigma$-Protocol formalisation:

\begin{lstlisting}[mathescape,label=lst:sigma:schnorr,caption=Schnorr instantiation]
clone export SigmaProtocols as Sigma with
  type statement <- group, (* group element *)
  type witness   <- F.t,   (* Finite field element, like $\mathbb{Z}_{q}$ *)
  type message   <- group,
  type challenge <- F.t,
  type response  <- F.t,

  op R h w =  ($h = g^w$)
  op dchallenge = FDistr.dt (* Distribution of messages *)
  proof *.
  realize dchallenge_llfuni. by split; [apply FDistr.dt_ll | apply FDistr.dt_funi].

module Schnorr : SProtocol = {
  var r : F.t
  proc init(h : statement, w : witness) : message = {
    r <$\$$ FDistr.dt;
    return $g^r$;
  }

  proc response(h : statement, w : witness, a : message, e : challenge) : response = {
    return $r + e \cdot w$;
  }

  proc verify(h : statement, a : message, e : challenge, z : response) : bool = {
    return $(g^z = a \cdot (h ^e))$;
  }
}
\end{lstlisting}

Here we first discharge the assumption that the challenge are lossless, uniform
and fully distributed by using the \easycrypt\ theories about distributions and
cyclic groups.

To prove security of the protocol we show that the it satisfies the security
definitions from section \ref{sec:sigma:def}.

\begin{lemma}[Schnorr correctness]
  R h w $\implies \Pr{\texttt{Completeness(Schnorr)}.main(h,w)} = 1$
\end{lemma}
\begin{proof}
  To prove correctness we need to prove two things:
  \begin{enumerate}
    \item That the procedure always terminates
    \item That it always outputs true
  \end{enumerate}
  \textbf{1)} Since all procedures bar the random sampling in $\texttt{Schnorr}$ are arithmetic
  operations they can never fail. The random sampling have been proven to be
  lossless. Therefore the procedures always terminates.

  \noindent\textbf{2)} After running all sub-procedures of the correctness game
  the output of the procedure is
  \begin{align*}
         &g^{r + e \cdot w} = g^{r} \cdot h^{e} \\
    \iff &g^{r + e \cdot w} = g^{r} \cdot g^{w^{e}} && \text{R h w = ($h = g^{w}$)} \\
    \iff &g^{r} \cdot g^{e \cdot w} = g^{r} \cdot g^{w \cdot {e}} \\
  \end{align*}

  Which is easily proven by \easycrypt\ automation tools for algebraic operations.
\end{proof}

\begin{lemma}[Schnorr soundness]
  \begin{align*}
    &e \neq e' \implies \\
    &\Pr{\texttt{verify}(a, e, z)} = 1 \implies \\
    &\Pr{\texttt{verify}(a, e', z')} = 1 \implies \\
    &\Pr{\texttt{Soundness(Schnorr)}(a, [e; e'], [z; z'])} = 1 \\
  \end{align*}
\end{lemma}
\begin{proof}
  We start by defining the witness extractor for Schnorr's protocol:
\begin{lstlisting}
proc witness_extractor(h : statement, m : message, e : challenge list, z : response list) : witness= {
  return (z[0] - z[1]) / (e[0] - e[1]);
}
\end{lstlisting}
  \todo{Define list indexing in background chapter}
  To prove that the soundness game succeeds we need the following
  \begin{enumerate}
    \item Both transcripts are accepting
    \item The witness extractor produces a valid witness for the relation R
  \end{enumerate}

  \textbf{1)} By stepping though the while loop of the soundness game we can
  show that all transcripts must be accepting by our assumptions.

  \noindent \textbf{2)} Running all procedures of the soundness game we are left
  with showing:
  \begin{equation*}
    \text{R h } ((z - z') / (e - e'))
  \end{equation*}
  Which follows by unfolding the definition of $z$ and $z'$ and using the
  automation tools of \easycrypt\  to solve algebraic operations.
\end{proof}

\begin{lemma}[Schnorr SHVZK]
  \[
    equiv[\texttt{SHVZK(Schnorr)}.ideal \sim \Pr{\texttt{SHVZK(Schnorr)}.real} :\; \indis{h,e} \land \text{R h w}^{real} \implies \indis{res}]
  \]
\end{lemma}
\begin{proof}
  We start by defining the simulator for Schnorr's protocol:
\begin{lstlisting}[mathescape]
proc simulator(h : statement, e : challenge) = {
  z <$\$$ FDistr.dt;
  a = $g^z * h ^ (-e)$;
  return (a, z);
}
\end{lstlisting}
  To prove SHVZK be must the prove output indistinguishability of the following procedures:
  \begin{figure}[ht]
    \centering
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc real(h, w, e) = {
   r <$\$$ FDistr.dt;
   a = $g^r$;
   z = $r + e \cdot w$;
   return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth }
\begin{lstlisting}[mathescape]
proc ideal(h, e) = {
  z <$\$$ FDistr.dt;
  a = $g^z * h^{(-e)}$;
  return (a, e, z);
}
\end{lstlisting}
    \end{subfigure}
  \end{figure}
  To prove this we use \easycrypt\ coupling functionality to show that $r^{real} \equiv z^{ideal} - e \cdot w^{real}$ and that $z^{ideal} \equiv r^{real} + e \cdot w^{real}$.
  This is easily prove, since the distribution is full and uniform, and the group is closed under addition and multiplication. All these facts follow directly from the cyclic group theory in \easycrypt.
  We then use this to show output indistinguishability:
  \begin{align*}
    (a^{real}, e, z^{real}) &= (g^{r^{real}}, e, r^{real} + e \cdot w^{real}) \\
                          &\sim (g^{r^{real}}, e, z^{ideal} - e \cdot w^{real} + e \cdot w^{real}) \\
                          &= (g^{z^{ideal} - e \cdot w^{real}}, e, z^{ideal}) \\
                          &= (g^{z^{ideal}} \cdot g^{w^{real} - e}, e, z^{ideal}) \\
                          &= (g^{z^{ideal}} \cdot h^{(-e)}, e, z^{ideal}) \\
                          &= (a^{ideal}, e, z^{ideal}) \\
  \end{align*}
  Which can easily be proven by \easycrypt's automation tools.
\end{proof}
\todo{The proofs have been relatively easy thanks to the strong support for algebraic groups in EC}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
