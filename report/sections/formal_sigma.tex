\chapter{Formalising Sigma-Protocols}
\label{ch:formal_sigma}
This section will aim to formalise $\Sigma$-protocols according to the
definitions set out in section \ref{sec:background:sigma_protocols}, with a
sufficiently general set-up to allows easy instantiation of arbitrary concrete
protocols.
This abstraction is provided by \easycrypt's abstract theories, where we let
$\Sigma$-Protocol be quantified over the abstract types:
\begin{itemize}
  \item input
  \item witness
  \item message
  \item challenge
  \item response
  \item randomness
\end{itemize}

And a relation $R : (\text{input} \times \text{witness}) \rightarrow \{0,1\}$.

Moreover, we require that there exists an uniform distribution, for which
elements of type challenge can be sampled from. Now, since distribution are also
probabilistic programs within \easycrypt, we require that sampling from the
distribution is always successful. This is refereed to as the distribution being lossless.

We then define the $\Sigma$-protocol itself to be a series of probabilistic procedures:
\begin{itemize}
  \item init
  \item response
  \item verify
\end{itemize}

\todo{Rewrite as EC module}

Along with another set of algorithms required to satisfy the definition of
security defined in \ref{def:sigma:sec}.

\begin{itemize}
  \item gen
  \item witness\_extractor
  \item simulator
\end{itemize}

\begin{lstlisting}[float, label=lst:sigma_completeness,caption=Completeness game for $\Sigma$-Protocols]
module Completeness(S : SigmaProtocol) = {
  proc main(h : input, w : witness) : bool = {
      var a, e, z;
      a = S.init(h,w);
      e <$ dchallenge;
      z = S.response(h, a, e);
      v = S.verify(h, a, e, z);
      return v;
  }
}.
\end{lstlisting}

An instantiation of a $\Sigma$-Protocol is then an implementation of the above
procedures, which can be seen in Listing \ref{lst:sigma_completeness}.

We then model security as a series of games:

\begin{definition}[Completeness]
  We say the protocol is complete, if the probabilistic procedure in
  \ref{lst:sigma_completeness} outputs 1 with probability 1, i.e.
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall \&m h w, R h w \implies Pr[\text{Completeness.main}(h,w) @ \&m : res] = 1\%r.
  \end{equation}
\end{definition}


\begin{definition}[Special Soundness]
Given a $\Sigma$-Protocol $S$ for some relation $R$ with public input $h$
and two any accepting transcripts $(a,e,z)$ and $(a,e',z')$
where both transcripts have the same initial message, $a$ and $e \neq e'$.

Then we say that $S$ satisfies $2$-special soundness if, there exists an
efficient \todo{what is efficient?} algorithm $A$,
which given the two transcripts outputs a valid witness for the relation $R$.

Alternatively we state $2$-special soundness as:
\todo{Add game from EC}
\end{definition}

\begin{definition}[Special Honest Verifier Zero-Knowledge]
Given a $\Sigma$-Protocol $S$ for some relation $R$ with public input $h$ and
witness $w$, then $S$ is said to be Special Honest Verifier Zero-knowledge
(SHVZK), if there exists a simulator, Sim, which given input $h$ outputs a
transcript $(a,e,z)$, which is indistinguishable from the transcript observed by
running $S$ on input $h, w$.

\todo{define indistinguishability}

\end{definition}

\begin{lemma}
  A $\Sigma$-Protocol is secure if all the above games succeed with probability $1$
\end{lemma}

\todo{Argue that games corresponds to original definitions}

\todo{To prove composition we assume to following relations to be true \dots and
this only hold if both inputs are in the domain of R.}

\section{Composition Protocols}
\label{sec:sigma_comp}

\subsection{AND}
\label{subsec:sigma_AND}
\todo{Needed to change definition of games to relate challenges}

\subsection{OR}
\label{subsec:sigma_OR}
\todo{Needed to change relation}







%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
