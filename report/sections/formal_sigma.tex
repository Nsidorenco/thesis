\chapter{Formalising Sigma-Protocols}
\label{ch:formal_sigma}
This section will aim to formalise $\Sigma$-protocols according to the
definitions set out in section \ref{sec:background:sigma_protocols}, with a
sufficiently general set-up to allows easy instantiation of arbitrary concrete
protocols.
This abstraction is provided by \easycrypt's abstract theories, where we let
$\Sigma$-Protocol be quantified over the abstract types:
\begin{itemize}
  \item input
  \item witness
  \item message
  \item challenge
  \item response
  \item randomness
\end{itemize}

And a relation $R : (\text{input} \times \text{witness}) \rightarrow \{0,1\}$.

Moreover, we require that there exists an uniform distribution, for which
elements of type challenge can be sampled from. Now, since distribution are also
probabilistic programs within \easycrypt\ , we require that sampling from the
distribution is always successful. This is refereed to as the distribution being lossless.

\todo{Relate to figure in background chapter?}

We then define the $\Sigma$-protocol itself to be a series of probabilistic procedures:
\lstinputlisting[linerange={29-38}]{../code/SigmaProtocols.eca}

\todo{Here gen is \dots}

\begin{lstlisting}[float, label=lst:sigma_completeness,caption=Completeness game for $\Sigma$-Protocols]
module Completeness(S : SigmaProtocol) = {
  proc main(h : input, w : witness) : bool = {
      var a, e, z;
      a = S.init(h,w);
      e <$ dchallenge;
      z = S.response(h, a, e);
      v = S.verify(h, a, e, z);
      return v;
  }
}.
\end{lstlisting}

An instantiation of a $\Sigma$-Protocol is then an implementation of the above
procedures, which can be seen in Listing \ref{lst:sigma_completeness}.

We then model security as a series of games:

\begin{definition}[Completeness]
\label{def:sigma:completeness}
  We say that a $\Sigma$-protocol, S, is complete, if the probabilistic procedure in
  \ref{lst:sigma_completeness} outputs 1 with probability 1, i.e.
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall \&m h w, R h w \implies Pr[\text{Completeness(S).main}(h,w) @ \&m : res] = 1\%r.
  \end{equation}
\end{definition}

One problem with definition $\ref{def:sigma:completeness}$ is that
quantification over challenges is implicitly done when sampling from the random
distribution of challenges. This mean that reasoning about the challenges are
done within the probabilistic Hoare logic, and not the ambient logic. If we at
some later point need the completeness property to hold for a specific
challenge, then that is not true by this definition of completeness, since
the ambient logic does not quantify over the challenges. To alleviate this
problem we introduce a alternative definition of completeness:

\begin{definition}[Alternative Completeness]
\label{def:sigma:alt_completeness}
  We say that a $\Sigma$-protocol, S, is complete if:
  \begin{equation}
    \label{eq:sigma_completeness}
    \forall \&m h w e, R h w \implies Pr[\text{Completeness(S).special}(h,w,e) @ \&m : res] = 1\%r.
  \end{equation}
  Where the procedure ``Completeness(S).special'' is defined as
  \lstinputlisting[linerange={40-48}]{../code/SigmaProtocols.eca}
\end{definition}

Now, since the alternative procedure no longer samples from a random
distribution it is not possible to prove equivalence between the two procedure,
but to show that this alternative definition is still captures what is means for
a protocol to be complete we have the following lemma:

\begin{lemma}
Given that definition \ref{def:sigma:alt_completeness} then it must hold that
definition \ref{def:sigma:completeness} holds, given the same public input and witness.

This can be stated in \easycrypt as:
\begin{lstlisting}[mathescape]
lemma special_implies_main (S <: SProtocol) h' w':
  ($\forall$ h' w' e',
    phoare[special : (h = h' /\ w = w' /\ e = e') ==> res] = 1%r)
  =>
  phoare[Completeness(S).main : (h = h' /\ w = w') ==> res] = 1%r.
\end{lstlisting}
\end{lemma}

\begin{proof}
First we start by defining an intermediate game:
\begin{lstlisting}
proc intermediate(h : input, w : witness) : bool = {
   e <$ dchallenge;
   v = special(h, w, e);
   return v;
}
\end{lstlisting}

From this it is easy to prove equivalence between the two procedures
``intermediate'' and ``main'' by simply inlinining the procudures and moving
the sampling to the first line of each program. This will make the two programs
equivalent.

Now, we can prove the lemma by instead proving:
\begin{lstlisting}
lemma special_implies_main (S <: SProtocol) h' w':
  (forall h' w' e', phoare[special : (h = h' /\ w = w' /\ e = e') ==> res] = 1%r) =>
  phoare[intermediate : (h = h' /\ w = w') ==> res] = 1%r.
\end{lstlisting}

The proof then proceeds by first sampling $e$ and then proving the following
probabilistic Hoare triplet: $true \vdash \{\exists e', e = e'\}
\text{special(h,w,e)} \{true\}$. Now, we can move the existential
from the pre-condition into the context:
\[
  e' \vdash \{e = e'\} \text{special(h,w,e)} \{true\}
\]

Which then is proven by the hypothesis of the ``special'' procedure being complete.

\todo{variable declarations have been omitted}
\end{proof}


\begin{definition}[Special Soundness]
\label{def:sigma:soundness}
Given a $\Sigma$-Protocol $S$ for some relation $R$ with public input $h$
and two any accepting transcripts $(a,e,z)$ and $(a,e',z')$
where both transcripts have the same initial message, $a$ and $e \neq e'$.

\begin{lstlisting}[float, label=lst:sigma-soundness, caption= 2-special soundness game]
module SpecialSoundness(S : SProtocol) = {
  proc main(h : statement, m : message, c c' : challenge, z z' : response) : bool = {
    var w, v, v';

    v  = S.verify(h, m, c, z);
    v' = S.verify(h, m, c', z');

    w = S.witness_extractor(h, m, c, c', z, z');

    return (c <> c' /\ (R h w) /\ v /\ v');
  }
}.
\end{lstlisting}

We then define special soundness as winning the game
defined in Listing \ref{lst:sigma-soundness} with probability 1.

\end{definition}

\begin{definition}[Special Honest Verifier Zero-Knowledge]
Given a $\Sigma$-Protocol $S$ for some relation $R$ with public input $h$ and
witness $w$, then $S$ is said to be Special Honest Verifier Zero-knowledge
(SHVZK), if there exists a simulator that given input $h$ outputs a
transcript $(a,e,z)$, which is indistinguishable from the transcript observed by
running $S$ on input $h, w$.

\todo{define indistinguishability}

\end{definition}

\begin{definition}
\label{def:sigma-protocol}
  S is said to be a $\Sigma$-Protocol if it satisfies the above three definition
  and is on three-move form.
\end{definition}

\todo{Argue that games corresponds to original definitions}

\todo{To prove composition we assume to following relations to be true \dots and
this only hold if both inputs are in the domain of R.}

\section{Composition Protocols}
\label{sec:sigma_comp}
\todo{Some introduction based on background chapter?}

\subsection{AND}
\label{subsec:sigma_AND}
\todo{Needed to change definition of games to relate challenges}

In this section we prove the AND construction to be a $\Sigma$-protocol by
definition \ref{def:sigma-protocol}.

\todo{Write protocol as diagram?}
\todo{Write procedure definitions?}

\begin{lemma}[AND completeness]
  \begin{align*}
    R h w \land
    \Pr{Completeness.main(S_{1})} = 1 \land \Pr{Completeness.main(S_{2})} = 1 \\
    \implies \Pr{Completeness.main(AND(S_{1}, S_{2}))} = 1
  \end{align*}
  % If the completeness definition (\ref{def:sigma:completeness}) is instantiated
  % with the AND protocol, then it will succeed with probability 1, if $S_{1}$ and $S_{2}$
  \todo{Missing parameters and quantification}
\end{lemma}
\begin{proof}
  The proof proceeds by game-hopping to:
  \begin{lstlisting}[mathescape]
  proc intermediate(h : input, w : witness) = {
    $(h_{1}, h_{2}) = h$;
    $(w_{1}, w_{2}) = w$;
    $v_{1} = Completeness(S_1).main(h_1, w_{1})$
    $v_{2} = Completeness(S_2).main(h_2, w_{2})$

    return $v_{1} \land v_{2}$
  }
  \end{lstlisting}

  This intermediate game will return true with probability 1 since both
  $v_{1}$ and $v_{2}$ will always return true by our assumption of completeness
  for $S_{1}$ and $S_{2}$.
\end{proof}

\begin{lemma}[AND special soundness]
  \begin{align*}
    &R (h_{1}, h_{2}) (w_{1}, w_{2}) \\
    \land &\Pr{S_{1}.verify(h_{1}, w_{1}, e, z)} = 1 \\
    \land &\Pr{S_{2}.verify(h_{2}, w_{2}, e', z')} = 1 \\
    &\implies \Pr{SpecialSoundness(AND(S_{1}, S_{2})).main} = 1
  \end{align*}
\end{lemma}



\subsection{OR}
\label{subsec:sigma_OR}
\todo{Needed to change relation}


\subsection{Concrete Example: Schnorr protocol}
\label{subsec:schnorr}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
