\chapter{Introduction}
\label{ch:intro}
Since their introduction, zero-knowledge arguments/proofs have become
an important building block for cryptographic protocols.
Zero-knowledge has, for example, been used to enable anonymous board-room
voting \cite{boardroom-voting} and to ensure privacy in blockchain applications \cite{concordium}.
Moreover, zero-knowledge also has important theoretical applications, where it
is used by the GMW-compiler to turn any passively secure protocol into an
actively secure protocol.

Due to zero-knowledge being applied in critical applications like
blockchains, which could have real-life financial consequences if the security is
broken, it is paramount that we can offer the highest levels of assurance in the
protocols performing to specification.
However, many proofs of security are considered unverifiable, partly due to informal
reasoning and implicit arguments. Bellare and Rogaway also remarked this \cite{game-playing}:

\begin{quote}
In our opinion, many proofs in cryptography have become essentially unverifiable. Our field may be approaching a crisis of rigor.
\end{quote}

To harness this complexity, Bellare and Rogaway suggest the code-based game-playing approach
for doing security proofs.
However, game-playing security is not the end-all of security, and the approach
still allows for unrigorous proofs. Many cryptographic proofs still suffer
from informal arguments and human errors when proving security.

However, with the code-based approach, we can apply
formal verification to help us attain an even higher level of trust in our
proofs by making them machine verifiable.
This approach has been made possible by the recent advances in proof assistants
specialising in formal verification of probabilistic programs \cite{SOK:CAC}.
It is important to remark, however, that formally verified does not imply
absolute security. When formally proving cryptographic protocols, we do so in
the context of a cryptographic model.
Such models help us by reducing the complexity of our protocols
by limiting external influences or by giving access to idealised
functionalities. If the assumptions made in the model used are unsound, then the
protocol would still be insecure, even though it has been formally proven.
However, by applying formal
reasoning to cryptographic proofs, we can expel all informal reasoning and
implicit knowledge, thus attaining much more precise definitions of security.

An additional benefit of using tools supporting game-based security, like \easycrypt, is that
it becomes possible to formally verify protocols in a representation very close
to the one in cryptographic literature. This gives a more direct connection between
the formal proofs and how the protocols are used in practice.
These proof assistants also open the possibility of extracting the verified
protocol into an efficient language, which can be run on most computers.
One example of this is \easycrypt, where a low-level language called Jasmin has
been successfully embedded within \cite{easycrypt-jasmin}.
Cryptographic protocols written in a low-level machine language can
then, through EasyCrypt, be formally proven secure and extracted to assembly code.

Studying these tools are, therefore, important since they could help
cryptographer to describe their protocols more rigorously while providing
machine verifiable proofs.

In an attempt to bring higher assurance to the field of cryptography, formal
verification of various cryptographic primitives have commenced
\cite{SOK:CAC,ec_intro,cryptoeprint:2019:1185,certicrypt_sigma,DBLP:journals/corr/abs-1805-12482,DBLP:journals/corr/abs-1806-07197}.

The goal of this thesis is to further this formalisation effort by reproducing
previous results of $\Sigma$-Protocols and Commitment schemes before formalising
a variant of Multi-party computations protocols and the ZKBOO protocol by
\cite{zkboo}.
To achieve this, we study the \easycrypt\ proof assistant.
Here we examine the workability of \easycrypt\ and discuss
the benefits and drawbacks of using the tool. Additionally, we remark on how
the tool is to use given no prior knowledge of the tool.

$\Sigma$-Protocols has the desirable attribute of having code-based
game-playing definitions of security, which allows us to use \easycrypt in order to formulate
and prove their security. Moreover, $\Sigma$-Protocols can be turned into
zero-knowledge proofs with limited overhead \cite{zkboo}.
To reason about $\Sigma$-Protocols, we reproduce the results of \cite{cryptoeprint:2019:1185} to
develop a rich formalisation of $\Sigma$-Protocols in \easycrypt.
This formalisation can then be used to formalise cryptographic protocols
depending on $\Sigma$-Protocols.

Additionally, we reproduce the formalisation of commitment schemes by
\cite{DBLP:journals/corr/MetereD17} and improve upon the work by offering
alternative, yet equivalent, security definitions.

We then use our formalisation of $\Sigma$-Protocols to formalise ZKBoo, which
uses multi-part computations and commitment schemes to make
a generalised $\Sigma$-Protocol. With this work, we aim to demonstrate how complex
cryptographic protocols can be formally verified by using formalisations of
cryptographic primitives. Moreover, we show how formal verification can help expose
the implicit and informal assumptions often made in cryptographic papers.

To formalise ZKBoo, we also have to formalise arithmetic circuits, which can help
guide future formalisations. Moreover, we formalisation of a particular variant
of multi-party computations on arithmetic circuits called the
(2,3)-Decomposition where all parties are simulated locally.


\paragraph{Outline}
In \autoref{ch:EasyCrypt}. we introduce the code-based game-playing approach to
cryptographic security. Moreover, we introduce the \easycrypt\ proof assistant,
and how it can be used to formally prove code-based protocols.
\autoref{ch:background} introduce key concepts and definitions.

In \autoref{ch:formal_commitment}, we reproduce the results of
\cite{DBLP:journals/corr/MetereD17} to formalise commitment schemes and a
concrete instantiation in the form of Pedersen's commitment scheme.
Additionally, we formulate alternative security definitions, which can help
apply our formalisation in more complex protocols.

In \autoref{ch:formal_sigma} we explore the results by
\cite{cryptoeprint:2019:1185}, which were formalised in the Isabelle/CryptHOL
proof assistant. These results are then reproduced in \easycrypt.

Chapter \ref{ch:general_zk} introduces generalised zero-knowledge protocols and
ZKBoo as well as an informal overview of the security proofs of ZKBoo given by \cite{zkboo}.

Next, in \autoref{ch:formal_zkboo} we formalise arithmetic circuit and the
(2,3)-Decomposition of arithmetic circuits. We then conclude the chapter by
formally proving the security of ZKBoo.

Last, we summarise our findings and their relation to other works within the
area of formal verification.

\paragraph{Implementation}
The \easycrypt\ files of the work explored in this thesis
are publicly available on Github\footnote{https://github.com/Nsidorenco/thesis}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
