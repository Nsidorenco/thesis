\chapter{Introduction}
\label{ch:intro}

\todo{Maybe add database example from CertiCrypt paper?}

Computer-aided cryptography is an active area of research that combines the
fields of formal verification and cryptography to develop
formal machine-checkable proofs approaches to cryptographic protocol design as
well as the implementations of said protocols \cite{SOK:CAC}.

\todo{Formal verification is ...}

the field of cryptography has in recent times lend itself to ``game hopping''
approach to design-level security of protocols. In this approach security is
modelled as the probability of an adversary, with varying degrees of power,
breaking the intended design of the protocol. This is done usually done by
either proving that it is impossible for the adversary to break to protocol by
mathematical reasoning on the possible choices the adversary can make or
proving that breaking the protocol is computationally equivalent to
solving a, presumably, difficult problem.

The problem with this approach is that these game reduction are often prone to
implicit assumptions and rely on peer-reviewing of the proof of security.

Finally, cryptographic design does not led it self to implementation level
security issues, which is usually left to domain expert when implementing the
protocols.

Computer-aided cryptographic can help us solve these problems by making the
assumptions more transparent, but moreover it also makes the logical reasoning
more transparent. Since formal proofs can only proceed by applying logical
rules, then an error can only arise from having a flaw in the core logic or in
one of the assumptions made for the protocol.

% State of the art Computer-aided cryptography now allows us to build toolchains,
% where it is possible to prove the security of a protocol within a logical
% framework and then compiling it to efficient machine-level code, while ensure
% that this compilation is sound, i.e. the same security guarantees provided in
% the host language will still hold in the target language.

Having formally verified software is especially important when it is used as a
building block in bigger and more complex protocols.
One such example of a fundamental building block in cryptology is Zero knowledge
arguments, which since their introduction has been in many complex cryptographic
protocols. Most notably they have found important use on the blockchain and in
the  GMW compiler, which can compile any passively secure protocol into a active
secure one.

One problem with Zero-knowledge arguments is that they usually fall into two
categories: They are either efficient, but to specialised, or they are
generalised but too inefficient. A example of the former is Schnorr protocol,
which allows us to prove knowledge of a discrete logarithm.

This has led to a new class of protocols known as \textit{Succinct
  Non-interactive ARguments of Knowledge}, also known as SNARKS, which aim to
improve on the generalised zero knowledge protocols by reducing the size of the
proof and moves the bulk of the work to prover, such that SNARKS can be quickly
verified but are expensive to make.
\todo{reference}

Since these generalised zero-knowledge compilers can be used within applications
where security is critical it is important to that they have been rigorously
studied and formally proven.

In this paper we will therefore look at the ZKBoo protocol by \citet{zkboo},
which can generate zero-knowledge proofs for any relation, assuming the relation
can be expressed as a circuit, with a bound on the proof size.

In doing so we will develop a rich formalisation of $\Sigma$-protocols they
relate to Zero-knowledge. Moreover, we will show how to create a fully verified
toolchain for constructing a generalised zero-knowledge compiler based on ZKBoo.

the main contribution of this thesis is \dots

\todo{Goal: Develop a rich formalisation that be the basis for future formal analysis of zero-knowledge protocols}

\paragraph{Outline}
In chapter \ref{ch:EasyCrypt} \dots
Then in chapter \ref{ch:background} we introduce the relevant background
in regards to $\Sigma$-Protocols, Commitment schemes and Multi-part computations.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
