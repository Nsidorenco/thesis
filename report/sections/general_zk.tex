\chapter{Generalised Zero-Knowledge compilation}
\label{ch:general_zk}
We have previously seen a concrete instantiation of a $\Sigma$-protocol with the
relation being the discrete logarithm problem, namely Schnorr's protocol. We
have also seen how it was possible to prove Schnorr's protocol to be secure in a
formal setting though \easycrypt.

\todo{Mention zkSNARKS?}

There exists an infinite set of possible relations, for which we could want to
provide zero-knowledge proofs of. It is therefore infeasible to design a
protocol for each relation and proving its security.

An example of this is the GMW-compiler \dots, or the example system from \cite{zkcrypt}.

We therefore need a more generalised approach, that is able to generate
zero-knowledge proof for an entire family of relations rather than a specific relation.
One such family of relations is the pre-image under group homomorphisms \dots

Another important factor of zero-knowledge compilers is the reduce the proof
size. ZK proofs are notoriously expensive to run.

\section{ZKBOO}
\label{sec:zkboo}
The ZKBoo protocol, which was invented by \citet{zkboo}, is a zero-knowledge compiler for relations, which can be
expressed as the pre-image of a group homomorphism, i.e.

\[
  R \text{ h w} = \phi(w) = h
\]

Where $h$ is the public input and $w$ is the witness.

The principle idea of this protocol is based on a technique called ``MPC in the
head''. Recall from section \ref{sec:background:mpc}, that the theory of
Multipart Computation allows us, for any given function taking $n$ inputs to
securely compute output $y$ for the function. We then have by definition
\ref{def:mpc:d-privacy} that as long as less than $d \leq n$ views are available to the adversary, then the inputs to the function are private.

Now, if we instead of proving the knowledge of a witness satisfying $\phi(w) = h$
we revealed a run, i.e. the views, of a MPC protocol computing the above
function, but with the witness distributed amongst all parties then we have the
claims:

\begin{lemma}
\label{lemma:zkboo_correctness}
By correctness (definition \ref{def:mpc:correctness}), and assuming that
the input share to the parties where indeed a valid distribution of the
witness, then we can conclude that the witness is the pre-image of the public input
\end{lemma}

\begin{lemma}
\label{lemma:zkboo_privacy}
By d-privacy (definition \ref{def:mpc:d-privacy}) if less than $d$ views are
revealed, then the witness is not revealed.
\end{lemma}

Which ultimately gives us:

\begin{lemma}
\label{lemma:zkboo_secure}
From lemma \ref{lemma:zkboo_correctness} and lemma \ref{lemma:zkboo_privacy} it
follows that MPC can be used to create an zero-knowledge protocol for the
pre-image of a group homomorphism.
\end{lemma}

Before we go into proving the above lemmas, we first need to address how we are
to actually perform the MPC protocol. Having to depend on $n$ different parties
to perform a zero-knowledge protocol is not a feasible solution, so instead of
recruiting the help of $n$ external parties to perform the protocol we instead
perform the entire protocol locally by simulating every party in the protocol.
This is commonly refereed to as performing the protocol ``in the head''.

\todo{implication on security by having all parties locally}

The following section we then, in order, be dedicated to explaining how to
distribute the witness to multiple parties, and decomposing the original single
input into an MPC protocol computing the function take $n$ inputs. Then, having
properly defined the MPC protocol, we will show how to use the ``MPC in the
head'' protocol to make a zero-knowledge protocol to and prove lemma \ref{lemma:zkboo_secure}.

\subsection{(2,3)-Function Decomposition}
\label{subsec:decomposition}
(2,3)-Function decomposition is a general technique given a function
$f : X \rightarrow Y$ and a input value $x \in X$ to compute the value $f(x)$ by
splitting it into three computational branches, where revealing tow of the
branches reveals no information about the input $x$.
Through-out this section we will simply refer the a (2,3)-Function decomposition
as $\decomp$.

\todo{General description}

Based on the security definitions from MPC (Section \ref{sec:background:mpc}) we
can then define the two necessary properties from \cite{zkboo} for security of
our (2,3)-Function decomposition, namely, correctness and privacy.

\begin{definition}[Correctness]
\label{def:decomp_correctness}
A (2,3)-decomposition $\decomp$ is correct if $\forall x \in X, \Pr{\phi(x) = \Phi_{\phi}^{*}(x)} = 1$.
\todo{Change notation to account for randomness}
\end{definition}

\begin{definition}[Privacy]
\label{def:decomp_privacy}
A (2,3)-decomposition $\decomp$ is 2-private if it is correct and for all challenges
$e \in \{1,2,3\}$ there exists a probabilistic polynomial time simulator $S_{e}$
such that:
\[
  \forall x \in x, \left(\{\tape_{i}, \view_{i} \}_{i \in \{e, e+1\}}, \textbf{y}_{e+2} \right)
  \equiv S_{e}(x)
\]
Where $\left(\{\tape_{i}, \view_{i} \}_{i \in \{e, e+1\}}, \textbf{y}_{e+2}
\right)$ is produced by running $\decomp$ on input $x$
\end{definition}

\subsubsection{(2,3)-Function Decomposition for Arithmetic circuits}

\todo{For the scope of this thesis we simplify this assumption, and only look at
functions, which can be represented as a arithmetic circuit in some finite
integer ring. If the function is represented as an integer arithmetic circuit,
then a general technique exists for perform the (2,3)-Decomposition}

\todo{Describe technique for 2,3 decomp of arith.}

\subsection{Making the protocol zero-knowledge}
\label{subsec:zkboo_sigma}



\todo{Proof size of ZKboo}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
