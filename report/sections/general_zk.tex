\chapter{Generalised Zero-Knowledge compilation}
\label{ch:general_zk}
We have previously seen a concrete instantiation of a $\Sigma$-protocol with the
relation being the discrete logarithm problem, namely Schnorr's protocol
(Section \ref{sec:schnorr}).
We have also seen how it is possible to prove the security of $\Sigma$-Protocols
working on composite relations like AND and OR (Section \ref{sec:sigma_comp}).
The main problem with these solutions is that they require a specialised
$\Sigma$-Protocol for every non-composite relation. In our case we have a
protocol we can use for proving knowledge of the discrete logarithm relation,
but what if we also want to prove knowledge for another computational problem?
With our current framework we would have to define a new $\Sigma$-Protocol
exclusively for this relation.

The problem with this is that there exists an infinite set of possible
relations, for which we could want to provide zero-knowledge proofs. It is
therefore infeasible to design a protocol for each relation and proving it to be
secure.

We therefore need a more generalised approach, that is able to generate
zero-knowledge proof for an entire family of relations rather than a specific relation.
One such family of relations is the pre-image under group homomorphisms \dots

We will in this chapter introduce the generalized zero-knowledge compiler,
ZKBoo, by \citet{zkboo}. When doing so we aim to provide an general overview
of how the protocol works, whilst recalling key definitions and proofs from the paper.

\section{ZKBOO}
\label{sec:zkboo}
\todo{Based on MPC in the head}
\todo{Needs a semi-honest MPC protocol}
\todo{Efficient because of semi-honest requirement}
\todo{privacy implies ZK}
\todo{Can only cheat verifier if he is unlucky in the view he opens}
\todo{One view needs to be inconsistent to produce valid output for invalid input}
ZKBoo protocol is a generalised $\Sigma$-Protocol for the class of relations that can be
expressed as the pre-image of a group homomorphism, i.e.

\[
  R \text{ h w} = \phi(w) = h
\]

Where $h$ is the public input and $w$ is the witness.

\todo{define view. different from normal MPC definition}

The principle idea of this protocol is based on a technique called ``MPC in the
head''. Recall from section \ref{sec:background:mpc}, that
Multipart Computations allows us to securely compute any given function taking
$n$ inputs to an output $y$.
We then have by definition \ref{def:mpc:d-privacy} that as long as only
$d \leq n$ views are available to the adversary, then the inputs to the function
are private.

Now, if we instead of proving the knowledge of a witness satisfying $\phi(w) = h$
we revealed a run, i.e. the views of a MPC protocol computing the above
function, but with the witness distributed amongst all parties then we get the
following:

\begin{lemma}
\label{lemma:zkboo_correctness}
By correctness (definition \ref{def:mpc:correctness}), and assuming that
the input share to the parties where indeed a valid distribution of the
witness, then we can conclude that the witness is the pre-image of the public input
\end{lemma}

\begin{lemma}
\label{lemma:zkboo_privacy}
By d-privacy (definition \ref{def:mpc:d-privacy}) if $d \leq n$ views are
revealed, then the witness is not revealed.
\end{lemma}

Which ultimately gives us:

\begin{lemma}
\label{lemma:zkboo_secure}
From lemma \ref{lemma:zkboo_correctness} and lemma \ref{lemma:zkboo_privacy} it
follows that MPC can be used to create an $\Sigma$-Protocol for the
pre-image of a group homomorphism.
\end{lemma}

Before we go into proving the above lemmas, we first need to address how we are
to actually perform the MPC protocol. Having to depend on $n$ different parties
to perform a zero-knowledge protocol is not a feasible solution, so instead of
recruiting the help of $n$ external parties to perform the protocol we instead
perform the entire protocol locally by simulating every party in the protocol.
This is commonly refereed to as performing the protocol ``in the head''.

\todo{implication on security by having all parties locally}

The following section we then, in order, be dedicated to explaining how to
distribute the witness to multiple parties, and decomposing the original single
input into an MPC protocol computing the function take $n$ inputs. Then, having
properly defined the MPC protocol, we will show how to use the ``MPC in the
head'' protocol to make a zero-knowledge protocol to and prove lemma \ref{lemma:zkboo_secure}.

\subsection{(2,3)-Function Decomposition}
\label{subsec:decomposition}
\todo{MPC protocol but local}
(2,3)-Function decomposition is a general technique for computing the output of
a function $f : X \rightarrow Y$ on input value $x \in X$.
The decomposition works by splitting the function evaluation into three
computational branches where each computation branch is a party in a MPC
protocol. Each party is then allowed to communicate with each other, but
observing the computation of any two of the parties will reveal no information
about the input value $x$.
Through-out this section we will simply refer the (2,3)-Function decomposition
of a function $f$ as $\decomp_{f}$.

We refer to the three parties of the decomposition as $P_{1}, P_{2}, P_{3}$. The
decomposition then works by converting the function $f$ into a circuit and
computing a input share for each party, where the original input can be obtain
if all three input shares are acquired.
Each party then evaluates the gates in the circuit to a new
share based on the input they are given. party $P_{i}$ is allowed to communicate
with party $P_{i+1 \mod 3}$, but since every party in run locally it effectively
means that party $P_{i}$ has access to the entire view of $P_{i+1 \mod 3}$ for
the entire duration of the protocol. The view of a party is then a list  of all the shares that
the party has computed so far. The view of party $P_{i}$ is referred to as
$w_{i}$ For the rest of this section we will omit the $\mod 3$ from the
indexing. Moreover we assume that each party has access to a random tape $k_{i}$
which describes what the party should do if the protocol asks for a random
choice.

\begin{definition}
  In its most general form the decomposition is a collection of functions:
  \[
    \decomp = \{\text{Share}, \text{Output}, \text{Rec}, \text{Update}\}
  \]

  Where Share is a procedure for compute the three inputs shares based on a
  input to $f$.
  Moreover, it should be possible to invert the share procedure such that the
  original input can be recovered from the three input shares.
  Output is a function returning the output share from the view of a party.
  Rec is a function reconstructing the output of the function $f$ based on the
  output values of the parties.

  Lastly we have Update(w$^{j}_{i}$, w$^{j}_{i+1}$, k$_{i}$, k$_{i+1}$) $= w^{j+1}_{i}$ which
  is the function used to evaluate the j'th gate of the circuit from the point
  of view of $P_{i}$. Here
  $j$ also refers to the size of the view, i.e. how many shares has been
  computed so far.
\end{definition}

The (2,3)-Decomposition is then the three views produced by running Update on
each party with input shares produced by Share until the entire circuit has been
evaluated by each party.

\paragraph{Security}
Based on the security definitions from MPC (Section \ref{sec:background:mpc}) we
can then define the two necessary properties from \cite{zkboo} for security of
our (2,3)-Function decomposition, namely, correctness and privacy.

\begin{definition}[Correctness]
\label{def:decomp_correctness}
A (2,3)-decomposition $\decomp_{f}$ is correct if
$\forall x \in X, \Pr{f(x) = \decomp_{f}(x)} = 1$.
\todo{Change notation to account for randomness}
\end{definition}

\begin{definition}[Privacy]
\label{def:decomp_privacy}
A (2,3)-decomposition $\decomp_{f}$ is 2-private if it is correct and for all challenges
$e \in \{1,2,3\}$ there exists a probabilistic polynomial time simulator $S_{e}$
such that:
\[
  \forall x \in x, \left(\{\tape_{i}, \view_{i} \}_{i \in \{e, e+1\}}, \textbf{y}_{e+2} \right)
  \equiv S_{e}(x)
\]
Where $\left(\{\tape_{i}, \view_{i} \}_{i \in \{e, e+1\}}, \textbf{y}_{e+2}
\right)$ is produced by running $\decomp$ on input $x$
\end{definition}

\subsubsection{(2,3)-Function Decomposition for Arithmetic circuits}
\label{subsec:general:arith}
Based on the general description of the (2,3)-Decomposition from the previous
section we can now define a concrete (2,3)-Decomposition of arithmetic circuits
as in \citet{zkboo}.

We assume the circuit is expressed in some arbitrary finite field
$\mathbb{Z}_{q}$ such that the circuit can be expressed by gates: addition by constant,
multiplication by constant, binary addition, and binary multiplication.
Assume that every gate in the circuit is labelled as $[1 \dots N]$ where $N$ is
the total number of gates.
We then implement $\decomp_{\text{ARITH}}$ as:

\begin{itemize}
  \item Share$(x, k_{1}, k_{2}, k_{3})$: Sample random values
    $x_{1}, x_{2}, x_{3}$ such that $x = x_{1} + x_{2} + x_{3}$
  \item Output$(w_{i}) = y_{i}$: return the output share of party i.
  \item Rec$(y_{1}, y_{2}, y_{3}) = y_{1} + y_{2} + y_{3} = y$ where $y$ is the
    value of evaluating the circuit normally.
  \item Update(view$^{j}_{i}$, view$^{j}_{i+1}$, k$_{i}$, k$_{i+1}$): Here we
    define procedures based on what type the j'th gate is. Since update only
    append a new share to the view of the party we only define how to compute
    the new share, since the old shares are immutable.
    \begin{itemize}
      \item Addition by constant: where $a$ is the input wire to the gate
        and $\alpha$ is the constant.
        $$ w[j+1]_{i} =
        \begin{cases} w_{i}[a] + \alpha & \text{if } i = 1 \\
                      w_{i}[a]          & \text{else}       %
        \end{cases}$$
      \item Multiplication by constant: where $a$ is the input wire to the gate
        and $alpha$ is the constant
        $$ w_{i}[j+1] = w_{i}[a] \cdot \alpha$$
      \item Binary addition: where $a, b$ are the input wires.
        $$
        w_{i}[j+1] = w_{i}[a] + w_{i}[b]
        $$
      \item Binary multiplication: where $a, b$ are the input wires.
        $$
        w_{i}[j+1] = w_{i}[a] \cdot w_{i}[b] + w_{i+1}[a] \cdot w_{i}[b] + w_{i}[a] \cdot w_{i+1}[b] + R_{i}(j+1) - R_{i+1}(j+1)
        $$
        Where $R_{i}(j+1)$ is a uniformly random function sampling values using $k_{i}$
    \end{itemize}
\end{itemize}

Here the binary multiplication gate is the most interesting since it needs the
share from another party to compute. The random values are added to hide what
the share of the other party where. If the random values where not added then if
would be easy to deduce what the share of $P_{i+1}$ where given access to the
view of party $P_{i}$.

\todo{ZKBoo omits implementation detail - what is the output wire of the gate}

\todo{Replace $\phi$ with f?}
\subsection{ZKBoo}
\label{subsec:general:zkboo}
Based on the (2,3)-Decomposition we are now ready to describe the
$\Sigma$-Protocol for the relation R x y = $f(x) = y$.

The protocol proceeds as follows:
\begin{itemize}
  \item The Prover run obtains the circuit representation $C_{f}$ of f and uses
    $\decomp$ to produce three views $w_{1}, w_{2},$ and $w_{3}$.
    The Prover then commits to all random choices and the views and sends the
    output shares $y_{1}, y_{2}, y_{3}$ of the decomposition and the commitments to the Verifier
  \item The verifier pick a number $e \in \{1,2,3\}$
  \item The Prover sends views $w_{e}, w_{e+1}$ to the Verifier
  \item The Verifier checks
    \begin{itemize}
      \item The commitments corresponds to the views
      \item The view $w_{e}$ has been constructed by $\decomp$
      \item Rec$(y_{1}, y_{2}, y_{3}) = y$
    \end{itemize}
\end{itemize}

From this protocol we can see that if $\decomp_{f}$ is correct and we get access to
all three views then we would be able to extract the witness of the relation,
since the output of decomposition is equivalent to the result of the function it decomposes.
By only revealing 2 of the three views we are ensured by the 2-privacy property
of $\decomp$ that the protocol is zero-knowledge. This
property is stronger than the one given by $\Sigma$-protocols, which only offers
zero-knowledge if the verifier is honest. The problem, however, is that the
Prover gives the Verifier access to the commitment of the last view, so if the
view can be determined based on the commitment then the zero-knowledge property
does not hold.

Lastly, if the Prover is to cheat the Verifier he must produce three views where
the output is $y$. The only way for the Prover to do this is to change some of
the shares in one of the views to coerce the output. By doing so one of the
views will deviate from the procedures of $\decomp_{f}$, which the prove can easily
check if the pick the correct challenge.

To prove that the above claims holds and that the ZKBoo protocol is secure we will
in the following chapter use the work laid out in this thesis to develop a
formalisation of the ZKBoo protocol that captures the aforementioned security aspects.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
