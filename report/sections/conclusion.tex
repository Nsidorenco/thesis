\chapter{Reflections and Conclusion}
\label{sec:reflection_conclusion}

\section{Related Works}
\label{sec:related_works}
This work exists in the field of formal verification of cryptographic protocols.
Notably our work has been heavily influenced by similar formalisations
\cite{cryptoeprint:2019:1185,DBLP:journals/corr/MetereD17,certicrypt_sigma,zkcrypt,Yao}

\citet{cryptoeprint:2019:1185} managed to formalise both $\Sigma$-Protocols and
commitment schemes within Isabelle/CryptoHOL. Additionally, they have managed to
prove that commitment schemes can be build directly from $\Sigma$-Protocols.
Their formalisation of $\Sigma$-Protocols also include various concrete
instantiations.
The main difference between the results obtained in their work compared to our
has been the tool usage. Isabelle/CryptHOL is a tool similar to \easycrypt\ that
offers a higher-order logic for dealing with cryptographic game-based proofs.
The fundamental difference between the two tools is that Isabelle/CryptHOL
programs are written in a functional style, where as \easycrypt\ allows the user
to write programs in an imperative style. This ultimately leads to the same
understanding of programs as distribution transformers as discussed in chapter
\ref{ch:EasyCrypt}. Moreover, \easycrypt\ offers strong automation tactics...

Other formalisations of $\Sigma$-Protocols also exists. \citet{certicrypt_sigma}
successfully formalised $\Sigma$-Protocols with CertiCrypt. They work includes a
formalisation of $\Sigma$-Protocols where the relation is the pre-image of a
homomorphism with certain restrictions or a claw-free permutation. This has
allowed them to define and prove the security for a whole class of
$\Sigma$-Protocols. This result is similar to the one we achieved with out
formalisation of ZKBoo. ZKBoo, however, defines a more general class of
$\Sigma$-Protocols than the one defined in the paper.

Moreover, commitment schemes has been formalised in \easycrypt\ by
\citet{DBLP:journals/corr/MetereD17}. Their work differs from our by offering
less definitions of security, which we described the need for in chapter \ref{ch:formal_commitment}

Notable work also exists for formalising generalised zero-knowledge compilers.
\citet{zkcrypt} developed a fully verified zero-knowledge compiler in CertiCrypt
which uses the generalised Schnorr protocol to produce zero-knowledge proofs of
any relation defined by the pre-image of a group homomorphism, just like ZKBoo.
The generalised Schnorr protocol, however, is a fundamentally different protocol
than ZKBoo, in the sense that it does not use MPC or commitment scheme.

Last, secure function evaluation has been studied by \citet{Yao}, which
formalised Yao protocol in \easycrypt. This work also included a formalisation
of circuits.


\section{Discussion}
\label{sec:discussion}
\todo{Needs a semi-honest MPC protocol}
Throughout the work of this thesis we have used the \easycrypt\ proof assistant
to formally verify the proofs presented herein.
The work has been an iterative process between formulating a lemma and then
trying to prove it within \easycrypt. This process was then repeated until the
lemma would be formally proven. Consequently, \easycrypt\ has been a
instrumental part of the work formulated in this thesis. Moreover, the powerful
automation tools offered by \easycrypt\ has allowed us to discharge trivial
proofs, thus enabling us to spend more time working on the complex lemmas seen
within this thesis.

Overall, we feel that \easycrypt\ captures the models used by cryptographers
quite well; our formalisation of ZKBoo has a structure similar to that presented
in the original paper by \citet{zkboo}. This has enabled us to spend less time
formulating the protocol and the proof steps and more time on formalising
important security criteria.
This has been capacitated, in part, by \easycrypt\ \textit{pWhile} language for
implementing procedures. This language follow a structure closely resembling the
pseudo-code seen in cryptographic papers.

Ultimately, the tool offers the possibility of writing programs both in a
functional style and in an imperative style. It is, however, only programs
written in the imperative style that is allowed to make random choices.

Our main problems with using this tool has been the schism between computation
and perfect indistinguishability and the tools steep learning curve.

In particular \easycrypt\ offers its rPHL for proving procedures to be perfect
indistinguishable. If, however, computational indistinguishability is needed then
the rPHL logic cannot directly be used, and we instead have to deal with
adversaries comparing procedures.

This problem is part of a more general problem where \easycrypt\ in essence
offers two techniques for dealing with cryptographic proofs. The first is the
traditional adversaries game-hopping technique where we reason about an
adversary being able to break to security of the protocol. These adversaries can
then be used to construct new adversaries that can break the security of other protocols.
The other techniques observably indistinguishability with \easycrypt's rPHL
logic.
Both of these techniques are perfectly valid for proving security of
cryptographic protocols. However, at the time of writing this thesis it is not
clear to us how to formally prove the relation between the two techniques.
The schism became apparent in chapter \ref{ch:formal_zkboo} where the
adversarial-based security definitions of our commitment schemes did not conform
to our the goals needed to prove security in our $\Sigma$-Protocol formalisation.

The steep leaning curve is primarily caused by the lack of documentation of new
tactics. At the time of writing this thesis the last update to the \easycrypt\
reference manual \cite{ec_refman} was in 2018. Moreover, the deduction rules by
the different logics that \easycrypt\ provides are not documented anywhere, but
instead have to be found in the papers describing \textbf{CertiCrypt} which is
the Coq-based proof assistant antecedent to \easycrypt.

\section{Future work}
\label{sec:future_work}
In this thesis we have formalised $\Sigma$-Protocols and
commitment schemes that is applicable to larger cryptographic protocols, as show
by our formalisation of ZKBoo. However, various improvement has since been made to the
ZKBoo protocol. Notably, the ZB++ protocol, which offers a reduction to the
size of the zero-knowledge proof sent to the verify. Moreover, it also provides zero-knowledge
in a post-quantum context \cite{zkb++}. An interesting next step could,
therefore, be to use our existing formalisation of ZKBoo to formally verify the
improvements made by ZB++.

With our formalisation we have intentionally focused on the ZKBoo protocol in
isolation but in real applications it would be part of a larger tool chain.
Mainly, ZKBoo requires a circuit with a definable execution order to be secure.
In our formalisation we have assumed the input to be a circuit and defined an
execution order, but to complete the tool chain we would need a formalisation of
a procedure converting functions to circuits and a formal proof of the induced
execution order in section \ref{subsec:arith-representation} being semantic preserving.

Moreover we saw in section \ref{subsec:fiat-shamir} that there is a need for
formalising the rewinding lemma to reason about soundness of the Fiat-Shamir
transformation. Moreover, rewinding is a common technique for proving soundness
of zero-knowledge protocols. Formalising the rewinding lemma would then allows
us to reason about more general zero-knowledge protocols than the sub-class of
$\Sigma$-Protocol which we have explored in this thesis.

\section{Conclusion}
\label{sec:conclusion}

In this thesis we have successfully managed to develop a rich formalisation of
$\Sigma$-Protocols and commitment schemes, whilst reproducing some of the key results of
formalisation done in other proof assistant \cite{cryptoeprint:2019:1185,certicrypt_sigma}.
From this formalisation we have managed to take MPC-based zero-knowledge
compiler for general relations and managed to prove it to be secure in a formal
setting by using our formalisations of both $\Sigma$-Protocols and commitments
schemes. In doing so we showed how important details for achieving security is
often glossed over in cryptographic literature...

The main contributions of this work has been recreating key results form other
proof assistants and showing the workability of \easycrypt, whilst also showing
how our formalisation can be used to fuel future work by showing how it is
possible to prove security of a more complex cryptographic protocol.
Moreover, we have gained key insights into how \easycrypt works and how to
develop workable formalisations

Particular we have seen in section \ref{subsec:zkboo:sec} how important small
assumption are for security of implementations of cryptographic protocols. If
one procedures is allowed to observe the state of another running on the system
all proofs in the aforementioned section would not hold. These assumption are
often left out when discussing cryptographic protocol design, but are important
when reasoning about the security of the protocols when implemented in a
programming language.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
