\chapter{Reflections and Conclusion}
\label{sec:reflection_conclusion}

\section{Related Works}
\label{sec:related_works}
This work exists in the field of formal verification of cryptographic protocols.
Notably our work has been heavily influenced by similar formalisations
\cite{cryptoeprint:2019:1185,DBLP:journals/corr/MetereD17,certicrypt_sigma,zkcrypt,Yao}

\citet{cryptoeprint:2019:1185} managed to formalise both $\Sigma$-Protocols and
commitment schemes within Isabelle/CryptoHOL. Additionally, they have managed to
prove that commitment schemes can be build directly from $\Sigma$-Protocols.
Their formalisation of $\Sigma$-Protocols also include various concrete
instantiations.
The main difference between the results obtained in their work compared to our
has been the tool usage. Isabelle/CryptHOL is a tool similar to \easycrypt\ that
offers a higher-order logic for dealing with cryptographic game-based proofs.
The fundamental difference between the two tools is that Isabelle/CryptHOL
programs are written in a functional style, where as \easycrypt\ allows the user
to write programs in an imperative style. This ultimately leads to the same
understanding of programs as distribution transformers as discussed in chapter \ref{ch:EasyCrypt}.

Other formalisations of $\Sigma$-Protocols also exists. \citet{certicrypt_sigma}
successfully formalised $\Sigma$-Protocols with CertiCrypt. They work includes a
formalisation of $\Sigma$-Protocols where the relation is the pre-image of a
homomorphism with certain restrictions or a claw-free permutation. This has
allowed them to define and prove the security for a whole class of
$\Sigma$-Protocols. This result is similar to the one we achieved with out
formalisation of ZKBoo. ZKBoo, however, defines a more general class of
$\Sigma$-Protocols than the one defined in the paper.

Moreover, commitment schemes has been formalised in \easycrypt\ by
\citet{DBLP:journals/corr/MetereD17}. Their work differs from our by offering
less definitions of security, which we described the need for in chapter \ref{ch:formal_commitment}

Notable work also exists for formalising generalised zero-knowledge compilers.
\citet{zkcrypt} developed a fully verified zero-knowledge compiler in CertiCrypt
which uses the generalised Schnorr protocol to produce zero-knowledge proofs of
any relation defined by the pre-image of a group homomorphism, just like ZKBoo.
The generalised Schnorr protocol, however, is a fundamentally different protocol
than ZKBoo, in the sense that it does not use MPC or commitment scheme.

Last, secure function evaluation has been studied by \citet{Yao}, which
formalised Yao protocol in \easycrypt. This work also included a formalisation
of circuits.


\section{Discussion}
\label{sec:discussion}
For all of the work laid out in this thesis we have used the \easycrypt\ proof
assistant to formally verify all the proofs shown.

\easycrypt\ tries to capture the models in which cryptographers create and prove
protocols. For the most part we feel like \easycrypt\ has managed to capture
these models quite well both in its \textit{pWhile} language for implementing
protocols and its different logics for proving properties about programs.

The benefit of using an imperative language like \textit{pWhile} over a functional
language used by cryptographic proof assistants like Isabelle/CryptHOL is that most
cryptographic protocols are described in a pseudo-code mimicking imperative
languages. This makes it relatively easy to convert protocols described in
papers into \easycrypt\ implementations. This is clear from the code examples
provided in this thesis, which closely resemble the actual \easycrypt\
implementations whilst being relatively similar to the protocol descriptions
seen in cryptographic papers.

Ultimately, the tool offers the possibility of writing programs both in a
functional style and in an imperative style. It is, however, only programs
written in the imperative style that is allowed to make random choices.

Our main problems with using this tool has been the schism between computation
and perfect indistinguishability and the tools steep learning curve.

In particular \easycrypt\ offers its rPHL for proving procedures to be perfect
indistinguishable. If, however, computational indistinguishability is needed then
the rPHL logic cannot directly be used, and we instead have to deal with
adversaries comparing procedures.
% This is a completely sound method for dealing
% with indistinguishability of procedures. In \easycrypt, however, the technique
% of using an adversary to compare procedures then none of the tactics for dealing
% with procedures provided by \easycrypt\ can be used, unless all proofs are
% converted into adversarial games.

This problem is part of a more general problem where \easycrypt\ in essence
offers two techniques for dealing with cryptographic proofs. The first is the
traditional adversaries game-hopping technique where we reason about an
adversary being able to break to security of the protocol. These adversaries can
then be used to construct new adversaries that can break the security of other protocols.
The other techniques observably indistinguishability with \easycrypt's rPHL
logic.
Both of these techniques are perfectly valid for proving security of
cryptographic protocols. However, \easycrypt\ offers no support for relating the
two techniques. This became apparent in chapter \ref{ch:formal_zkboo} where the
adversarial-based security definitions of our commitment schemes did not conform
to our the goals needed to prove security in our $\Sigma$-Protocol formalisation.

The steep leaning curve is primarily caused by the lack of documentation of new
tactics. At the time of writing this thesis the last update to the \easycrypt\
reference manual \cite{ec_refman} was in 2018. Moreover, the deduction rules by
the different logics that \easycrypt\ provides are not documented anywhere, but
instead have to be found in the papers describing \textbf{CertiCrypt} which is
the Coq-based proof assistant antecedent to \easycrypt.

Overall, we believe that ...

\section{Future work}
\label{sec:future_work}
In this thesis we has created a formalisation and $\Sigma$-Protocols and
commitment schemes that is applicable to larger cryptographic protocols, as show
by our formalisation of ZKBoo. Various improvement has then been made to the
ZKBoo protocol to mainly reduce to proof size but also to provide zero-knowledge
in a post-quantum context \cite{zkb++}.

With our formalisation we have intentionally focused on the ZKBoo protocol in
isolation but in real applications it would be part of a larger tool chain.
Mainly, ZKBoo requires a circuit with a definable execution order to be secure.
In our formalisation we have assumed the input to be a circuit and defined an
execution order but to complete the tool chain we would need a formalisation of
a procedure converting functions to circuits and a formal proof of the induced
execution order in section \ref{subsec:arith-representation} being semantic preserving.

Moreover we saw in section \ref{subsec:fiat-shamir} that there is a need for
formalising the rewinding lemma to reason about soundness of the Fiat-Shamir
transformation. Moreover, rewinding is a common technique for proving soundness
of zero-knowledge protocols. Formalising the rewinding lemma would then allows
us to reason about be general zero-knowledge protocols than the sub-class of
$\Sigma$-Protocol which we have explored in this thesis.

% \todo{Prove connection between $\Sigma$ and pok or arg ZK}
% \todo{Commitment: connection between original and alternative definitions}

\section{Conclusion}
\label{sec:conclusion}

In this thesis we have successfully managed to develop a rich formalisation of
$\Sigma$-Protocols and commitment schemes, whilst reproducing some of the key results of
formalisation done in other proof assistant \cite{cryptoeprint:2019:1185,certicrypt_sigma}.
From this formalisation we have managed to take MPC-based zero-knowledge
compiler for general relations and managed to prove it to be secure in a formal
setting by using our formalisations of both $\Sigma$-Protocols and commitments
schemes. In doing so we showed how important details for achieving security is
often glossed over in cryptographic literature...

The main contributions of this work has been recreating key results form other
proof assistants and showing the workability of \easycrypt, whilst also showing
how our formalisation can be used to fuel future work by showing how it is
possible to prove security of a more complex cryptographic protocol.
Moreover, we have gained key insights into how \easycrypt works and how to
develop workable formalisations

Particular we have seen in section \ref{subsec:zkboo:sec} how important small
assumption are for security of implementations of cryptographic protocols. If
one procedures is allowed to observe the state of another running on the system
all proofs in the aforementioned section would not hold. These assumption are
often left out when discussing cryptographic protocol design, but are important
when reasoning about the security of the protocols when implemented in a
programming language.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
