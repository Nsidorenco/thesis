\chapter{Reflections and Conclusion}
\label{sec:reflection_conclusion}

\section{Related Work}
\label{sec:related_work}

This work exists in the field of formal verification of cryptographic protocols.
Notably our work has been heavily influenced by similar formalisations
\cite{cryptoeprint:2019:1185,DBLP:journals/corr/MetereD17,certicrypt_sigma,zkcrypt,Yao}

Sigma protocols has been done in a lesser extend in \easycrypt. Much of the same
work has been done in Isabelle/CryptHOL by \citeauthor{cryptoeprint:2019:1185}.

\citeauthor{certicrypt_sigma} formalised $\Sigma$-Protocols within CertiCrypt,
and proved the security of the $\Sigma^{\phi}$-Protocol, which proves knowledge
of the pre-image of a group homomorphism. ZKBoo protocol described in section
\ref{sec:zkboo} and the $\Sigma^{\phi}$-Protocol prove knowledge of the same
relation, but ZKBoo has reduced proof size? \todo{Examine differences}.

phi assumes the group homomorphism to be special?

\todo{Differences between the works}

Commitment schemes has been formalized in \easycrypt by
\citeauthor{DBLP:journals/corr/MetereD17}.

\todo{Differences between the works}

formalised general zero knowledge compilers have been explored, with some
notable work by \citeauthor{zkcrypt} and PINOCCIO.

\todo{Differences between the works}

\todo{SFE in EC, YAO}

\section{Discussion}
\label{sec:discussion}
For all of the work laid out in this thesis we have used the \easycrypt\ proof
assistant to formally verify all the proofs shown. By using \easycrypt\ we have
had to formulate our proofs ...

\easycrypt\ tries to capture the models in which cryptographers create and prove
protocols. For the most part we feel like \easycrypt has managed to capture
these models quite well both in its \textit{pWhile} language for implementing
protocols and its different logics for proving properties about programs.

The benefit of using an imperative language like \textit{pWhile} over a functional
language used by cryptographic proof assistants like Isabelle/CryptHOL is that most
cryptographic protocols are described in a pseudo-code mimicking imperative
languages. This makes it relatively easy to convert protocols described in
papers into \easycrypt\ implementations. This is clear from the code examples
provided in this thesis, which closely resemble the actual \easycrypt\
implementations whilst being relatively similar to the protocol descriptions
seen in cryptographic papers.

Ultimately, the tool offers the possibility of writing programs both in a
functional style and in an imperative style. It is, however, only programs
written in the imperative style that is allowed to make random choices.

We feel...

Our main problems with using this tool has been the schism between computation
and perfect indistinguishability and the tools steep learning curve.

In particular \easycrypt\ offers its rPHL for proving procedures to be perfect
indistinguishable. If, however, computational indistinguishability is need then
the rPHL logic cannot directly be used, and we instead have to deal with
adversaries comparing procedures. This is a completely sound method for dealing
with indistinguishability of procedures. In \easycrypt\ , however, the technique
of using an adversary to compare procedures then none of the tactics for dealing
with procedures provided by \easycrypt\ can be used, unless all proofs are
converted into adversarial games. \todo{rewrite}

The steep leaning curve is primarily caused by the lack of documentation of new
tactics. At the time of writing this thesis the last update to the \easycrypt\
reference manual \cite{ec_refman} was in 2018. Moreover, the deduction rules by
the different logics that \easycrypt\ provides are not documented anywhere, but
instead have to be found in the papers describing \textbf{CertiCrypt} which is
the Coq-based proof assistant antecedent to \easycrypt.

\todo{How has EC been to work with}
\todo{What is the future for cryptographers using EC}
% \todo{Documentation is lacking}
\todo{Possible code extraction?}
% \todo{Schism between perfect and computation distinguishably}

% \todo{Adversary based games are not always ideal}
% \todo{Not possible to swap order of verify in commitment if procedure}

% \todo{Functional vs imperative language for proof assistant?}
\todo{functions in EC are bound to theories not modules}

\section{Future work}
\label{sec:future_work}
In this thesis we has created a formalisation and $\Sigma$-Protocols and
commitment schemes that is applicable to larger cryptographic protocols, as show
by our formalisation of ZKBoo. Various improvement has then been made to the
ZKBoo protocol to mainly reduce to proof size but also to provide zero-knowledge
in a post-quantum context \cite{zkb++}.

With our formalisation we have intentionally focused on the ZKBoo protocol in
isolation but in real applications it would be part of a larger tool chain.
Mainly, ZKBoo requires a circuit with a definable execution order to be secure.
In our formalisation we have assumed the input to be a circuit and defined an
execution order but to complete the tool chain we would need a formalisation of
a procedure converting functions to circuits and a formal proof of the induced
execution order in section \ref{subsec:arith-representation} being semantic preserving.

Moreover we saw in section \ref{subsec:fiat-shamir} that there is a need for
formalising the rewinding lemma to reason about soundness of the Fiat-Shamir
transformation. Moreover, rewinding is a common technique for proving soundness
of zero-knowledge protocols. Formalising the rewinding lemma would then allows
us to reason about be general zero-knowledge protocols than the sub-class of
$\Sigma$-Protocol which we have explored in this thesis.

\todo{Prove connection between $\Sigma$ and pok or arg ZK}

\section{Conclusion}
\label{sec:conclusion}

In this thesis we have successfully managed to develop a rich formalisation of
$\Sigma$-Protocols and commitment schemes, whilst reproducing some of the key results of
formalisation done in other proof assistant \cite{cryptoeprint:2019:1185,certicrypt_sigma}.
From this formalisation we have managed to take MPC-based zero-knowledge
compiler for general relations and managed to prove it to be secure in a formal
setting by using our formalisations of both $\Sigma$-Protocols and commitments
schemes. In doing so we showed how important details for achieving security is
often glossed over in cryptographic literature...

The main contributions of this work has been recreating key results form other
proof assistants and showing the workability of \easycrypt, whilst also showing
how our formalisation can be used to fuel future work by showing how it is
possible to prove security of a more complex cryptographic protocol.
Moreover, we have gained key insights into how \easycrypt works and how to
develop workable formalisations

Particular we have seen in section \ref{subsec:zkboo:sec} how important small
assumption are for security of implementations of cryptographic protocols. If
one procedures is allowed to observe the state of another running on the system
all proofs in the aforementioned section would not hold. These assumption are
often left out when discussing cryptographic protocol design, but are important
when reasoning about the security of the protocols when implemented in a
programming language.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
