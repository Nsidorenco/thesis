\chapter{Background}
\label{ch:background}
This section aims to introduce some of the fundamental definitions and concepts
used throughout this thesis. This section will foremost give a rudimentary and
informal introduction, while the later chapters will provide more rigours
formalisations and proofs of security.
% First, we start by describing $\Sigma$-protocols, along with its security
% definitions and extensions.
%

\paragraph{Notations}

\section{Zero-knowlege}
\label{sec:background:zero-knowledge}
Zero-knowledge can be separated into two categories: \textit{arguments} and
\textit{proofs-of-knowledge}. We start by defining the former.

An Zero-knowledge argument is protocol run between an probabilistic polynomial
time (PPT) prover P and and a PPT verifier V. The prover and verifier then both
know a relation $R \subseteq \{0,1\}^{*} \times \{0,1\}^*$, which expresses a
computational problem. We refer to the first argument of the relation as $h$ and
to the second argument as $w$.
The goal of the protocol is then for P to convince V that we knows the pair
$(h,w)$ whilst only revealing $h$. At the end of the protocol the verifier will
then either output \textbf{accept}/\textbf{reject} based on whether P convinced
him or not.
We then require that the verifier following the protocol always output
\textbf{accept} if we P knew $(h,w)$ and followed the protocol. This is known as \textit{completeness}.
Moreover, we requires that that a cheating adversary who does not know $w$ can
only make the verifier output \textbf{accept} with some probability $\epsilon$.

The stronger variant of \textit{proofs-of-knowledge} shares the same definitions
as above, but require that the verifier only output \textbf{accept} if the
prover indeed knew the pair $(h,w)$.


Common amongst both variants is that the require that verifier learns no
information, whatsoever, about w. This is more formally defined as:

\begin{definition}[Zero-knowledge from \citet{on-sigma-protocols}]
  \label{def:zk}
  Any proof-of-knowledge or argument with parties (P,V) is said to be
  zero-knowledge if there for every PPT verifier V$^{*}$ there exists a
  simulator $\text{Sim}_{V^{*}}$ running in expected polynomial time can output a
  conversation indistinguishable from a real conversation between (P, V$^{*}$).
\end{definition}


\section{Sigma Protocols}
\label{sec:background:sigma_protocols}
Originally introduced by Cramer \todo{reference}, $\Sigma$-protocols are
two-party protocols with a three-move-form, based on a, computationally hard,
relation $R$, such that $(h, w) \in R$ if $h$ is an instance of a
computationally hard problem, and $w$ is the solution to $h$. $\Sigma$-protocols
then allows a prover, P, who knows the solution $w$, to convince a verify, V, of
the existence of $w$, without explicitly showing $w$ to him.


\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
      % \draw (-3,0) -- (-3,-3) (3,0) -- (3,-3);
      \node at (-3,.3) {Prover};
      \node at (-3,-.2) {$(h, w)$};
      \node at (3,.3) {Verifier};
      \node at (3,-.2) {$h$};
      \node at (-5,-1) {$Init(h, w) \rightarrow a$};
      \draw[->] (-3,-1) -- node[midway,above] {a} (3,-1);
      \draw[<-] (-3,-2) -- node[midway,above] {e} (3,-2);
      \node at (-5.75,-2) {$Response(h, w, a, e) \rightarrow z$};
      \draw[->] (-3,-3) -- node[midway,above] {z} (3,-3);
      \node at (5,-3) {$Verify(h,a,e,z)$};
  \end{tikzpicture}
  \caption{\label{fig:proto_sigma} $\Sigma$-Protocol}
\end{figure}


The following section aims to introduce the definition of $\Sigma$-protocols,
along with its notions of security. The following section is based on the
presentation of $\Sigma$-protocols by \citet{on-sigma-protocols}.

\todo{explain the flow of the protocol. what is a \dots}

\begin{definition}[$\Sigma$-Protocol Security]
\label{def:sigma:sec}
To prove security of a $\Sigma$-protocols, we require three properties, namely,
\textbf{Completeness}, \textbf{Special Soundness}, and \textbf{Special Honest Verifier Zero Knowledge (SHVZK)}.
\end{definition}

\todo{define honest}
\begin{definition}[Completeness]
  Assuming both P and V are honest then V will always output \textbf{accept} at
  the end of the protocol.
\end{definition}

\begin{definition}[Special Soundness]
Given a $\Sigma$-Protocol $S$ for some relation $R$ with public input $h$
and two any accepting transcripts $(a,e,z)$ and $(a,e',z')$
where both transcripts have the same initial message, $a$ and $e \neq e'$.

Then we say that $S$ satisfies $2$-special soundness if, there exists an
efficient algorithm, which we call the ``witness\_extractor'',
that given the two transcripts outputs a valid witness for the relation $R$.
\end{definition}

The special soundness property is important for ensuring that a cheating prover
cannot succeed. Given special soundness, if the protocol is run multiple times,
his advantage becomes negligible, since special soundness implies that there can
only exists one challenge, for any given message $a$, which can make the
protocol accept, without knowing the witness. Therefore, given a challenge space
with cardinality $c$, the probability of a cheating prover succeeding in
convincing the verifier is $\frac{1}{c}$. The protocol can then be run multiple
times, to ensure negligible probability.

Can also be generalised to $s$-Special Soundness, which requires that the
witness can be constructed, given $s$ accepting conversations.

\begin{definition}[SHVZK]
  A $\Sigma$-Protocol $S$ is said to be SHVZK if there exists a polynomial time
  simulator Sim which given instance $h$ and challenge $e$ as input produce a
  transcript $(a,e,z)$ indistinguishable from the transcript produced by $S$
\end{definition}

$\Sigma$-Protocols has the interesting property of being able to construct
zero-knowledge protocols from any secure $\Sigma$-Protocol in the random oracle
model with no additional computations. This effectively allows us to construct a
secure zero-knowledge protocol whilst only having the prove that the protocol is
zero-knowledge in the case of a honest verifier. This transformation from
$\Sigma$-Protocol to zero-knowledge protocol is known as the ``Fiat-Shamir''
transformation. More details about this transformation can be found in section
\ref{subsec:fiat-shamir}.
Moreover, it is possible to turn any $\Sigma$-Protocol into a zero-knowledge
argument with one additional round of communication between the Prover and
Verifier or a proof-of-knowledge with two extra rounds of communication without
assuming access to a random oracle \cite{on-sigma-protocols}.


\section{Commitment Schemes}
\label{sec:background:commitment}
Commitment schemes is another fundamental building block in cryptography, and
has a strong connection to $\Sigma$-Protocols where it is possible to construct
commitment schemes from $\Sigma$-Protocols \cite{cryptoeprint:2019:1185}. A commitment
schemes facilitates an interaction between two parties, P1 and P2, where P1
generates a commitment of a message, which he then sends to P2, without revealing
what his original message where. At a later point P1 can then send the message
to P2, who is then able to verify that P1 has not altered his message since
creating the commitment. More formally a commitment schemes is defined as:

\begin{definition}[Commitment Schemes]
A commitment schemes is a tuple of algorithms (Gen, Com, Ver), where:
\begin{itemize}
  \item $(ck, vk) \leftarrow Gen()$, provides key generation.
  \item $(c, d) \leftarrow Com(ck, m)$ generates a commitment $c$ of the message
    $m$ along with a opening key $d$, which can be revealed at a later time.
  \item $\{true, false\} \leftarrow Ver(vk, c, m, d)$ checked whether the
    commitment $c$ was generated from $m$ and opening key $d$.
\end{itemize}
\end{definition}

For a commitment schemes to be secure it is required to satisfy three
properties: \textbf{Correctness}, \textbf{Binding}, and \textbf{Hiding}.

\paragraph{Correctness}
A commitment scheme is said to be correct, if a commitment $(c, d)$ made by a
honest party will always be accepted by the verification procedure of another
party, i.e:
$$
Pr[Ver(vk, c, m, d) | (c, d) = Com(ck, m) \land (ck, vk) \leftarrow Gen()] = 1.
$$

\paragraph{Binding}
The binding property states that a party committing to a message will not be
able to successfully convince another party, that he has committed to another
message, i.e. $(c, d) \leftarrow Com(ck, m)$, will not be able to find an alternative opening key $d'$
and message $m'$ such that $(c, d') \leftarrow Com(ck, m')$.

\todo{write binding game}

\todo{Stat, perfect, comp variants}

\todo{All games parametrised by security param. Not used in formal definition}

\paragraph{Hiding}
The Hiding property states that a party given a commitment $c$, will not be able
to extract the message $m$, which the commitment was based on.

\section{Multi-Part Computation (MPC)}
\label{sec:background:mpc}
Consider the problem, where $n$ parties, called $P_{1}, \dots, p_{n}$, with
corresponding input values $\textbf{x} = x_{1}, \dots, x_{n}$ want to compute a commonly
known function, $f : (\text{input})^{n} \rightarrow \text{output}$, such that
every party agrees on the same output $y$, such that $y = f(\textbf{x})$, but none of them learns the inputs to function, barring their own.

\todo{Different notions of security. We need passive.}

This is the exact problem that MPC aims to solve.

\begin{definition}[Correctness]
\label{def:mpc:correctness}

\end{definition}

\begin{definition}[d-Privacy]
\label{def:mpc:d-privacy}

\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
