\chapter{Background}
\label{ch:background}
This chapter aims to introduce the fields of cryptography needed for this
thesis.
Most of these fields have very intricate security definitions which depend on the
context.
We, therefore, do not try to give a complete introduction to the fields.
Instead, we limit our introduction to the specific definitions relevant to the work of this thesis.

Notably, the section about multi-part computations (MPC) is intentionally left brief. The
cryptographic field of MPC has lots of intricate security definitions
depends on who is allowed to participate in the protocols. For our purposes, we
need a specific definition of security, where we assume all parties
adhere to the protocol description.

Additionally, in cryptography, it is common practice to quantify every security
definition over a ``security parameter''. This parameter exists to define how
hard specific computation problems should be. Consider, for example, the discrete
logarithm problem in a cyclic group. Naturally, the larger the group is,
the harder the problem is to solve since there is a larger set of potential solutions. The
security parameter would, in this case, be the size of the group.
The existence of the security parameter usually offers a trade-off between
security and efficiency. Considering the previous example for the discrete
logarithm; any protocol operating on a group will have arithmetic operations
with running time proportional to the size of the group. Therefore, the smaller
the group, the faster the protocol is to run in practice.

The security parameter, however, is usually left implicit, which we have also
done in the definitions below.

\paragraph{Notations}
While this thesis has been performed entirely in easycrypt, the code in this
thesis will be given in a more pseudo-code style to make it more general. For
the most part, we will avoid easycrypt specific notation when writing procedures
and solely focus on what tools easycrypt provides us with for proving
procedures.

Most notably we adopt the list indexing notation of $l[0]$ to mean the 0'th
index of the list $l$. Formally this notation is not sound since it does not
specify what will happen if the index not exists. The is solved in \easycrypt\
by declaring a default element to return, should the indexing fail. We omit 
the default value from our code examples.
Moreover, we define $x::xs$ to mean that we prepend $x$ to the list $xs$,
$l_{1} ++ l_{2}$ means we concatenate two lists, and $rcons \; x \; xs$ means we
append x to the list $xs$.

Lastly, when referring to indistinguishability, we are referring the perfect
indistinguishability unless stated otherwise.

\section{Zero-knowledge}
\label{sec:background:zero-knowledge}
Zero-knowledge can be separated into two categories: \textit{arguments} and
\textit{proofs-of-knowledge}. We start by defining the former.

A Zero-knowledge argument is a protocol run between a probabilistic polynomial
time (PPT) prover P and a PPT verifier V. The prover and verifier then both
know a relation $R \subseteq \{0,1\}^{*} \times \{0,1\}^*$, which expresses a
computational problem. We refer to the first argument of the relation as $h$ and
to the second argument as $w$.
The goal of the protocol is then for P to convince V that he knows the pair
$(h,w)$ while only revealing $h$. At the end of the protocol, the verifier will
then either output \textbf{accept}/\textbf{reject} based on whether P convinced
him or not.
We then require that the verifier following the protocol always output
\textbf{accept} if P knew $(h,w)$ and followed the protocol. This is known as \textit{correctness}.
Moreover, we require that a cheating adversary who does not know $w$ can
only make the verifier output \textbf{accept} with some probability $\epsilon$.

\textit{Proofs-of-knowledge} shares the same definitions
as above, but require that the verifier only output \textbf{accept} if the
prover indeed knew the pair $(h,w)$.


Common amongst both variants is that they require that verifier learns no
information, whatsoever, about w:

\begin{definition}[Zero-knowledge from \citet{on-sigma-protocols}]
  \label{def:zk}
  Any proof-of-knowledge or argument with parties (P, V) is said to be
  zero-knowledge if for every PPT verifier V$^{*}$ there exists a
  simulator $\text{Sim}_{V^{*}}$ running in expected polynomial time can output a
  conversation indistinguishable from a real conversation between (P, V$^{*}$).
\end{definition}


\section{Sigma Protocols}
\label{sec:background:sigma_protocols}
The following section aims to introduce the definition of $\Sigma$-protocols,
along with its notions of security. The following section is based on the
presentation of $\Sigma$-protocols by \citet{on-sigma-protocols}.
$\Sigma$-protocols are two-party protocols on a three-move-form, based on a,
computationally hard, relation $R$, such that $(h, w) \in R$ if $h$ is an
instance of a computationally hard problem, and $w$ is the solution to $h$.
This relation can also be expressed as a function, such that
$(h,w) \in \text{R} \iff \text{R}_{f} \; h \; w = 1$.
$\Sigma$-protocols allows a prover, P, who knows the solution $w$, to convince a
verify, V, of the existence of $w$, without revealing $w$ to him.


\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
      % \draw (-3,0) -- (-3,-3) (3,0) -- (3,-3);
      \node at (-3,.3) {Prover};
      \node at (-3,-.2) {$(h, w)$};
      \node at (3,.3) {Verifier};
      \node at (3,-.2) {$h$};
      \node at (-5,-1) {$Init(h, w) \rightarrow a$};
      \draw[->] (-3,-1) -- node[midway,above] {a} (3,-1);
      \draw[<-] (-3,-2) -- node[midway,above] {e} (3,-2);
      \node at (-5.75,-2) {$Response(h, w, a, e) \rightarrow z$};
      \draw[->] (-3,-3) -- node[midway,above] {z} (3,-3);
      \node at (5,-3) {$Verify(h,a,e,z)$};
  \end{tikzpicture}
  \caption{\label{fig:proto_sigma} $\Sigma$-Protocol}
\end{figure}

A general overview of a $\Sigma$-Protocol can be seen in figure
\ref{fig:proto_sigma}. Here we note that the protocol is on a three-move form
since only three messages, $(a,e,z)$, are sent between the prover and the verifier.

\begin{definition}[$\Sigma$-Protocol Security]
\label{def:sigma:sec}
To prove the security of a $\Sigma$-protocols, we require three properties, namely,
\textbf{Completeness}, \textbf{Special Soundness}, and \textbf{Special Honest Verifier Zero-Knowledge (SHVZK)}.
\end{definition}

\begin{definition}[Completeness]
  Assuming both P and V are honest \ie following the protocol, then V will always \textbf{accept} at
  the end of the protocol.
\end{definition}

\begin{definition}[Special Soundness]
Given a $\Sigma$-Protocol $S$ for some relation $R$ with public input $h$
and two any accepting transcripts $(a,e,z)$ and $(a,e',z')$
where both transcripts have the same initial message, $a$ and $e \neq e'$.

Then we say that $S$ satisfies $2$-special soundness if, there exists an
efficient algorithm, which we call the ``witness extractor'',
that given the two transcripts outputs a valid witness for the relation $R$.
\end{definition}

The special soundness property is important for ensuring that a cheating prover
cannot succeed. Given special soundness, and the protocol is run multiple times,
his advantage becomes negligible since special soundness implies that there can
only exist one challenge, for any given message $a$, which can make the
protocol accept, without knowing the witness. Therefore, given a challenge space
with cardinality $c$ the probability of a cheating prover succeeding in
convincing the verifier is $\frac{1}{c}$. The protocol can then be run multiple
times to ensure negligible probability.

Can also be generalised to $s$-Special Soundness, which requires that the
witness can be constructed, given $s$ accepting conversations.

\begin{definition}[SHVZK]
  A $\Sigma$-Protocol $S$ is said to be SHVZK if there exists a polynomial-time
  simulator Sim which given instance $h$ and challenge $e$ as input produces a
  transcript $(a,e,z)$ indistinguishable from the transcript produced by $S$
\end{definition}

$\Sigma$-Protocols have the convenient property of being able to construct
zero-knowledge protocols from any secure $\Sigma$-Protocol in the random oracle
model with no additional computations. This effectively allows us to construct a
secure zero-knowledge protocol while only having to prove that the protocol is
zero-knowledge in the case of an honest verifier. This transformation from
$\Sigma$-Protocol to zero-knowledge protocol is known as the ``Fiat-Shamir
transformation''. More details about this transformation can be found in section
\ref{subsec:fiat-shamir}.
Moreover, it is possible to turn any $\Sigma$-Protocol into a zero-knowledge
argument with one additional round of communication between the Prover and
Verifier or a proof-of-knowledge with two extra rounds of communication without
assuming access to a random oracle \cite{on-sigma-protocols}.


\section{Commitment Schemes}
\label{sec:background:commitment}
Commitment schemes is another fundamental building block in cryptography, and
has a strong connection to $\Sigma$-Protocols where it is possible to construct
commitment schemes from $\Sigma$-Protocols \cite{cryptoeprint:2019:1185}. A commitment
scheme facilitates interaction between two parties, C and V, where C
generates a commitment of a message, which he then sends to V, without revealing
what his original message where. At a later point, C can then send the message
to V, who is then able to verify that C has not altered his message since
creating the commitment. More formally, a commitment scheme is defined as:

\begin{definition}[Commitment Schemes]
A commitment scheme is a tuple of algorithms (Gen, Com, Ver), where:
\begin{itemize}
  \item $(ck, vk) \leftarrow Gen()$, provides key generation.
  \item $(c, d) \leftarrow Com(ck, m)$ generates a commitment $c$ of the message
    $m$ along with an opening key $d$ which can be revealed at a later time.
  \item $\{true, false\} \leftarrow Ver(vk, c, m, d)$ checked whether the
    commitment $c$ was generated from $m$ and opening key $d$.
\end{itemize}
\end{definition}

For commitment schemes to be secure; it is required to satisfy three
properties: \textbf{Correctness}, \textbf{Binding}, and \textbf{Hiding}.

\begin{definition}[Informal correctness]
  A commitment scheme is said to be correct if
  the verification procedure  will always accept a commitment made by an honest party,
 \ie
$$
Pr[Ver(vk, c, m, d) | (c, d) = Com(ck, m) \land (ck, vk) \leftarrow Gen()] = 1.
$$
\end{definition}

\begin{definition}[Informal binding]
The binding property states that a party committing to a message will not be
able to successfully convince another party, that he has committed to different
from the original message, \ie $(c, d) \leftarrow Com(ck, m)$, will not be able
to find an alternative opening key $d'$ and message $m'$ such that
$(c, d') \leftarrow Com(ck, m')$.

The scheme is said to have \textit{perfect binding} if it is impossible to change the
opening.
\textit{statistical binding} is achieved if there is a negligible probability of changing
the opening and \textit{computation binding} if producing a valid opening to a
different message is equivalent to a hard computation problem.
\end{definition}

\begin{definition}[Informal hiding]
The Hiding property states that a party given a commitment $c$ will not be able
to guess the message $m$ on which the commitment was based.

The scheme is said to have \textit{perfect hiding} if it is impossible to
distinguish two commitment of different messages from each other,
\textit{statistical hiding} if there is a negligible probability of
distinguishing the commitments and \textit{computational hiding} if
distinguishing the commitments is equivalent to a hard computational problem.
\end{definition}


\section{Multi-Part Computation (MPC)}
\label{sec:background:mpc}
Consider the problem with $n$ parties, called $P_{1}, \dots, p_{n}$, with
corresponding input values $\textbf{x} = x_{1}, \dots, x_{n}$ where the parties
are allowed to communicate with each other over a secure channel freely.
The parties then want to compute a public function,
$f : (\text{input})^{n} \rightarrow \text{output}$, where each party contribute
their input to the function and every party agrees on the same output
$y$, such that $y = f(\textbf{x})$, but none of them learns the inputs to
function, barring their own.

To achieve this, the parties jointly run an MPC protocol $\Phi_{f}$. This protocol
is defined in the term of rounds.
In each round, each party $P_{i}$ computes a
value with a deterministic function of all previously observed messages.
The party then either sends the value to another party or broadcasts it to everyone.
We define the collection of
computed values and received values as $\text{view}_{i}$.

Once all rounds of the protocol have been completed, the output values $y$ can be
directly computed based on $\text{view}_{i}$.

\todo{Yao's millionaire problem as primer?}

\begin{definition}[informal correctness]
  \label{def:mpc:correctness}
  An MPC protocol $\Phi_{f}$ computing a function $f$ is said to have perfect
  correctness if $f(x) = \Phi_{f}(x)$ for all x.
\end{definition}

\begin{definition}[d-Privacy]
\label{def:mpc:d-privacy}
  An MPC protocol $Phi_{f}$ is said to have $d$-privacy if $d$ parties colluding
  cannot about information about any of other $n-d$ private inputs.

  More formally, the protocol has $d$-privacy if it is possible to define a
  simulator $S_{A}$ which is given access to the output of the protocol,
  producing views that are indistinguishable from the views of the $d$ colluding
  parties.
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
