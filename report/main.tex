% \documentclass[twoside,11pt,openright]{report}
\documentclass[ twoside,openright,titlepage,numbers=noenddot,headinclude,%1headlines,% letterpaper a4paper
                footinclude=true,cleardoublepage=empty,abstractoff, % <--- obsolete, remove (todo)
                BCOR=5mm,paper=a4,fontsize=11pt,%11pt,a4paper,%
                ngerman,british,%
                ]{scrreprt}
\PassOptionsToPackage{eulerchapternumbers,listings,
                      pdfspacing,%floatperchapter,
                      % linedheaders,%
                      subfig,beramono
                      % ,eulermath
                    }{classicthesis}
\usepackage{classicthesis}

\usepackage[left=1.7in,right=1.2in,top=1in,bottom=1in]{geometry}% \setlength{\marginparwidth}{1em}%

\usepackage{textcomp} % fix warning with missing font shapes
\usepackage{scrhack} % fix warnings when using KOMA with listings package
\usepackage{xspace} % to get the spacing after macros right
\usepackage{mparhack} % get marginpar right
\usepackage{fixltx2e} % fixes some LaTeX stuff --> since 2015 in the LaTeX kernel (see below)

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[american]{babel}
% \usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{epsfig}
\usepackage{mathptmx}
\usepackage{color}
\usepackage{epstopdf}
% \usepackage{microtype}
\usepackage{hyperref}
\usepackage{ragged2e}

\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt,
citestyle=alphabetic
]{biblatex}
\addbibresource{refs.bib}

\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
% \usepackage{lipsum}
% \usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{matrix,backgrounds}
\usepackage{lstautogobble}
\usepackage{subcaption}


\usepackage{amsthm}                                % Theorem package
\theoremstyle{definition}                          % plain, definition, remark
\renewcommand*{\proofname}{Proof}


\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}
\newcommand{\easycrypt}{\texttt{EasyCrypt}}
\newcommand{\validviews}[1]{\textbf{Valid}$(#1)$}
\newcommand{\indis}[1]{{=}\!\{#1\}}
\newenvironment{draft}{\color{red}}{\ignorespacesafterend}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}

\newcommand{\ie}{i.\,e.}
\newcommand{\Ie}{I.\,e.}
\newcommand{\eg}{e.\,g.}
\newcommand{\Eg}{E.\,g.}

\newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

\newcommand{\decomp}{\mathcal{D}}
\newcommand{\view}{\textbf{w}}
\newcommand{\tape}{\textbf{k}}
\DeclarePairedDelimiter{\Prfences}{[}{]}
\renewcommand{\Pr}{\operatorname{Pr}\Prfences}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{aublue}{HTML}{193b77}

\lstset{
  morecomment=[s]{(*}{*)},
  morecomment=[n]{(*}{*)},
  keywordstyle=\color{RoyalBlue},%\bfseries,
  basicstyle=\small\ttfamily,
  commentstyle=\color{Green}\ttfamily,
  stringstyle=\rmfamily,
  numbers=none,%left,%
  numberstyle=\scriptsize,%\tiny
  stepnumber=5,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  %frameround=ftff,
  belowcaptionskip=.75\baselineskip,
  %frame=L
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  % firstnumber=1000,                % start line enumeration with line 1000
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  % language=Octave,                 % the language of the code
  morekeywords={*,module,type,proc,Pr,equiv,hoare,lemma,forall, phoare,
    res,op,with,let,in,require,const,var,return,pred,None,Some,clone,export,as,realize,by,split,theory,import,local},            % if you want to add more keywords to the set
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showtabs=false,                  % show tabs within strings adding particular underscores
  tabsize=2,	                   % sets default tabsize to 2 spaces
  % title=\lstname                   % show the filename of files included with
  % \lstinputlisting; also try caption instead of title
}
\newcommand{\myTitle}{Formalising Sigma-Protocols and Commitment Schemes using EasyCrypt\xspace}
\newcommand{\mySubtitle}{A Guide for Content \& Style\xspace}
\newcommand{\myDegree}{Master's Thesis\xspace}
\newcommand{\myName}{Nikolaj Sidorenco\xspace}
\newcommand{\myStudentId}{201504729\xspace}
\newcommand{\myProf}{Bas Spitters\xspace}
\newcommand{\myOtherProf}{Sabine Oechsner\xspace}
\newcommand{\myFaculty}{Natural Sciences\xspace}
\newcommand{\myDepartment}{Department of Computer Science\xspace}
\newcommand{\myUni}{Aarhus University\xspace}
\newcommand{\myLocation}{Aarhus\xspace}
\newcommand{\myTime}{\monthname\ \the\year\xspace}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%*******************************************************
\pagestyle{empty}
\pagenumbering{roman}
\vspace*{\fill}\noindent{\color{aublue}\rule{\linewidth}{1mm}\\[4ex]\color{black}
  \begin{RaggedRight}
\Large \spacedallcaps \myTitle\\ \vspace*{1.5em}
% \large \spacedallcaps \mySubtitle\\ \vspace*{3em}
\end{RaggedRight}
{\noindent\Large \spacedlowsmallcaps \myName, \myStudentId }\\[1ex]
\noindent\color{aublue}\rule{\linewidth}{1mm}\\[4ex]\color{black}
\noindent{\large \spacedlowsmallcaps \myDegree\\[1ex]
June \the\year  \\[1ex] Advisor: \myProf\\[1ex] Co-advisor: \myOtherProf \\[23ex]}\\[\fill]}
\includegraphics[width=\linewidth]{logo}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}
When applying cryptographic protocols in important applications, it is paramount
that we can trust them to work as specified. However, many cryptographic proofs
apply informal reasoning and implicit knowledge. Moreover,
cryptographic proofs can become so complex that they are considered
unverifiable.

Advances in formal reasoning of cryptographic protocols have provided a methodology
for constructing more rigours proofs which can eliminate informal reasoning.
Moreover, formal reasoning allows us to construct machine-verifiable proofs.

In this thesis, we use the EasyCrypt proof assistant to formally reason about two
cryptographic primitives; Commitment Schemes and $\Sigma$-Protocols.
First, we consider Commitment Schemes, which allows a
Committer to bind himself to a chosen message. The Committer can then later
reveal the message to a Verifier, which can be ensured that the
message revealed is the same as the one the Committer bound himself to earlier.

Next, we consider $\Sigma$-Protocols, which allows a Prover to convince a
Verifier, that he knows some secret without ever revealing the secret to
the Verifier.
To formalise these two primitives, we reproduce the results of previous
formalisations to develop abstract specifications, which can be used to
instantiate secure concrete protocols.
In addition to the abstract specifiction of $\Sigma$-Protocols, we formalise compound $\Sigma$-Protocol, which
allows us to combine $\Sigma$-Protocols.
We then show the workability of our formalisation by instantiating
Pedersen's Commitment Schemes and Schnorr's $\Sigma$-Protocol.

Using the formalisations of $\Sigma$-Protocols and Commitment schemes we
formalise the ZKBoo protocol, which is a generalised $\Sigma$-Protocol, based on Multi-Part
Computations, for proven knowledge of the pre-image of any group homomorphism.
In formalising ZKBoo we successfully formalised arithmetic circuits and an MPC
protocol on arithmetic circuits called the (2,3)-Decomposition.
We then use our abstract specifications to prove ZKBoo to be a secure $\Sigma$-Protocol.
With this work, we show the discrepancy between the security proofs in
cryptographic papers compared to the reasoning required to prove a protocol
secure in the formal context.

A highlight of our formalisation is the security proofs of ZKBoo. Here we show
how that it is possible to formally verify a cryptographic research paper with
no prior knowledge of \easycrypt.

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

Når kryptografiske protokoller anvendes i kritiske applikationer, så er det
altoverskyggende, at vi kan stole på protokollere til at opføre sig som
forventet.
Dog er mange kryptografiske beviser baseret på informelle argumenter og implicit
ekspertviden. Derudover, er mange kryptografiske beviser blevet så komplekse,
at de anses for umulige at verificere.

Gennembrud indenfor formel verifikation af kryptografiske protokoller har dog
muliggjort en ny metodologi, hvor vi kan konstruerer stringente beviser, som er
maskinelt verificerbare.

I dette speciale anvender vi værktøjet EasyCrypt til formelt at beskrive two
kryptografiske primitiver: ``Commitment Schemes'' og $\Sigma$-Protokoller.

``Commitment Schemes'' tillader en bruger, kaldet ``Committer'', at binde sig
selv til en besked overfor en anden bruger. Denne bruger lærer dog intet om den
beskeden. ``Committer'' kan så på et senere tidspunkt afslører beskeden overfor
den anden bruger. Den anden bruger kan herefter så kan bekræfte at beskeden der blev afsløret er
den samme som den ``Committer'' bandt sig selv til tidligere.

$\Sigma$-Protokoller tillader en bruger, kaldet ``Prover'', at overbevise en
andet bruger, at han kender til en hemmelighed $x$, dog uden at afsløre nogen
information omkring $x$.

For at formalisere disse primitiver baserer vi vores arbejde på tidligere
formaliseringer, lavet i andre værktøjer. Ud fra disse formalisering udvikler vi
abstrakte specifikationer af, hvad disse primitiver gør.
Derudover viser vi også, hvordan man formelt kan sammensætte flere sikre
$\Sigma$-Protokoller, uden at formindske sikkerheden.
Dernæst viser vi anvendeligheden af vores formalisering ved at bevise
Pedersens Commitment Scheme og Schnorr's $\Sigma$-Protokol.

Til sidst anvender vi vores formaliseringer af de to primitiver til, at vise
sikkerheden af ``ZKBoo'' protokollen. Denne protokol er en generaliseret
$\Sigma$-Protokol, som er baseret på Multi-Party Computation. Denne protokol kan
bevise kendskab til alle hemmelighed, der kan udtrykkes som definitionsmængden
af en gruppe homomorfi.

Ved at udforske ``ZKBoo'' lykkes det os, at formalisere aritmetiske kredsløb
samt (2,3)-nedbrydningen af disse. En (2,3)-nedbrydningen er en speciel klasse
af Multi-Party Computation protokoller.

Med dette arbejde viser vi, hvordan formel verifikation kan bruges til at ydre
højere sikkerhed af kryptografiske protokoller. Derudover, så viser vi også, hvordan det mere informelle format brugt i kryptografisk forskning ofte kan
undlade vigtige elementer, som kan bryde med sikkerheden.

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo{\dots}

\vspace{2ex}
\begin{flushright}
  \emph{Nikolaj Sidorenco,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{sections/introduction.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{sections/easycrypt.tex}

\input{sections/background.tex}

\input{sections/formal_commitment.tex}

\input{sections/formal_sigma.tex}

\input{sections/general_zk.tex}

\input{sections/formal_zkboo.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{sections/conclusion.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
% \input{sections/appendix.tex}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
