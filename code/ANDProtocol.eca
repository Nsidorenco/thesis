(* Formalization of Sigma Protocols *)
require import AllCore Distr DBool.

require SigmaProtocols.

(** Ignore: This is now the preferred setup but is not yet the default **)
pragma -oldip. pragma +implicits.

type statement1.
type statement2.
type witness1.
type witness2.
type message1.
type message2.
type randomness.
type challenge.
type response1.
type response2.

type statement = (statement1 * statement2).
type message = (message1 * message2).
type witness = (witness1 * witness2).
type response = (response1  * response2).

type transcript = message * challenge * response.

(* define the relations *)
op R1 (x : statement1, w : witness1) : bool.
op R2 (x : statement2, w : witness2) : bool.
op R = fun x w => (R1 (fst x) (fst w)) /\ (R2 (snd x) (snd w)).

op dchallenge : {challenge distr | is_lossless dchallenge /\ is_funiform dchallenge} as dchallenge_llfuni.

op (^^) (c1 : challenge, c2 : challenge) : challenge.
axiom xorK x c1 : (x ^^ c1) ^^ c1 = x.
axiom xorA x y : x ^^ y = y ^^ x.

clone SigmaProtocols as S1 with
  type SigmaProtocols.statement <- statement1,
  type SigmaProtocols.witness <- witness1,
  type SigmaProtocols.message <- message1,
  type SigmaProtocols.randomness <- randomness,
  type SigmaProtocols.challenge <- challenge,
  type SigmaProtocols.response <- response1,

  op SigmaProtocols.R = R1,
  op SigmaProtocols.dchallenge = dchallenge
  proof *.
  realize SigmaProtocols.dchallenge_llfuni by apply dchallenge_llfuni.

clone SigmaProtocols as S2 with
  type SigmaProtocols.statement <- statement2,
  type SigmaProtocols.witness <- witness2,
  type SigmaProtocols.message <- message2,
  type SigmaProtocols.randomness <- randomness,
  type SigmaProtocols.challenge <- challenge,
  type SigmaProtocols.response <- response2,

  op SigmaProtocols.R = R2,
  op SigmaProtocols.dchallenge = dchallenge
  proof *.
  realize SigmaProtocols.dchallenge_llfuni by apply dchallenge_llfuni.

clone SigmaProtocols as Sigma with
  type SigmaProtocols.statement <- (statement1 * statement2),
  type SigmaProtocols.witness <- witness,
  type SigmaProtocols.message <- message,
  type SigmaProtocols.randomness <- randomness * randomness,
  type SigmaProtocols.challenge <- challenge,
  type SigmaProtocols.response <- response,

  op SigmaProtocols.R = R,
  op SigmaProtocols.dchallenge = dchallenge
  proof *.
  realize SigmaProtocols.dchallenge_llfuni by apply dchallenge_llfuni.
export Sigma.


module ANDProtocol (P1 : S1.SigmaProtocols.SProtocol, P2 : S2.SigmaProtocols.SProtocol) : Sigma.SigmaProtocols.SProtocol = {
  proc gen() : statement * witness = {
    var h1, h2, w1, w2;
    (h1, w1) = P1.gen();
    (h2, w2) = P2.gen();
    return ((h1, h2), (w1, w2));
  }

  proc init(h : statement, w : witness) = {
    var h1, h2, r1, r2, w1, w2, a1, a2;
    (h1, h2) = h;
    (w1, w2) = w;

    (a1, r1) = P1.init(h1, w1);
    (a2, r2) = P2.init(h2, w2);
    return ((a1, a2), (r1, r2));
  }

  proc response(h : statement, w : witness, m : message, r : (randomness * randomness), e : challenge) : response = {
    var m1, m2, h1, h2, w1, w2, r1, r2, z1, z2;
    (m1, m2) = m;
    (h1, h2) = h;
    (w1, w2) = w;
    (r1, r2) = r;

    z1 = P1.response(h1, w1, m1, r1, e);
    z2 = P2.response(h2, w2, m2, r2, e);
    return (z1, z2);
  }

  proc verify(h : statement, m : message, e : challenge, z : response) : bool = {
    var h1, h2, m1, m2, z1, z2, v, v';
    (h1, h2) = h;
    (m1, m2) = m;
    (z1, z2) = z;

    v = P1.verify(h1, m1, e, z1);
    v' = P2.verify(h2, m2, e, z2);

    return (v /\ v');

  }

  proc witness_extractor(h : statement, m : message,
                          e : challenge, e' : challenge,
                          z : response, z' : response) = {
    var h', w;
    (h', w) = gen();
    return w;
  }

  proc simulator(h : statement, c : challenge) : message * response = {
    var h1, h2, a1, a2, z1, z2;
    (h1, h2) = h;

    (a1, z1) = P1.simulator(h1, c);
    (a2, z2) = P2.simulator(h2, c);

    return ((a1, a2), (z1, z2));
  }

}.
section Security.
declare module SP1 : S1.SigmaProtocols.SProtocol{ANDProtocol}.
declare module SP2 : S2.SigmaProtocols.SProtocol{ANDProtocol,SP1}.

axiom lossless_sp1_init : islossless SP1.init.
axiom lossless_sp1_response : islossless SP1.response.
axiom lossless_sp1_verify : islossless SP1.verify.
axiom lossless_sp2_init : islossless SP2.init.
axiom lossless_sp2_response : islossless SP2.response.
axiom lossless_sp2_verify : islossless SP2.verify.

local module C1 = S1.SigmaProtocols.Completeness(SP1).
local module C2 = S2.SigmaProtocols.Completeness(SP2).

local module SHVZK1 = S1.SigmaProtocols.SHVZK(SP1).
local module SHVZK2 = S2.SigmaProtocols.SHVZK(SP2).

axiom completeness_protocol1 h w &m : (R1 h w) => Pr[S1.SigmaProtocols.Completeness(SP1).main(h, w) @ &m : res] = 1%r.
axiom completeness_protocol2 h w &m : (R2 h w) => Pr[S2.SigmaProtocols.Completeness(SP2).main(h, w) @ &m : res] = 1%r.

axiom shvzk1_equiv h' w':
  equiv[S1.SigmaProtocols.SHVZK(SP1).real ~ S1.SigmaProtocols.SHVZK(SP1).ideal : (={h} /\ h{2} = h' /\ w{1} = w' /\ (R1 h' w')) ==> ={res}].
axiom shvzk2_equiv h' w':
  equiv[S2.SigmaProtocols.SHVZK(SP2).real ~ S2.SigmaProtocols.SHVZK(SP2).ideal : (={h} /\ h{2} = h' /\ w{1} = w' /\ (R2 h' w')) ==> ={res}].

local lemma shvzk1_equiv_pr h' w' &m:
    (R1 h' w') =>
    Pr[S1.SigmaProtocols.SHVZK(SP1).real(h', w') @ &m : (res <> None)] =
    Pr[S1.SigmaProtocols.SHVZK(SP1).ideal(h') @ &m : (res <> None)].
proof. move=>rel.
by byequiv (shvzk1_equiv h' w'). qed.

(* local lemma shvzk1_ideal_never_fails_pr h' &m: *)
(*     Pr[S1.SigmaProtocols.SHVZK(SP1).ideal(h') @ &m : (res <> None)] = 1%r. *)
(* proof. *)
(*    have eq := (shvzk1_equiv h'). *)
(*    have H := (completeness_protocol1 h'). *)


(* local lemma shvzk1_ideal_completeness h' w' &m: *)
(*     Pr[S1.SigmaProtocols.SHVZK(SP1).ideal(h') @ &m : (res <> None)] = *)
(*     Pr[C1.main(h', w') @ &m : res]. *)
(* proof. have H := (shvzk1 h' w' &m). *)
(*   rewrite -H. *)
(*   have -> := (S1.SigmaProtocols.shvzk_real_never_fail SP1 h' w' &m). *)
(*   byequiv=>//. proc. sim. qed. *)

(* NOTE: proof idea... *)
(* Pr[ideal] = (forall w, (R h w), Pr[real])*)

axiom shvzk1_ideal_never_fails_pr h' &m:
    Pr[S1.SigmaProtocols.SHVZK(SP1).ideal(h') @ &m : (res <> None)] = 1%r.
axiom shvzk2_ideal_never_fails_pr h' &m:
    Pr[S2.SigmaProtocols.SHVZK(SP2).ideal(h') @ &m : (res <> None)] = 1%r.

local lemma shvzk1_ideal_never_fails h':
      phoare[S1.SigmaProtocols.SHVZK(SP1).ideal : (h = h') ==> (res <> None)] = 1%r.
proof. have H := (shvzk1_ideal_never_fails_pr h'). bypr. progress. apply (H &m). qed.

local lemma shvzk2_ideal_never_fails h':
      phoare[S2.SigmaProtocols.SHVZK(SP2).ideal : (h = h') ==> (res <> None)] = 1%r.
proof. have H := (shvzk2_ideal_never_fails_pr h'). bypr. progress. apply (H &m). qed.

local lemma shvzk1_real_never_fails h' w':
      phoare[S1.SigmaProtocols.SHVZK(SP1).real : (h = h' /\ w = w' /\ (R1 h' w')) ==> (res <> None)] = 1%r.
proof.
bypr. progress.
have -> := (S1.SigmaProtocols.shvzk_real_never_fail SP1 h{m} w{m} &m).
by have := (completeness_protocol1 h{m} w{m} &m H).
qed.

local lemma shvzk2_real_never_fails h' w':
      phoare[S2.SigmaProtocols.SHVZK(SP2).real : (h = h' /\ w = w' /\ (R2 h' w')) ==> (res <> None)] = 1%r.
proof.
bypr. progress.
have -> := (S2.SigmaProtocols.shvzk_real_never_fail SP2 h{m} w{m} &m).
by have := (completeness_protocol2 h{m} w{m} &m H).
qed.

(* Converting the ambient logic to the pHoare logic *)
local lemma SP1_completeness_pr h' w' : phoare[C1.main : (h = h' /\ w = w' /\ (R1 h' w')) ==> res] = 1%r.
  proof. bypr. progress. by apply (completeness_protocol1 &m) in H. qed.
local lemma SP2_completeness_pr h' w' : phoare[C2.main : (h = h' /\ w = w' /\ (R2 h' w')) ==> res] = 1%r.
  proof. bypr. progress. by apply (completeness_protocol2 &m) in H. qed.

local module Completeness' = {
    var e : challenge
    var v1 : bool
    var v2 : bool
proc completeness1 (h1 : statement1, w : witness1) : bool = {
    var a1, r, z1, v1;
    (a1, r) = SP1.init(h1, w);


    z1 = SP1.response(h1, w, a1, r, e);
    v1 = SP1.verify(h1, a1, e, z1);
    return v1;
}

proc completeness2 (h2 : statement2, w : witness2) : bool = {
    var a2, r, z2, v2;
    (a2, r) = SP2.init(h2, w);

    z2 = SP2.response(h2, w, a2, r, e);
    v2 = SP2.verify(h2, a2, e, z2);
    return v2;
}

proc main(h : statement, w : witness) : bool = {
  var h1, h2, w1, w2;
  (h1, h2) = h;
  (w1, w2) = w;
  e <$ Sigma.SigmaProtocols.dchallenge;
  v1 = completeness1(h1, w1);
  v2 = completeness2(h2, w2);
  return v1 /\ v2;
}
}.

local lemma completeness_sim_equiv h' w' &m:
    (R h' w') =>
    Pr[Sigma.SigmaProtocols.Completeness(ANDProtocol(SP1,SP2)).main(h', w') @ &m : res] =
    Pr[Completeness'.main(h', w') @ &m : (Completeness'.v1 /\ Completeness'.v2)].
proof.
  move=>rel.
  byequiv (: ={h, w, glob SP1, glob SP2} ==> _)=>//. proc. inline *. wp.
  swap{2} [8..9] 4. swap{1} 8 -5.
  swap{2} [8..10] -2.
  swap{2} 9 -1.
  sim.
  wp. call (:true).
  wp. call (:true).
  wp. call (:true).
  wp. call (:true).
  auto.
qed.

local lemma split1_true h' w' &m:
    (R1 (fst h') (fst w')) =>
    Pr[Completeness'.main(h', w') @ &m : Completeness'.v1] = 1%r.
proof. move=> rel. have <- := (completeness_protocol1 (fst h') (fst w') &m rel).
  byequiv=>//.
  proc. inline *.
  swap{2} 2 -1.
  wp. sp. swap{1} [4..7] 5.
  sim.
  kill{1} 5 ! 4.
   - call (lossless_sp2_verify).
     call (lossless_sp2_response).
     call (lossless_sp2_init). auto.
  auto. qed.

local lemma split2_true h' w' &m:
    (R2 (snd h') (snd w')) =>
    Pr[Completeness'.main(h', w') @ &m : Completeness'.v2] = 1%r.
proof. move=> rel. have <- := (completeness_protocol2 (snd h') (snd w') &m rel).
  byequiv=>//.
  proc. inline *.
  swap{2} 2 -1.
  sim.
  kill{1} 5 ! 4.
   - call (lossless_sp1_verify).
     call (lossless_sp1_response).
     call (lossless_sp1_init). auto.
  auto. qed.

local lemma split2_true_phoare h' w':
    phoare[Completeness'.main : (h = h' /\ w = w' /\ (R2 (snd h') (snd w'))) ==> Completeness'.v2] = 1%r.
bypr. progress. by have := (split2_true h{m} w{m} &m H). qed.


local lemma completeness'_true h' w':
    phoare[Completeness'.main : (h = h' /\ w = w' /\ (R h' w')) ==> (Completeness'.v1 /\ Completeness'.v2)] = 1%r.
proof.
  (* rewrite /R. move=>[rel1 rel2]. *)
  phoare split 1%r 1%r 1%r; rewrite /R.
  - progress.
  - bypr. progress. by have := (split1_true h{m} w{m} &m H).
  - bypr. progress. by have := (split2_true h{m} w{m} &m H0).
  - bypr. progress. have <- := (split2_true h{m} w{m} &m H0).
    byequiv=>//. proc *.
    call{1} (split2_true_phoare h{m} w{m}).
    call{2} (split2_true_phoare h{m} w{m}).
    auto. progress. smt().
    qed.

lemma and_completeness h' w' &m:
    (R h' w') =>
    Pr[Sigma.SigmaProtocols.Completeness(ANDProtocol(SP1,SP2)).main(h', w') @ &m : res] = 1%r.
proof.
  move=> rel. have -> := (completeness_sim_equiv h' w' &m rel).
  byphoare(: h = h' /\ w = w' /\ (R h' w') ==> _ )=>//.
  proc *. call (completeness'_true h' w'). auto.
qed.


  local module SHVZK' = {
      proc real(h, w) = {
        var h1, h2, a1, a2, z1, z2, e1, e2, ret, t1, t2;
        (h1, h2) = h;
        if (R1 h1 w) {
          t1 = SHVZK1.real(h1, w);
          t2 = SHVZK2.ideal(h2);
          if (t1 = None \/ t2 = None) {
            ret = None;
          } else {
            (a1, e1, z1) = oget(t1);
            (a2, e2, z2) = oget(t2);
            ret = Some ((a1, e1, z1), (a2, e2, z2));
          }
        } else {
          t2 = SHVZK2.real(h2, w);
          t1 = SHVZK1.ideal(h1);
          if (t1 = None \/ t2 = None) {
            ret = None;
          } else {
            (a1, e1, z1) = oget(t1);
            (a2, e2, z2) = oget(t2);
            ret = Some ((a1, e1, z1), (a2, e2, z2));
          }
        }
        return ret;
      }
      proc ideal(h) = {
        var h1, h2, a1, a2, z1, z2, e1, e2, ret, t1, t2;
        (h1, h2) = h;
        t1 = SHVZK1.ideal(h1);
        t2 = SHVZK2.ideal(h2);
        if (t1 = None \/ t2 = None) {
          ret = None;
        } else {
          (a1, e1, z1) = oget(t1);
          (a2, e2, z2) = oget(t2);
          ret = Some ((a1, e1, z1), (a2, e2, z2));
        }
        return ret;
      }
    }.

    local lemma real_real'_equiv h' w' &m :
        Pr[SHVZK'.real(h', w') @ &m : (res <> None)] =
        Pr[Sigma.SigmaProtocols.SHVZK(ORProtocol(SP1, SP2)).real(h', w') @ &m : (res <> None)].
    proof. byequiv=>//.
    proc. inline *. sp. case (R1 (fst h') w').
    (* case: relation is true *)
    rcondt{1} 1. progress.
    rcondt{2} 1. progress.
    rcondt{2} 14. progress. auto. call (:true). rnd. call(:true). progress.
    sp. auto. call (:true). swap{1} [8..10] -5.
    swap{2} 11 2. swap{2} [13..14] -6.
    auto.
    call (:true). swap{2} [6..8] -3.
    auto. call (:true).
    auto. call (:true). swap{1} 4 -2. wp.
    rnd (fun z => z ^^ e0{1}) (fun q => q ^^ ORProtocol.e2{2}).
    rnd. call (:true).
    auto. progress.
    - apply S1.SigmaProtocols.dchallenge_fu.
    - by rewrite xorK.
    - apply S1.SigmaProtocols.dchallenge_funi.
    - apply S1.SigmaProtocols.dchallenge_fu.
    - by rewrite xorK.
    - smt(xorA xorK).
    (* case: relation is false *)
    rcondf{1} 1. progress.
    rcondf{2} 1. progress.
    rcondf{2} 14. progress. auto. call (:true). rnd. call(:true). progress.
    sp. auto. swap{2} 24 1. call (:true). swap{1} [8..10] -5.
    swap{2} 11 2. swap{2} [13..14] -6.
    auto.
    call (:true). swap{2} [6..8] -3.
    auto. call (:true).
    auto. call (:true). swap{1} 4 -2. wp.
    rnd (fun z => z ^^ e4{1}) (fun q => q ^^ ORProtocol.e1{2}).
    rnd. call (:true).
    auto. progress.
    - apply S1.SigmaProtocols.dchallenge_fu.
    - by rewrite xorK.
    - apply S1.SigmaProtocols.dchallenge_funi.
    - apply S1.SigmaProtocols.dchallenge_fu.
    - by rewrite xorK.
    - smt(xorA xorK).
    qed.

    local lemma ideal_ideal'_equiv h' &m:
        Pr[SHVZK'.ideal(h') @ &m : (res <> None)] =
        Pr[Sigma.SigmaProtocols.SHVZK(ORProtocol(SP1, SP2)).ideal(h') @ &m : (res <> None)].
    proof. byequiv=>//.
    proc. inline *.
    sp. auto. call (:true).
    swap{1} [3..6] 3. auto.
    call (:true). auto.
    call (:true).
    swap{1} 2 2. call (:true).
    swap{1} 3 -2. swap{2} 5 -4. wp.
    rnd (fun z => z ^^ e0{1}) (fun q => q ^^ c2{2}).
    auto. progress.
    - apply SigmaProtocols.dchallenge_fu.
    - by rewrite xorK.
    - apply SigmaProtocols.dchallenge_funi.
    - apply SigmaProtocols.dchallenge_fu.
    - by rewrite xorK.
    - smt().
    qed.


lemma or_shvzk h' w' &m:
    (Sigma.SigmaProtocols.R h' w') =>
    Pr[Sigma.SigmaProtocols.SHVZK(ORProtocol(SP1, SP2)).real(h', w') @ &m : (res <> None)] =
    Pr[Sigma.SigmaProtocols.SHVZK(ORProtocol(SP1, SP2)).ideal(h') @ &m : (res <> None)].
proof.
  move=> rel.
  have <- := (real_real'_equiv h' w' &m).
  have <- := (ideal_ideal'_equiv h' &m).
case (R1 (fst h') w')=> rel_true.
(* case: relation is true *)
byequiv=>//. proc.
auto. rcondt{1} 2. auto. sp.
auto. inline SHVZK2.ideal.
auto. do ? call (:true). auto.
call (shvzk1_equiv (fst h') w'). auto.
(* case: relation is false *)
byequiv=>//. proc.
auto. rcondf{1} 2. auto. sp.
auto. swap{1} 1 1.
call (shvzk2_equiv (snd h') w').
inline SHVZK1.ideal.
auto. do ? call (:true). auto. progress; smt().
qed.

lemma or_special_soundness &m:


end section Security.
end ORProtocol.
