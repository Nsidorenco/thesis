(* Formalization of MPC Phi decomposition *)
require import AllCore Distr List IntDiv DList DInterval.
(** Ignore: This is now the preferred setup but is not yet the default **)
pragma -oldip. pragma +implicits.

type input.
type output.
type share.
type gate.
type random.
type projected_view.
type verification_input = projected_view list.
type challenge = int.

type circuit = gate list.
type view = share list * random.

op challenge : challenge distr.
op output (v : view) : share.
op reconstruct (ss : share list) : output.
op circuit_eval (c : circuit) (x : input) : output.
op valid_circuit (c : circuit) : bool.
op f (vs : view list, e : int) : verification_input.
op f_inv (vs : verification_input) : view list.

const n : int.
const d : int.

axiom n_pos : 0 < n.
axiom d_pos : 0 < d.
axiom d_leq_n : d <= n.

op nth_looping (vs : 'a list) (i : int) =
  nth witness vs (i %% n).

op in_dom_f (n : int) (e : challenge) (i : int) : bool.

op in_doms_f n (es : challenge list) i =
  foldr (fun e acc => acc \/ in_dom_f n e i) false es.

(* op in_dom_f n (e : challenge) i = *)
(*   if (e + d <= n) then i \in [e..e+d-1] else (i \in [e..n-1] \/ i \in [0..d-(n - e)-1]). *)

(* op in_doms_f n (es : challenge list) i = *)
(*    has (fun (e : challenge) =>  *)
(*         if (e + d <= n) then i \in [e..e+d-1] else (i \in [e..n-1] \/ i \in [0..d-(n - e)-1])) *)
(*        es. *)

op proj_mapping (i e : int) : int.
op cyclic_distance e i = min (i - e %% n) (n - e + i).

(* op map_index e i  *)
   (* given view from challenge e recover the view i *)
   (* new offset is based on e: *)
   (*  view e is now view 0  *)
   (*  view e+1 is now view 1 *)
   (*  view i is then the distance from e to i. Where we consider cyclic distance *)

pred fully_consistent (vs' : verification_input list) (es : challenge list) =
  forall (e e'), e \in es /\ e' \in es=>
    (forall j, in_doms_f n [e; e'] j =>
      nth witness (nth witness vs' e) (proj_mapping j e) =
      nth witness (nth witness vs' e') (proj_mapping j e')).

(* pred fully_consistent (vs' : view list list) (es : challenge list) = *)
(*   forall i, 0 <= i < size es => *)
(*     (forall j, in_doms_f n [nth witness es i; nth witness es (i+1 %% size es)] i => *)
(*       nth_looping (nth witness vs' (nth witness es i)) (cyclic_distance (nth witness es i) j) = *)
(*       nth_looping (nth witness vs' (nth witness es ((i + 1) %% size es))) (cyclic_distance (nth witness es ((i + 1) %% size es)) j)). *)

axiom f_inv_correct vs e:
  e \in challenge =>
  forall i, in_dom_f n e i =>
      nth witness vs i = nth witness (f_inv (f vs e)) (proj_mapping i e).

(* axiom f_inv_size vs e: size(f_inv (f vs e)) = min (size vs) d. *)

(* random seed distribution *)
op drandom : {random distr | is_lossless drandom /\ is_uniform drandom} as drandom_lluni.

module type Phi = {
  proc* sample_tapes(n : int) : random list
  proc decomp(c : circuit, x : input, rs : random list) : view list
  proc verify(c : circuit, vs : verification_input, e : int, ys : share list) : bool {}
  proc simulator(c : circuit, y : output, e : int) : verification_input * share list
  proc extractor(vs : verification_input list) : input option
}.

(* module Correctness(D : Phi) = { *)
(*   proc main(c, x) = { *)
(*     var vs, shares, v, y, rs, i; *)
(*     rs <$ dlist drandom n; *)
(*     vs <- D.decomp(c, x, rs); *)
(*     shares <- []; *)
(*     i <- 0; *)
(*     while (i < size vs) { *)
(*       v <- nth witness vs i; *)
(*       shares <- rcons shares (output v); *)
(*       i <- i + 1; *)
(*     } *)
(*     y <- reconstruct(shares); *)
(*     return (circuit_eval c x) = y; *)
(*   } *)
(* }. *)

module Privacy(D : Phi) = {
  proc real(c, x, e) = {
    var rs, vs, ys;
    rs <- D.sample_tapes(size c);
    vs <- D.decomp(c, x, rs);
    ys <- map output vs;
    return ((f vs e), ys);
  }

  proc ideal(c, y, e) = {
    var vs, ys;
    (vs, ys) <- D.simulator(c, y, e);
    return (vs, ys);
  }
}.

module Verifiability(D : Phi) = {
  proc main(c, w, e) = {
    var vs, valid, vs', ys, y, rs, y', ws;
    rs <- D.sample_tapes(size c);
    vs <- D.decomp(c, w, rs);
    ys <- [];
    ys <- (map output vs);
    (* i <- 0; *)
    (* while (i < n) { *)
    (*   v <- nth witness vs i; *)
    (*   ys <- rcons ys (output v); *)
    (*   i <- i + 1; *)
    (* } *)
    y <- reconstruct(ys);
    y' <- circuit_eval c w;
    vs' <- f vs e;
    ws <- f_inv vs';
    valid <- D.verify(c, vs', e, ys);

    return valid /\ y = y';
  }
}.

module Soundness(D : Phi) = {
  proc main(c, vs', es, ys) = {
    var xopt, v,  verified, tmp, i, e;
    verified <- true;
    i <- 0;
    while (i < size vs') {
      v <- (nth witness vs' i);
      e <- (nth witness es i);
      tmp <- D.verify(c, v, e, ys);
      verified <- verified /\ tmp;
      i <- i + 1;
    }

    xopt <- D.extractor(vs');
    (* rs <- D.sample_tapes(n); *)

    (* vs <- D.decomp(c, (oget xopt), rs); *)
    (* shares <- map output vs; *)
    return xopt <> None /\ circuit_eval c (oget xopt) = reconstruct ys;
  }
}.

(* Lemmas: *)
(*---------*)
(* lemma correctness c x rs &m: *)
(*   Pr[Correctness(D).main(c, x, rs) @ &m : res] = 1%r. *)
(*---------*)
(* lemma privacy c' x' y' e': *)
(*     0 < e' /\ e' <= 3 => *)
(*     y' = eval_circuit c' [x'] => *)
(*       equiv[Privacy.real ~ Privacy.ideal : (={c, e} /\ c{1} = c' /\ h{1} = x' /\ y{2} = y' /\ e{1} = e') *)
(*             ==> ={res}]. *)
(*---------*)
(* lemma verifiability c x, y rs &m: *)
(*     Pr[Verifiability(D).main(c, x, rs) @ &m : res] = 1%r. *)
(*---------*)
(* d+1-Special Soundness *)
(* lemma soundness c vs' y &m: *)
(*   (forall i, (0 <= i /\ i <= d + 1) => *)
(*   Pr[D.verify(c, vs', y) @ &m : res] = 1%r) *)
(*   => Pr[Soundness(D).main(c, vs', y) @ &m : res] = 1%r. *)
