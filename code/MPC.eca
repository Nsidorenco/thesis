(* Formalization of MPC Phi decomposition *)
require import AllCore Distr List IntDiv DList.
(** Ignore: This is now the preferred setup but is not yet the default **)
pragma -oldip. pragma +implicits.

type input.
type output.
type share.
type gate.
type random.
type verification_input.

type circuit = gate list.
type view = share list * random.

op challenge : int distr.
op output (v : view) : share.
op reconstruct (ss : share list) : output.
op circuit_eval (c : circuit) (x : input) : output.
op f (vs : view list, e : int) : verification_input.
op f_inv (vs : verification_input) : view list.

const n : int.
const d : int.

axiom n_pos : 0 < n.
axiom d_pos : 0 < d.
axiom e_size e : e \in challenge => e + d <= n.

op nth_looping (vs : 'a list) (i : int) =
  if (i < size vs) then nth witness vs i
  else nth witness vs (i - (size vs)).

axiom f_inv_correct vs e:
  forall i, 0 <= i < d => nth_looping vs (e+i) = nth_looping (f_inv (f vs e)) i.

axiom f_inv_size vs e: size(f_inv (f vs e)) = min (size vs) d.

(* random seed distribution *)
op drandom : {random distr | is_lossless drandom /\ is_funiform drandom} as drandom_llfuni.

module type Phi = {
  proc sample_tapes(n : int) : random list
  proc decomp(c : circuit, x : input, rs : random list) : view list
  proc verify(c : circuit, vs : verification_input, e : int, y : output) : bool {}
  proc simulator(c : circuit, y : output, e : int) : view list * output * verification_input
  proc extractor(vs : verification_input list) : input option
}.

module Correctness(D : Phi) = {
  proc main(c, x) = {
    var vs, shares, v, y, rs;
    rs <$ dlist drandom n;
    vs <- D.decomp(c, x, rs);
    shares <- [];
    while (vs <> []) {
      v <- oget(ohead vs);
      shares <- (output v)::shares;
      vs <- behead vs;
    }
    y <- reconstruct(shares);
    return (circuit_eval c x) = y;
  }
}.

module Privacy(D : Phi) = {
  proc real(c, x, e) = {
    var rs, vs;
    rs <- D.sample_tapes(size c);
    vs <- D.decomp(c, x, rs);
    return (f vs e);
  }

  proc ideal(c, y, e) = {
    var vs;
    vs <- D.simulator(c, y, e);
    return vs;
  }
}.

module Verifiability(D : Phi) = {
  proc main(c, x, e) = {
    var vs, validity, vs', shares, y, v, vs_copy, rs;
    rs <$ dlist drandom n;
    vs <- D.decomp(c, x, rs);
    vs_copy <- vs;
    shares <- [];
    while (vs <> []) {
      v <- oget(ohead vs);
      shares <- (output v)::shares;
      vs <- behead vs;
    }
    y <- reconstruct(shares);
    vs' <- f vs_copy e;
    validity <- D.verify(c, vs', e, y);

    return validity;
  }
}.

module Soundness(D : Phi) = {
  proc main(c, vs', y) = {
    var xopt, x, rs, vs, shares, v, y', verified, e, tmp, v';
    verified <- true;
    e <- 1;
    while (onth vs' (e-1) <> None) {
      v <- oget (onth vs' (e-1));
      tmp <- D.verify(c, v, e, y);
      verified <- verified /\ tmp;
      e <- e + 1;
    }

    xopt <- D.extractor(vs');
    x <- oget xopt;
    rs <$ dlist drandom n;

    vs <- D.decomp(c, x, rs);
    shares <- [];
    while (vs <> []) {
      v' <- oget(ohead vs);
      shares <- (output v')::shares;
      vs <- behead vs;
    }
    y' <- reconstruct(shares);
    return y = y';
  }
}.

(* Lemmas: *)
(*---------*)
(* lemma correctness c x rs &m: *)
(*   Pr[Correctness(D).main(c, x, rs) @ &m : res] = 1%r. *)
(*---------*)
(* lemma privacy c' x' y' e': *)
(*     0 < e' /\ e' <= 3 => *)
(*     y' = eval_circuit c' [x'] => *)
(*       equiv[Privacy.real ~ Privacy.ideal : (={c, e} /\ c{1} = c' /\ h{1} = x' /\ y{2} = y' /\ e{1} = e') *)
(*             ==> ={res}]. *)
(*---------*)
(* lemma verifiability c x, y rs &m: *)
(*     Pr[Verifiability(D).main(c, x, rs) @ &m : res] = 1%r. *)
(*---------*)
(* d+1-Special Soundness *)
(* lemma soundness c vs' y &m: *)
(*   (forall i, (0 <= i /\ i <= d + 1) => *)
(*   Pr[D.verify(c, vs', y) @ &m : res] = 1%r) *)
(*   => Pr[Soundness(D).main(c, vs', y) @ &m : res] = 1%r. *)
