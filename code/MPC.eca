(* Formalization of MPC Phi decomposition *)
require import AllCore Distr List IntDiv DList DInterval.
(** Ignore: This is now the preferred setup but is not yet the default **)
pragma -oldip. pragma +implicits.

type input.
type output.
type share.
type gate.
type random.
type verification_input.
type challenge = int.

type circuit = gate list.
type view = share list * random.

op challenge : challenge distr.
op output (v : view) : share.
op reconstruct (ss : share list) : output.
op circuit_eval (c : circuit) (x : input) : output.
op f (vs : view list, e : int) : verification_input.
op f_inv (vs : verification_input) : view list.

const n : int.
const d : int.

axiom n_pos : 0 < n.
axiom d_pos : 0 < d.
axiom d_leq_n : d <= n.

op nth_looping (vs : 'a list) (i : int) =
  nth witness vs (i %% n).

op in_dom_f n (e : challenge) i =
  if (e + d <= n) then i \in [e..e+d-1] else (i \in [e..n-1] \/ i \in [0..d-(n - e)-1]).

axiom f_inv_correct vs e:
  e \in challenge =>
  forall i, in_dom_f n e i =>
      nth witness vs i = nth_looping (f_inv (f vs e)) (i-e).

(* axiom f_inv_size vs e: size(f_inv (f vs e)) = min (size vs) d. *)

(* random seed distribution *)
op drandom : {random distr | is_lossless drandom /\ is_funiform drandom} as drandom_llfuni.

module type Phi = {
  proc* sample_tapes(n : int) : random list
  proc decomp(c : circuit, x : input, rs : random list) : view list
  proc verify(c : circuit, vs : verification_input, e : int, ys : share list) : bool {}
  proc simulator(c : circuit, y : output, e : int) : verification_input * share list
  proc extractor(vs : verification_input list) : input option
}.

(* module Correctness(D : Phi) = { *)
(*   proc main(c, x) = { *)
(*     var vs, shares, v, y, rs, i; *)
(*     rs <$ dlist drandom n; *)
(*     vs <- D.decomp(c, x, rs); *)
(*     shares <- []; *)
(*     i <- 0; *)
(*     while (i < size vs) { *)
(*       v <- nth witness vs i; *)
(*       shares <- rcons shares (output v); *)
(*       i <- i + 1; *)
(*     } *)
(*     y <- reconstruct(shares); *)
(*     return (circuit_eval c x) = y; *)
(*   } *)
(* }. *)

module Privacy(D : Phi) = {
  proc real(c, x, e) = {
    var rs, vs, ys;
    rs <- D.sample_tapes(size c);
    vs <- D.decomp(c, x, rs);
    ys <- map output vs;
    return ((f vs e), ys);
  }

  proc ideal(c, y, e) = {
    var vs, ys;
    (vs, ys) <- D.simulator(c, y, e);
    return (vs, ys);
  }
}.

module Verifiability(D : Phi) = {
  proc main(c, w, e) = {
    var vs, valid, vs', ys, y, rs, y', ws;
    rs <- D.sample_tapes(size c);
    vs <- D.decomp(c, w, rs);
    ys <- [];
    ys <- (map output vs);
    (* i <- 0; *)
    (* while (i < n) { *)
    (*   v <- nth witness vs i; *)
    (*   ys <- rcons ys (output v); *)
    (*   i <- i + 1; *)
    (* } *)
    y <- reconstruct(ys);
    y' <- circuit_eval c w;
    vs' <- f vs e;
    ws <- f_inv vs';
    valid <- D.verify(c, vs', e, ys);

    return valid /\ y = y';
  }
}.

module Soundness(D : Phi) = {
  proc main(c, vs', ys) = {
    var xopt, x, rs, vs, shares, v, y', verified, e, tmp, v';
    verified <- true;
    e <- 1;
    while (onth vs' (e-1) <> None) {
      v <- oget (onth vs' (e-1));
      tmp <- D.verify(c, v, e, ys);
      verified <- verified /\ tmp;
      e <- e + 1;
    }

    xopt <- D.extractor(vs');
    x <- oget xopt;
    rs <$ dlist drandom n;

    vs <- D.decomp(c, x, rs);
    shares <- [];
    while (vs <> []) {
      v' <- oget(ohead vs);
      shares <- (output v')::shares;
      vs <- behead vs;
    }
    y' <- reconstruct(shares);
    return reconstruct ys = y';
  }
}.

(* Lemmas: *)
(*---------*)
(* lemma correctness c x rs &m: *)
(*   Pr[Correctness(D).main(c, x, rs) @ &m : res] = 1%r. *)
(*---------*)
(* lemma privacy c' x' y' e': *)
(*     0 < e' /\ e' <= 3 => *)
(*     y' = eval_circuit c' [x'] => *)
(*       equiv[Privacy.real ~ Privacy.ideal : (={c, e} /\ c{1} = c' /\ h{1} = x' /\ y{2} = y' /\ e{1} = e') *)
(*             ==> ={res}]. *)
(*---------*)
(* lemma verifiability c x, y rs &m: *)
(*     Pr[Verifiability(D).main(c, x, rs) @ &m : res] = 1%r. *)
(*---------*)
(* d+1-Special Soundness *)
(* lemma soundness c vs' y &m: *)
(*   (forall i, (0 <= i /\ i <= d + 1) => *)
(*   Pr[D.verify(c, vs', y) @ &m : res] = 1%r) *)
(*   => Pr[Soundness(D).main(c, vs', y) @ &m : res] = 1%r. *)
